{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Amazon Bedrock AgentCore","text":"<p>Amazon Bedrock AgentCore is a comprehensive platform for deploying and operating highly effective AI agents securely at scale. The platform includes a Python SDK and Starter Toolkit that work together to help you build, deploy, and manage agent applications.</p> <p> </p> Python SDK Starter Toolkit Samples <p>Preview Status</p> <p>Amazon Bedrock AgentCore is currently in preview release. APIs may change as we refine the platform.</p>"},{"location":"index.html#from-local-development-to-bedrock-agentcore","title":"\ud83d\ude80 From Local Development to Bedrock AgentCore","text":"<pre><code># Your existing agent (any framework)\nfrom strands import Agent\n# or LangGraph, CrewAI, Autogen, custom logic - doesn't matter\n\ndef my_local_agent(query):\n    # Your carefully crafted agent logic\n    return agent.process(query)\n\n# Deploy to Bedrock AgentCore\nfrom bedrock_agentcore import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef production_agent(request):\n    return my_local_agent(request['query'])  # Same logic, enterprise platform\n\nproduction_agent.run()  # Ready to run on Bedrock AgentCore\n</code></pre> <p>What you get with Bedrock AgentCore:</p> <ul> <li>\u2705 Keep your agent logic - Works with Strands, LangGraph, CrewAI, Autogen, custom frameworks.</li> <li>\u2705 Zero infrastructure management - No servers, containers, or scaling concerns.</li> <li>\u2705 Enterprise-grade platform - Built-in auth, memory, observability, security.</li> <li>\u2705 Production-ready deployment - Reliable, scalable, compliant hosting.</li> </ul> <p>Your function is now a production-ready API server with health monitoring, streaming support, and AWS integration.</p>"},{"location":"index.html#platform-components","title":"Platform Components","text":""},{"location":"index.html#bedrock-agentcore-sdk","title":"\ud83d\udd27 Bedrock AgentCore SDK","text":"<p>The SDK provides Python primitives for agent development with built-in support for:</p> <ul> <li>Runtime: Lightweight wrapper to convert functions into API servers</li> <li>Memory: Persistent storage for conversation history and agent context</li> <li>Tools: Built-in clients for code interpretation and browser automation</li> <li>Identity: Secure authentication and access management</li> </ul>"},{"location":"index.html#bedrock-agentcore-starter-toolkit","title":"\ud83d\ude80 Bedrock AgentCore Starter Toolkit","text":"<p>The Toolkit provides CLI tools and higher-level abstractions for:</p> <ul> <li>Deployment: Containerize and deploy agents to AWS infrastructure</li> <li>Import Agent: Migrate existing Bedrock Agents to AgentCore with framework conversion</li> <li>Gateway Integration: Transform existing APIs into agent tools</li> <li>Configuration Management: Manage environment and deployment settings</li> <li>Observability: Monitor agents in production environments</li> </ul>"},{"location":"index.html#platform-services","title":"Platform Services","text":"<p>Amazon Bedrock AgentCore provides enterprise-grade services for AI agent development:</p> <ul> <li>\ud83d\ude80 AgentCore Runtime - Serverless deployment and scaling for dynamic AI agents</li> <li>\ud83e\udde0 AgentCore Memory - Persistent knowledge with event and semantic memory</li> <li>\ud83d\udcbb AgentCore Code Interpreter - Secure code execution in isolated sandboxes</li> <li>\ud83c\udf10 AgentCore Browser - Fast, secure cloud-based browser for web interaction</li> <li>\ud83d\udd17 AgentCore Gateway - Transform existing APIs into agent tools</li> <li>\ud83d\udcca AgentCore Observability - Real-time monitoring and tracing</li> <li>\ud83d\udd10 AgentCore Identity - Secure authentication and access management</li> </ul>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<ul> <li> <p> SDK Quickstart</p> <p>Get started with the core SDK for agent development</p> <p> Start coding</p> </li> <li> <p> Toolkit Guide</p> <p>Learn to deploy and manage agents in production</p> <p> Deploy agents</p> </li> <li> <p> Import Agent</p> <p>Migrate existing Bedrock Agents to AgentCore</p> <p> Import agents</p> </li> <li> <p> API Reference</p> <p>Detailed API documentation for developers</p> <p> Explore APIs</p> </li> </ul>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Zero Code Changes: Your existing functions remain untouched</li> <li>Production Ready: Automatic HTTP endpoints with health monitoring</li> <li>Streaming Support: Native support for generators and async generators</li> <li>Framework Agnostic: Works with any AI framework (Strands, LangGraph, LangChain, custom)</li> <li>AWS Optimized: Ready for deployment to AWS infrastructure</li> <li>Enterprise Security: Built-in identity, isolation, and access controls</li> </ul>"},{"location":"api-reference/cli.html","title":"CLI","text":"<p>Command-line interface for BedrockAgentCore Starter Toolkit.</p> <p>The <code>agentcore</code> CLI provides commands for configuring, launching, managing agents, and working with gateways.</p>"},{"location":"api-reference/cli.html#runtime-commands","title":"Runtime Commands","text":""},{"location":"api-reference/cli.html#configure","title":"Configure","text":"<p>Configure agents and runtime environments.</p> <pre><code>agentcore configure [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--entrypoint, -e TEXT</code>: Python file of agent</p> </li> <li> <p><code>--name, -n TEXT</code>: Agent name (defaults to Python file name)</p> </li> <li> <p><code>--execution-role, -er TEXT</code>: IAM execution role ARN</p> </li> <li> <p><code>--ecr, -ecr TEXT</code>: ECR repository name (use \"auto\" for automatic creation)</p> </li> <li> <p><code>--container-runtime, -ctr TEXT</code>: Container runtime</p> </li> <li> <p><code>--requirements-file, -rf TEXT</code>: Path to requirements file of agent</p> </li> <li> <p><code>--disable-otel, -do</code>: Disable OpenTelemetry</p> </li> <li> <p><code>--authorizer-config, -ac TEXT</code>: OAuth authorizer configuration as JSON string</p> </li> <li> <p><code>--verbose, -v</code>: Enable verbose output</p> </li> <li> <p><code>--region, -r TEXT</code>: AWS region</p> </li> <li> <p><code>--protocol, -p TEXT</code>: Agent server protocol (HTTP or MCP)</p> </li> </ul> <p>Subcommands:</p> <ul> <li> <p><code>list</code>: List configured agents</p> </li> <li> <p><code>set-default</code>: Set default agent</p> </li> </ul>"},{"location":"api-reference/cli.html#launch","title":"Launch","text":"<p>Deploy agents to AWS or run locally.</p> <pre><code>agentcore launch [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--local, -l</code>: Run locally</p> </li> <li> <p><code>--push-ecr, -p</code>: Build and push to ECR only (no deployment)</p> </li> <li> <p><code>--env, -env TEXT</code>: Environment variables for agent (format: KEY=VALUE)</p> </li> </ul>"},{"location":"api-reference/cli.html#invoke","title":"Invoke","text":"<p>Invoke deployed agents.</p> <pre><code>agentcore invoke [PAYLOAD] [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>PAYLOAD</code>: JSON payload to send</li> </ul> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--session-id, -s TEXT</code>: Session ID</p> </li> <li> <p><code>--bearer-token, -bt TEXT</code>: Bearer token for OAuth authentication</p> </li> <li> <p><code>--local, -l</code>: Send request to a running local container</p> </li> <li> <p><code>--user-id, -u TEXT</code>: User ID for authorization flows</p> </li> </ul>"},{"location":"api-reference/cli.html#status","title":"Status","text":"<p>Get Bedrock AgentCore status including config and runtime details.</p> <pre><code>agentcore status [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--verbose, -v</code>: Verbose JSON output of config, agent, and endpoint status</p> </li> </ul>"},{"location":"api-reference/cli.html#gateway-commands","title":"Gateway Commands","text":"<p>Access gateway subcommands:</p> <pre><code>agentcore gateway [COMMAND]\n</code></pre>"},{"location":"api-reference/cli.html#create-mcp-gateway","title":"Create MCP Gateway","text":"<pre><code>agentcore gateway create-mcp-gateway [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--region TEXT</code>: Region to use (defaults to us-west-2)</p> </li> <li> <p><code>--name TEXT</code>: Name of the gateway (defaults to TestGateway)</p> </li> <li> <p><code>--role-arn TEXT</code>: Role ARN to use (creates one if none provided)</p> </li> <li> <p><code>--authorizer-config TEXT</code>: Serialized authorizer config</p> </li> <li> <p><code>--enable-semantic-search, -sem</code>: Whether to enable search tool (defaults to True)</p> </li> </ul>"},{"location":"api-reference/cli.html#create-mcp-gateway-target","title":"Create MCP Gateway Target","text":"<pre><code>agentcore gateway create-mcp-gateway-target [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--gateway-arn TEXT</code>: ARN of the created gateway</p> </li> <li> <p><code>--gateway-url TEXT</code>: URL of the created gateway</p> </li> <li> <p><code>--role-arn TEXT</code>: Role ARN of the created gateway</p> </li> <li> <p><code>--region TEXT</code>: Region to use (defaults to us-west-2)</p> </li> <li> <p><code>--name TEXT</code>: Name of the target (defaults to TestGatewayTarget)</p> </li> <li> <p><code>--target-type TEXT</code>: Type of target (lambda, openApiSchema, smithyModel)</p> </li> <li> <p><code>--target-payload TEXT</code>: Specification of the target (required for openApiSchema)</p> </li> <li> <p><code>--credentials TEXT</code>: Credentials for calling this target (API key or OAuth2)</p> </li> </ul>"},{"location":"api-reference/cli.html#example-usage","title":"Example Usage","text":""},{"location":"api-reference/cli.html#configure-an-agent","title":"Configure an Agent","text":"<pre><code># Basic configuration\nagentcore configure --entrypoint agent_example.pt\n\n# Configure with execution role\nagentcore configure --entrypoint agent_example.py --execution-role arn:aws:iam::123456789012:role/MyRole\n\n# List configured agents\nagentcore configure list\n\n# Set default agent\nagentcore configure set-default my_agent\n</code></pre>"},{"location":"api-reference/cli.html#deploy-and-run-agents","title":"Deploy and Run Agents","text":"<pre><code># Deploy to AWS\nagentcore launch\n\n# Run locally\nagentcore launch --local\n\n# Launch with environment variables\nagentcore launch --env API_KEY=abc123 --env DEBUG=true\n</code></pre>"},{"location":"api-reference/cli.html#invoke-agents","title":"Invoke Agents","text":"<pre><code># Basic invocation\nagentcore invoke '{\"prompt\": \"Hello world!\"}'\n\n# Invoke with session ID\nagentcore invoke '{\"prompt\": \"Continue our conversation\"}' --session-id abc123\n\n# Invoke with OAuth authentication\nagentcore invoke '{\"prompt\": \"Secure request\"}' --bearer-token eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n\n# Invoke local agent\nagentcore invoke '{\"prompt\": \"Test locally\"}' --local\n</code></pre>"},{"location":"api-reference/cli.html#check-status","title":"Check Status","text":"<pre><code># Get status of default agent\nagentcore status\n\n# Get status of specific agent\nagentcore status --agent my-agent\n</code></pre>"},{"location":"api-reference/cli.html#gateway-operations","title":"Gateway Operations","text":"<pre><code># Create MCP Gateway\nagentcore gateway create-mcp-gateway --name MyGateway\n\n# Create MCP Gateway Target\nagentcore gateway create-mcp-gateway-target \\\n  --gateway-arn arn:aws:bedrock-agentcore:us-west-2:123456789012:gateway/abcdef \\\n  --gateway-url https://gateway-url.us-west-2.amazonaws.com \\\n  --role-arn arn:aws:iam::123456789012:role/GatewayRole\n</code></pre>"},{"location":"api-reference/cli.html#importing-from-bedrock-agents","title":"Importing from Bedrock Agents","text":"<pre><code># Interactive Mode\nagentcore import-agent\n\n# For Automation\nagentcore import-agent \\\n  --region us-east-1 \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --output-dir ./my-agent \\\n  --deploy-runtime \\\n  --run-option runtime\n\n# AgentCore Primitive Opt-out\nagentcore import-agent --disable-gateway --disable-memory --disable-code-interpreter --disable-observability\n</code></pre>"},{"location":"api-reference/identity.html","title":"Identity","text":"<p>Memory management for Bedrock AgentCore SDK.</p>"},{"location":"api-reference/identity.html#service-client","title":"Service client","text":""},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity","title":"<code>bedrock_agentcore.services.identity</code>","text":"<p>The main high-level client for the Bedrock AgentCore Identity service.</p>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient","title":"<code>IdentityClient</code>","text":"<p>A high-level client for Bedrock AgentCore Identity.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>class IdentityClient:\n    \"\"\"A high-level client for Bedrock AgentCore Identity.\"\"\"\n\n    def __init__(self, region: str):\n        \"\"\"Initialize the identity client with the specified region.\"\"\"\n        self.region = region\n        self.cp_client = boto3.client(\n            \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_control_plane_endpoint(region)\n        )\n        self.identity_client = boto3.client(\n            \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self.dp_client = boto3.client(\n            \"bedrock-agentcore\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self.logger = logging.getLogger(\"bedrock_agentcore.identity_client\")\n\n    def create_oauth2_credential_provider(self, req):\n        \"\"\"Create an OAuth2 credential provider.\"\"\"\n        self.logger.info(\"Creating OAuth2 credential provider...\")\n        return self.cp_client.create_oauth2_credential_provider(**req)\n\n    def create_api_key_credential_provider(self, req):\n        \"\"\"Create an API key credential provider.\"\"\"\n        self.logger.info(\"Creating API key credential provider...\")\n        return self.cp_client.create_api_key_credential_provider(**req)\n\n    def get_workload_access_token(\n        self, workload_name: str, user_token: Optional[str] = None, user_id: Optional[str] = None\n    ) -&gt; Dict:\n        \"\"\"Get a workload access token using workload name and optionally user token.\"\"\"\n        if user_token:\n            if user_id is not None:\n                self.logger.warning(\"Both user token and user id are supplied, using user token\")\n            self.logger.info(\"Getting workload access token for JWT...\")\n            resp = self.dp_client.get_workload_access_token_for_jwt(workloadName=workload_name, userToken=user_token)\n        elif user_id:\n            self.logger.info(\"Getting workload access token for user id...\")\n            resp = self.dp_client.get_workload_access_token_for_user_id(workloadName=workload_name, userId=user_id)\n        else:\n            self.logger.info(\"Getting workload access token...\")\n            resp = self.dp_client.get_workload_access_token(workloadName=workload_name)\n\n        self.logger.info(\"Successfully retrieved workload access token\")\n        return resp\n\n    def create_workload_identity(self, name: Optional[str] = None) -&gt; Dict:\n        \"\"\"Create workload identity with optional name.\"\"\"\n        self.logger.info(\"Creating workload identity...\")\n        if not name:\n            name = f\"workload-{uuid.uuid4().hex[:8]}\"\n        return self.identity_client.create_workload_identity(name=name)\n\n    async def get_token(\n        self,\n        *,\n        provider_name: str,\n        scopes: Optional[List[str]] = None,\n        agent_identity_token: str,\n        on_auth_url: Optional[Callable[[str], Any]] = None,\n        auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n        callback_url: Optional[str] = None,\n        force_authentication: bool = False,\n        token_poller: Optional[TokenPoller] = None,\n    ) -&gt; str:\n        \"\"\"Get an OAuth2 access token for the specified provider.\n\n        Args:\n            provider_name: The credential provider name\n            scopes: Optional list of OAuth2 scopes to request\n            agent_identity_token: Agent identity token for authentication\n            on_auth_url: Callback for handling authorization URLs\n            auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n            callback_url: OAuth2 callback URL (must be pre-registered)\n            force_authentication: Force re-authentication even if token exists in the token vault\n            token_poller: Custom token poller implementation\n\n        Returns:\n            The access token string\n\n        Raises:\n            RequiresUserConsentException: When user consent is needed\n            Various other exceptions for error conditions\n        \"\"\"\n        self.logger.info(\"Getting OAuth2 token...\")\n\n        # Build parameters\n        req = {\n            \"resourceCredentialProviderName\": provider_name,\n            \"scopes\": scopes,\n            \"oauth2Flow\": auth_flow,\n            \"workloadIdentityToken\": agent_identity_token,\n        }\n\n        # Add optional parameters\n        if callback_url:\n            req[\"resourceOauth2ReturnUrl\"] = callback_url\n        if force_authentication:\n            req[\"forceAuthentication\"] = force_authentication\n\n        response = self.dp_client.get_resource_oauth2_token(**req)\n\n        # If we got a token directly, return it\n        if \"accessToken\" in response:\n            return response[\"accessToken\"]\n\n        # If we got an authorization URL, handle the OAuth flow\n        if \"authorizationUrl\" in response:\n            auth_url = response[\"authorizationUrl\"]\n            # Notify about the auth URL if callback provided\n            if on_auth_url:\n                if asyncio.iscoroutinefunction(on_auth_url):\n                    await on_auth_url(auth_url)\n                else:\n                    on_auth_url(auth_url)\n\n            # only the initial request should have force authentication\n            if force_authentication:\n                req[\"forceAuthentication\"] = False\n\n            # Poll for the token\n            active_poller = token_poller or _DefaultApiTokenPoller(\n                auth_url, lambda: self.dp_client.get_resource_oauth2_token(**req).get(\"accessToken\", None)\n            )\n            return await active_poller.poll_for_token()\n\n        raise RuntimeError(\"Identity service did not return a token or an authorization URL.\")\n\n    async def get_api_key(self, *, provider_name: str, agent_identity_token: str) -&gt; str:\n        \"\"\"Programmatically retrieves an API key from the Identity service.\"\"\"\n        self.logger.info(\"Getting API key...\")\n        req = {\"resourceCredentialProviderName\": provider_name, \"workloadIdentityToken\": agent_identity_token}\n\n        return self.dp_client.get_resource_api_key(**req)[\"apiKey\"]\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize the identity client with the specified region.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def __init__(self, region: str):\n    \"\"\"Initialize the identity client with the specified region.\"\"\"\n    self.region = region\n    self.cp_client = boto3.client(\n        \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_control_plane_endpoint(region)\n    )\n    self.identity_client = boto3.client(\n        \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self.dp_client = boto3.client(\n        \"bedrock-agentcore\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self.logger = logging.getLogger(\"bedrock_agentcore.identity_client\")\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_api_key_credential_provider","title":"<code>create_api_key_credential_provider(req)</code>","text":"<p>Create an API key credential provider.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_api_key_credential_provider(self, req):\n    \"\"\"Create an API key credential provider.\"\"\"\n    self.logger.info(\"Creating API key credential provider...\")\n    return self.cp_client.create_api_key_credential_provider(**req)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_oauth2_credential_provider","title":"<code>create_oauth2_credential_provider(req)</code>","text":"<p>Create an OAuth2 credential provider.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_oauth2_credential_provider(self, req):\n    \"\"\"Create an OAuth2 credential provider.\"\"\"\n    self.logger.info(\"Creating OAuth2 credential provider...\")\n    return self.cp_client.create_oauth2_credential_provider(**req)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_workload_identity","title":"<code>create_workload_identity(name=None)</code>","text":"<p>Create workload identity with optional name.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_workload_identity(self, name: Optional[str] = None) -&gt; Dict:\n    \"\"\"Create workload identity with optional name.\"\"\"\n    self.logger.info(\"Creating workload identity...\")\n    if not name:\n        name = f\"workload-{uuid.uuid4().hex[:8]}\"\n    return self.identity_client.create_workload_identity(name=name)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_api_key","title":"<code>get_api_key(*, provider_name, agent_identity_token)</code>  <code>async</code>","text":"<p>Programmatically retrieves an API key from the Identity service.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>async def get_api_key(self, *, provider_name: str, agent_identity_token: str) -&gt; str:\n    \"\"\"Programmatically retrieves an API key from the Identity service.\"\"\"\n    self.logger.info(\"Getting API key...\")\n    req = {\"resourceCredentialProviderName\": provider_name, \"workloadIdentityToken\": agent_identity_token}\n\n    return self.dp_client.get_resource_api_key(**req)[\"apiKey\"]\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_token","title":"<code>get_token(*, provider_name, scopes=None, agent_identity_token, on_auth_url=None, auth_flow, callback_url=None, force_authentication=False, token_poller=None)</code>  <code>async</code>","text":"<p>Get an OAuth2 access token for the specified provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>scopes</code> <code>Optional[List[str]]</code> <p>Optional list of OAuth2 scopes to request</p> <code>None</code> <code>agent_identity_token</code> <code>str</code> <p>Agent identity token for authentication</p> required <code>on_auth_url</code> <code>Optional[Callable[[str], Any]]</code> <p>Callback for handling authorization URLs</p> <code>None</code> <code>auth_flow</code> <code>Literal['M2M', 'USER_FEDERATION']</code> <p>Authentication flow type (\"M2M\" or \"USER_FEDERATION\")</p> required <code>callback_url</code> <code>Optional[str]</code> <p>OAuth2 callback URL (must be pre-registered)</p> <code>None</code> <code>force_authentication</code> <code>bool</code> <p>Force re-authentication even if token exists in the token vault</p> <code>False</code> <code>token_poller</code> <code>Optional[TokenPoller]</code> <p>Custom token poller implementation</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The access token string</p> <p>Raises:</p> Type Description <code>RequiresUserConsentException</code> <p>When user consent is needed</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>async def get_token(\n    self,\n    *,\n    provider_name: str,\n    scopes: Optional[List[str]] = None,\n    agent_identity_token: str,\n    on_auth_url: Optional[Callable[[str], Any]] = None,\n    auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n    callback_url: Optional[str] = None,\n    force_authentication: bool = False,\n    token_poller: Optional[TokenPoller] = None,\n) -&gt; str:\n    \"\"\"Get an OAuth2 access token for the specified provider.\n\n    Args:\n        provider_name: The credential provider name\n        scopes: Optional list of OAuth2 scopes to request\n        agent_identity_token: Agent identity token for authentication\n        on_auth_url: Callback for handling authorization URLs\n        auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n        callback_url: OAuth2 callback URL (must be pre-registered)\n        force_authentication: Force re-authentication even if token exists in the token vault\n        token_poller: Custom token poller implementation\n\n    Returns:\n        The access token string\n\n    Raises:\n        RequiresUserConsentException: When user consent is needed\n        Various other exceptions for error conditions\n    \"\"\"\n    self.logger.info(\"Getting OAuth2 token...\")\n\n    # Build parameters\n    req = {\n        \"resourceCredentialProviderName\": provider_name,\n        \"scopes\": scopes,\n        \"oauth2Flow\": auth_flow,\n        \"workloadIdentityToken\": agent_identity_token,\n    }\n\n    # Add optional parameters\n    if callback_url:\n        req[\"resourceOauth2ReturnUrl\"] = callback_url\n    if force_authentication:\n        req[\"forceAuthentication\"] = force_authentication\n\n    response = self.dp_client.get_resource_oauth2_token(**req)\n\n    # If we got a token directly, return it\n    if \"accessToken\" in response:\n        return response[\"accessToken\"]\n\n    # If we got an authorization URL, handle the OAuth flow\n    if \"authorizationUrl\" in response:\n        auth_url = response[\"authorizationUrl\"]\n        # Notify about the auth URL if callback provided\n        if on_auth_url:\n            if asyncio.iscoroutinefunction(on_auth_url):\n                await on_auth_url(auth_url)\n            else:\n                on_auth_url(auth_url)\n\n        # only the initial request should have force authentication\n        if force_authentication:\n            req[\"forceAuthentication\"] = False\n\n        # Poll for the token\n        active_poller = token_poller or _DefaultApiTokenPoller(\n            auth_url, lambda: self.dp_client.get_resource_oauth2_token(**req).get(\"accessToken\", None)\n        )\n        return await active_poller.poll_for_token()\n\n    raise RuntimeError(\"Identity service did not return a token or an authorization URL.\")\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_workload_access_token","title":"<code>get_workload_access_token(workload_name, user_token=None, user_id=None)</code>","text":"<p>Get a workload access token using workload name and optionally user token.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def get_workload_access_token(\n    self, workload_name: str, user_token: Optional[str] = None, user_id: Optional[str] = None\n) -&gt; Dict:\n    \"\"\"Get a workload access token using workload name and optionally user token.\"\"\"\n    if user_token:\n        if user_id is not None:\n            self.logger.warning(\"Both user token and user id are supplied, using user token\")\n        self.logger.info(\"Getting workload access token for JWT...\")\n        resp = self.dp_client.get_workload_access_token_for_jwt(workloadName=workload_name, userToken=user_token)\n    elif user_id:\n        self.logger.info(\"Getting workload access token for user id...\")\n        resp = self.dp_client.get_workload_access_token_for_user_id(workloadName=workload_name, userId=user_id)\n    else:\n        self.logger.info(\"Getting workload access token...\")\n        resp = self.dp_client.get_workload_access_token(workloadName=workload_name)\n\n    self.logger.info(\"Successfully retrieved workload access token\")\n    return resp\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.TokenPoller","title":"<code>TokenPoller</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for token polling implementations.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>class TokenPoller(ABC):\n    \"\"\"Abstract base class for token polling implementations.\"\"\"\n\n    @abstractmethod\n    async def poll_for_token(self) -&gt; str:\n        \"\"\"Poll for a token and return it when available.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.TokenPoller.poll_for_token","title":"<code>poll_for_token()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Poll for a token and return it when available.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>@abstractmethod\nasync def poll_for_token(self) -&gt; str:\n    \"\"\"Poll for a token and return it when available.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api-reference/identity.html#decorators","title":"Decorators","text":""},{"location":"api-reference/identity.html#bedrock_agentcore.identity","title":"<code>bedrock_agentcore.identity</code>","text":"<p>Bedrock AgentCore SDK identity package.</p>"},{"location":"api-reference/identity.html#bedrock_agentcore.identity.requires_access_token","title":"<code>requires_access_token(*, provider_name, into='access_token', scopes, on_auth_url=None, auth_flow, callback_url=None, force_authentication=False, token_poller=None)</code>","text":"<p>Decorator that fetches an OAuth2 access token before calling the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>into</code> <code>str</code> <p>Parameter name to inject the token into</p> <code>'access_token'</code> <code>scopes</code> <code>List[str]</code> <p>OAuth2 scopes to request</p> required <code>on_auth_url</code> <code>Optional[Callable[[str], Any]]</code> <p>Callback for handling authorization URLs</p> <code>None</code> <code>auth_flow</code> <code>Literal['M2M', 'USER_FEDERATION']</code> <p>Authentication flow type (\"M2M\" or \"USER_FEDERATION\")</p> required <code>callback_url</code> <code>Optional[str]</code> <p>OAuth2 callback URL</p> <code>None</code> <code>force_authentication</code> <code>bool</code> <p>Force re-authentication</p> <code>False</code> <code>token_poller</code> <code>Optional[TokenPoller]</code> <p>Custom token poller implementation</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorator function</p> Source code in <code>bedrock_agentcore/identity/auth.py</code> <pre><code>def requires_access_token(\n    *,\n    provider_name: str,\n    into: str = \"access_token\",\n    scopes: List[str],\n    on_auth_url: Optional[Callable[[str], Any]] = None,\n    auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n    callback_url: Optional[str] = None,\n    force_authentication: bool = False,\n    token_poller: Optional[TokenPoller] = None,\n) -&gt; Callable:\n    \"\"\"Decorator that fetches an OAuth2 access token before calling the decorated function.\n\n    Args:\n        provider_name: The credential provider name\n        into: Parameter name to inject the token into\n        scopes: OAuth2 scopes to request\n        on_auth_url: Callback for handling authorization URLs\n        auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n        callback_url: OAuth2 callback URL\n        force_authentication: Force re-authentication\n        token_poller: Custom token poller implementation\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        client = IdentityClient(_get_region())\n\n        async def _get_token() -&gt; str:\n            \"\"\"Common token fetching logic.\"\"\"\n            return await client.get_token(\n                provider_name=provider_name,\n                agent_identity_token=await _get_workload_access_token(client),\n                scopes=scopes,\n                on_auth_url=on_auth_url,\n                auth_flow=auth_flow,\n                callback_url=callback_url,\n                force_authentication=force_authentication,\n                token_poller=token_poller,\n            )\n\n        @wraps(func)\n        async def async_wrapper(*args: Any, **kwargs_func: Any) -&gt; Any:\n            token = await _get_token()\n            kwargs_func[into] = token\n            return await func(*args, **kwargs_func)\n\n        @wraps(func)\n        def sync_wrapper(*args: Any, **kwargs_func: Any) -&gt; Any:\n            if _has_running_loop():\n                # for async env, eg. runtime\n                ctx = contextvars.copy_context()\n                import concurrent.futures\n\n                with concurrent.futures.ThreadPoolExecutor() as executor:\n                    future = executor.submit(ctx.run, asyncio.run, _get_token())\n                    token = future.result()\n            else:\n                # for sync env, eg. local dev\n                token = asyncio.run(_get_token())\n\n            kwargs_func[into] = token\n            return func(*args, **kwargs_func)\n\n        # Return appropriate wrapper based on function type\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.identity.requires_api_key","title":"<code>requires_api_key(*, provider_name, into='api_key')</code>","text":"<p>Decorator that fetches an API key before calling the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>into</code> <code>str</code> <p>Parameter name to inject the API key into</p> <code>'api_key'</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorator function</p> Source code in <code>bedrock_agentcore/identity/auth.py</code> <pre><code>def requires_api_key(*, provider_name: str, into: str = \"api_key\") -&gt; Callable:\n    \"\"\"Decorator that fetches an API key before calling the decorated function.\n\n    Args:\n        provider_name: The credential provider name\n        into: Parameter name to inject the API key into\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        client = IdentityClient(_get_region())\n\n        async def _get_api_key():\n            return await client.get_api_key(\n                provider_name=provider_name,\n                agent_identity_token=await _get_workload_access_token(client),\n            )\n\n        @wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            api_key = await _get_api_key()\n            kwargs[into] = api_key\n            return await func(*args, **kwargs)\n\n        @wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            if _has_running_loop():\n                # for async env, eg. runtime\n                ctx = contextvars.copy_context()\n                import concurrent.futures\n\n                with concurrent.futures.ThreadPoolExecutor() as executor:\n                    future = executor.submit(ctx.run, asyncio.run, _get_api_key())\n                    api_key = future.result()\n            else:\n                # for sync env, eg. local dev\n                api_key = asyncio.run(_get_api_key())\n\n            kwargs[into] = api_key\n            return func(*args, **kwargs)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api-reference/memory.html","title":"Memory","text":"<p>Memory management for Bedrock AgentCore SDK.</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory","title":"<code>bedrock_agentcore.memory</code>","text":"<p>Bedrock AgentCore Memory module for agent memory management capabilities.</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient","title":"<code>MemoryClient</code>","text":"<p>High-level Bedrock AgentCore Memory client with essential operations.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>class MemoryClient:\n    \"\"\"High-level Bedrock AgentCore Memory client with essential operations.\"\"\"\n\n    def __init__(self, region_name: Optional[str] = None):\n        \"\"\"Initialize the Memory client.\"\"\"\n        self.region_name = region_name or boto3.Session().region_name or \"us-west-2\"\n\n        self.gmcp_client = boto3.client(\"bedrock-agentcore-control\", region_name=self.region_name)\n        self.gmdp_client = boto3.client(\"bedrock-agentcore\", region_name=self.region_name)\n\n        logger.info(\n            \"Initialized MemoryClient for control plane: %s, data plane: %s\",\n            self.gmcp_client.meta.region_name,\n            self.gmdp_client.meta.region_name,\n        )\n\n    def create_memory(\n        self,\n        name: str,\n        strategies: Optional[List[Dict[str, Any]]] = None,\n        description: Optional[str] = None,\n        event_expiry_days: int = 90,\n        memory_execution_role_arn: Optional[str] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory with simplified configuration.\"\"\"\n        if strategies is None:\n            strategies = []\n\n        try:\n            processed_strategies = self._add_default_namespaces(strategies)\n\n            params = {\n                \"name\": name,\n                \"eventExpiryDuration\": event_expiry_days,\n                \"memoryStrategies\": processed_strategies,  # Using old field name for input\n                \"clientToken\": str(uuid.uuid4()),\n            }\n\n            if description is not None:\n                params[\"description\"] = description\n\n            if memory_execution_role_arn is not None:\n                params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n            response = self.gmcp_client.create_memory(**params)\n\n            memory = response[\"memory\"]\n            # Normalize response to handle new field names\n            memory = self._normalize_memory_response(memory)\n\n            logger.info(\"Created memory: %s\", memory[\"memoryId\"])\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to create memory: %s\", e)\n            raise\n\n    def create_memory_and_wait(\n        self,\n        name: str,\n        strategies: List[Dict[str, Any]],\n        description: Optional[str] = None,\n        event_expiry_days: int = 90,\n        memory_execution_role_arn: Optional[str] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory and wait for it to become ACTIVE.\n\n        This method creates a memory and polls until it reaches ACTIVE status,\n        providing a convenient way to ensure the memory is ready for use.\n\n        Args:\n            name: Name for the memory resource\n            strategies: List of strategy configurations\n            description: Optional description\n            event_expiry_days: How long to retain events (default: 90 days)\n            memory_execution_role_arn: IAM role ARN for memory execution\n            max_wait: Maximum seconds to wait (default: 300)\n            poll_interval: Seconds between status checks (default: 10)\n\n        Returns:\n            Created memory object in ACTIVE status\n\n        Raises:\n            TimeoutError: If memory doesn't become ACTIVE within max_wait\n            RuntimeError: If memory creation fails\n        \"\"\"\n        # Create the memory\n        memory = self.create_memory(\n            name=name,\n            strategies=strategies,\n            description=description,\n            event_expiry_days=event_expiry_days,\n            memory_execution_role_arn=memory_execution_role_arn,\n        )\n\n        memory_id = memory.get(\"memoryId\", memory.get(\"id\"))  # Handle both field names\n        if memory_id is None:\n            memory_id = \"\"\n        logger.info(\"Created memory %s, waiting for ACTIVE status...\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                status = self.get_memory_status(memory_id)\n\n                if status == MemoryStatus.ACTIVE.value:\n                    logger.info(\"Memory %s is now ACTIVE (took %d seconds)\", memory_id, elapsed)\n                    # Get fresh memory details\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    memory = self._normalize_memory_response(response[\"memory\"])\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    # Get failure reason if available\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(\"Memory creation failed: %s\" % failure_reason)\n                else:\n                    logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s did not become ACTIVE within %d seconds\" % (memory_id, max_wait))\n\n    def retrieve_memories(\n        self, memory_id: str, namespace: str, query: str, actor_id: Optional[str] = None, top_k: int = 3\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Retrieve relevant memories from a namespace.\n\n        Note: Wildcards (*) are NOT supported in namespaces. You must provide the\n        exact namespace path with all variables resolved.\n\n        Args:\n            memory_id: Memory resource ID\n            namespace: Exact namespace path (no wildcards)\n            query: Search query\n            actor_id: Optional actor ID (deprecated, use namespace)\n            top_k: Number of results to return\n\n        Returns:\n            List of memory records\n\n        Example:\n            # Correct - exact namespace\n            memories = client.retrieve_memories(\n                memory_id=\"mem-123\",\n                namespace=\"support/facts/session-456\",\n                query=\"customer preferences\"\n            )\n\n            # Incorrect - wildcards not supported\n            # memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)\n        \"\"\"\n        if \"*\" in namespace:\n            logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n            return []\n\n        try:\n            # Let service handle all namespace validation\n            response = self.gmdp_client.retrieve_memory_records(\n                memoryId=memory_id, namespace=namespace, searchCriteria={\"searchQuery\": query, \"topK\": top_k}\n            )\n\n            memories = response.get(\"memoryRecordSummaries\", [])\n            logger.info(\"Retrieved %d memories from namespace: %s\", len(memories), namespace)\n            return memories\n\n        except ClientError as e:\n            error_code = e.response[\"Error\"][\"Code\"]\n            error_msg = e.response[\"Error\"][\"Message\"]\n\n            if error_code == \"ResourceNotFoundException\":\n                logger.warning(\n                    \"Memory or namespace not found. Ensure memory %s exists and namespace '%s' is configured\",\n                    memory_id,\n                    namespace,\n                )\n            elif error_code == \"ValidationException\":\n                logger.warning(\"Invalid search parameters: %s\", error_msg)\n            elif error_code == \"ServiceException\":\n                logger.warning(\"Service error: %s. This may be temporary - try again later\", error_msg)\n            else:\n                logger.warning(\"Memory retrieval failed (%s): %s\", error_code, error_msg)\n\n            return []\n\n    def create_event(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n        branch: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Save an event of an agent interaction or conversation with a user.\n\n        This is the basis of short-term memory. If you configured your Memory resource\n        to have MemoryStrategies, then events that are saved in short-term memory via\n        create_event will be used to extract long-term memory records.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier (could be id of your user or an agent)\n            session_id: Session identifier (meant to logically group a series of events)\n            messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n            event_timestamp: timestamp for the entire event (not per message)\n            branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n                   For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n                   A branch is used when you want to have a different history of events.\n\n        Returns:\n            Created event\n\n        Example:\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                messages=[\n                    (\"What's the weather?\", \"USER\"),\n                    (\"Today is sunny\", \"ASSISTANT\")\n                ]\n            )\n            root_event_id = event.get(\"eventId\")\n            print(event)\n\n            # Continue the conversation\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                messages=[\n                    (\"How about the weather tomorrow\", \"USER\"),\n                    (\"Tomorrow is cold!\", \"ASSISTANT\")\n                ]\n            )\n            print(event)\n\n            # branch the conversation so that the previous message is not part of the history\n            # (suppose you did not mean to ask about the weather tomorrow and want to undo\n            # that, and replace with a new message)\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},\n                messages=[\n                    (\"How about the weather a year from now\", \"USER\"),\n                    (\"I can't predict that far into the future!\", \"ASSISTANT\")\n                ]\n            )\n            print(event)\n        \"\"\"\n        try:\n            if not messages:\n                raise ValueError(\"At least one message is required\")\n\n            payload = []\n            for msg in messages:\n                if len(msg) != 2:\n                    raise ValueError(\"Each message must be (text, role)\")\n\n                text, role = msg\n\n                try:\n                    role_enum = MessageRole(role.upper())\n                except ValueError as err:\n                    raise ValueError(\n                        \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                    ) from err\n\n                payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n            # Use provided timestamp or current time\n            if event_timestamp is None:\n                event_timestamp = datetime.utcnow()\n\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"eventTimestamp\": event_timestamp,\n                \"payload\": payload,\n            }\n\n            if branch:\n                params[\"branch\"] = branch\n\n            response = self.gmdp_client.create_event(**params)\n\n            event = response[\"event\"]\n            logger.info(\"Created event: %s\", event[\"eventId\"])\n\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to create event: %s\", e)\n            raise\n\n    def save_conversation(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n        branch: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"DEPRECATED: Use create_event() instead.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n            event_timestamp: Optional timestamp for the entire event (not per message)\n            branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n                   For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n\n        Returns:\n            Created event\n\n        Example:\n            # Save multi-turn conversation\n            event = client.save_conversation(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                messages=[\n                    (\"What's the weather?\", \"USER\"),\n                    (\"And tomorrow?\", \"USER\"),\n                    (\"Checking weather...\", \"TOOL\"),\n                    (\"Today sunny, tomorrow rain\", \"ASSISTANT\")\n                ]\n            )\n\n            # Continue existing branch (only name required)\n            event = client.save_conversation(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                messages=[(\"Continue conversation\", \"USER\")],\n                branch={\"name\": \"existing-branch\"}\n            )\n        \"\"\"\n        try:\n            if not messages:\n                raise ValueError(\"At least one message is required\")\n\n            # Build payload\n            payload = []\n\n            for msg in messages:\n                if len(msg) != 2:\n                    raise ValueError(\"Each message must be (text, role)\")\n\n                text, role = msg\n\n                # Validate role\n                try:\n                    role_enum = MessageRole(role.upper())\n                except ValueError as err:\n                    raise ValueError(\n                        \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                    ) from err\n\n                payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n            # Use provided timestamp or current time\n            if event_timestamp is None:\n                event_timestamp = datetime.utcnow()\n\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"eventTimestamp\": event_timestamp,\n                \"payload\": payload,\n                \"clientToken\": str(uuid.uuid4()),\n            }\n\n            if branch:\n                params[\"branch\"] = branch\n\n            response = self.gmdp_client.create_event(**params)\n\n            event = response[\"event\"]\n            logger.info(\"Created event: %s\", event[\"eventId\"])\n\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to create event: %s\", e)\n            raise\n\n    def save_turn(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        agent_response: str,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"DEPRECATED: Use save_conversation() for more flexibility.\n\n        This method will be removed in v1.0.0.\n        \"\"\"\n        warnings.warn(\n            \"save_turn() is deprecated and will be removed in v1.0.0. \"\n            \"Use save_conversation() for flexible message handling.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        messages = [(user_input, \"USER\"), (agent_response, \"ASSISTANT\")]\n\n        return self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=messages,\n            event_timestamp=event_timestamp,\n        )\n\n    def process_turn(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        agent_response: str,\n        event_timestamp: Optional[datetime] = None,\n        retrieval_namespace: Optional[str] = None,\n        retrieval_query: Optional[str] = None,\n        top_k: int = 3,\n    ) -&gt; Tuple[List[Dict[str, Any]], Dict[str, Any]]:\n        \"\"\"DEPRECATED: Use retrieve_memories() and save_conversation() separately.\n\n        This method will be removed in v1.0.0.\n        \"\"\"\n        warnings.warn(\n            \"process_turn() is deprecated and will be removed in v1.0.0. \"\n            \"Use retrieve_memories() and save_conversation() separately, or use process_turn_with_llm().\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        retrieved_memories = []\n\n        if retrieval_namespace:\n            search_query = retrieval_query or user_input\n            retrieved_memories = self.retrieve_memories(\n                memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n            )\n\n        event = self.save_turn(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            user_input=user_input,\n            agent_response=agent_response,\n            event_timestamp=event_timestamp,\n        )\n\n        return retrieved_memories, event\n\n    def process_turn_with_llm(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n        retrieval_namespace: Optional[str] = None,\n        retrieval_query: Optional[str] = None,\n        top_k: int = 3,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n        r\"\"\"Complete conversation turn with LLM callback integration.\n\n        This method combines memory retrieval, LLM invocation, and response storage\n        in a single call using a callback pattern.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier (e.g., \"user-123\")\n            session_id: Session identifier\n            user_input: The user's message\n            llm_callback: Function that takes (user_input, memories) and returns agent_response\n                         The callback receives the user input and retrieved memories,\n                         and should return the agent's response string\n            retrieval_namespace: Namespace to search for memories (optional)\n            retrieval_query: Custom search query (defaults to user_input)\n            top_k: Number of memories to retrieve\n            event_timestamp: Optional timestamp for the event\n\n        Returns:\n            Tuple of (retrieved_memories, agent_response, created_event)\n\n        Example:\n            def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n                # Format context from memories\n                context = \"\\\\n\".join([m['content']['text'] for m in memories])\n\n                # Call your LLM (Bedrock, OpenAI, etc.)\n                response = bedrock.invoke_model(\n                    messages=[\n                        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                        {\"role\": \"user\", \"content\": user_input}\n                    ]\n                )\n                return response['content']\n\n            memories, response, event = client.process_turn_with_llm(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                user_input=\"What did we discuss yesterday?\",\n                llm_callback=my_llm,\n                retrieval_namespace=\"support/facts/{sessionId}\"\n            )\n        \"\"\"\n        # Step 1: Retrieve relevant memories\n        retrieved_memories = []\n        if retrieval_namespace:\n            search_query = retrieval_query or user_input\n            retrieved_memories = self.retrieve_memories(\n                memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n            )\n            logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n        # Step 2: Invoke LLM callback\n        try:\n            agent_response = llm_callback(user_input, retrieved_memories)\n            if not isinstance(agent_response, str):\n                raise ValueError(\"LLM callback must return a string response\")\n            logger.info(\"LLM callback generated response\")\n        except Exception as e:\n            logger.error(\"LLM callback failed: %s\", e)\n            raise\n\n        # Step 3: Save the conversation turn\n        event = self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=[(user_input, \"USER\"), (agent_response, \"ASSISTANT\")],\n            event_timestamp=event_timestamp,\n        )\n\n        logger.info(\"Completed full conversation turn with LLM\")\n        return retrieved_memories, agent_response, event\n\n    def list_events(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        branch_name: Optional[str] = None,\n        include_parent_events: bool = False,\n        max_results: int = 100,\n        include_payload: bool = True,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all events in a session with pagination support.\n\n        This method provides direct access to the raw events API, allowing developers\n        to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Optional branch name to filter events (None for all branches)\n            include_parent_events: Whether to include parent branch events (only applies with branch_name)\n            max_results: Maximum number of events to return\n            include_payload: Whether to include event payloads in response\n\n        Returns:\n            List of event dictionaries in chronological order\n\n        Example:\n            # Get all events\n            events = client.list_events(memory_id, actor_id, session_id)\n\n            # Get only main branch events\n            main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")\n\n            # Get events from a specific branch\n            branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")\n        \"\"\"\n        try:\n            all_events = []\n            next_token = None\n\n            while len(all_events) &lt; max_results:\n                params = {\n                    \"memoryId\": memory_id,\n                    \"actorId\": actor_id,\n                    \"sessionId\": session_id,\n                    \"maxResults\": min(100, max_results - len(all_events)),\n                }\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                # Add branch filter if specified (but not for \"main\")\n                if branch_name and branch_name != \"main\":\n                    params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n                response = self.gmdp_client.list_events(**params)\n\n                events = response.get(\"events\", [])\n                all_events.extend(events)\n\n                next_token = response.get(\"nextToken\")\n                if not next_token or len(all_events) &gt;= max_results:\n                    break\n\n            logger.info(\"Retrieved total of %d events\", len(all_events))\n            return all_events[:max_results]\n\n        except ClientError as e:\n            logger.error(\"Failed to list events: %s\", e)\n            raise\n\n    def list_branches(self, memory_id: str, actor_id: str, session_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all branches in a session.\n\n        This method handles pagination automatically and provides a structured view\n        of all conversation branches, which would require complex pagination and\n        grouping logic if done with raw boto3 calls.\n\n        Returns:\n            List of branch information including name and root event\n        \"\"\"\n        try:\n            # Get all events - need to handle pagination for complete list\n            all_events = []\n            next_token = None\n\n            while True:\n                params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.gmdp_client.list_events(**params)\n                all_events.extend(response.get(\"events\", []))\n\n                next_token = response.get(\"nextToken\")\n                if not next_token:\n                    break\n\n            branches = {}\n            main_branch_events = []\n\n            for event in all_events:\n                branch_info = event.get(\"branch\")\n                if branch_info:\n                    branch_name = branch_info[\"name\"]\n                    if branch_name not in branches:\n                        branches[branch_name] = {\n                            \"name\": branch_name,\n                            \"rootEventId\": branch_info.get(\"rootEventId\"),\n                            \"firstEventId\": event[\"eventId\"],\n                            \"eventCount\": 1,\n                            \"created\": event[\"eventTimestamp\"],\n                        }\n                    else:\n                        branches[branch_name][\"eventCount\"] += 1\n                else:\n                    main_branch_events.append(event)\n\n            # Build result list\n            result = []\n\n            # Only add main branch if there are actual events\n            if main_branch_events:\n                result.append(\n                    {\n                        \"name\": \"main\",\n                        \"rootEventId\": None,\n                        \"firstEventId\": main_branch_events[0][\"eventId\"],\n                        \"eventCount\": len(main_branch_events),\n                        \"created\": main_branch_events[0][\"eventTimestamp\"],\n                    }\n                )\n\n            # Add other branches\n            result.extend(list(branches.values()))\n\n            logger.info(\"Found %d branches in session %s\", len(result), session_id)\n            return result\n\n        except ClientError as e:\n            logger.error(\"Failed to list branches: %s\", e)\n            raise\n\n    def list_branch_events(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        branch_name: Optional[str] = None,\n        include_parent_events: bool = False,\n        max_results: int = 100,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"List events in a specific branch.\n\n        This method provides complex filtering and pagination that would require\n        significant boilerplate code with raw boto3. It handles:\n        - Automatic pagination across multiple API calls\n        - Branch filtering with parent event inclusion logic\n        - Main branch isolation (events without branch info)\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Branch name (None for main branch)\n            include_parent_events: Whether to include events from parent branches\n            max_results: Maximum events to return\n\n        Returns:\n            List of events in the branch\n        \"\"\"\n        try:\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"maxResults\": min(100, max_results),\n            }\n\n            # Only add filter when we have a specific branch name\n            if branch_name:\n                params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n            response = self.gmdp_client.list_events(**params)\n            events = response.get(\"events\", [])\n\n            # Handle pagination\n            next_token = response.get(\"nextToken\")\n            while next_token and len(events) &lt; max_results:\n                params[\"nextToken\"] = next_token\n                params[\"maxResults\"] = min(100, max_results - len(events))\n                response = self.gmdp_client.list_events(**params)\n                events.extend(response.get(\"events\", []))\n                next_token = response.get(\"nextToken\")\n\n            # Filter for main branch if no branch specified\n            if not branch_name:\n                events = [e for e in events if not e.get(\"branch\")]\n\n            logger.info(\"Retrieved %d events from branch '%s'\", len(events), branch_name or \"main\")\n            return events\n\n        except ClientError as e:\n            logger.error(\"Failed to list branch events: %s\", e)\n            raise\n\n    def get_conversation_tree(self, memory_id: str, actor_id: str, session_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get a tree structure of the conversation with all branches.\n\n        This method transforms a flat list of events into a hierarchical tree structure,\n        providing visualization-ready data that would be complex to build from raw events.\n        It handles:\n        - Full pagination to get all events\n        - Grouping by branches\n        - Message summarization\n        - Tree structure building\n\n        Returns:\n            Dictionary representing the conversation tree structure\n        \"\"\"\n        try:\n            # Get all events - need to handle pagination for complete list\n            all_events = []\n            next_token = None\n\n            while True:\n                params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.gmdp_client.list_events(**params)\n                all_events.extend(response.get(\"events\", []))\n\n                next_token = response.get(\"nextToken\")\n                if not next_token:\n                    break\n\n            # Build tree structure\n            tree = {\"session_id\": session_id, \"actor_id\": actor_id, \"main_branch\": {\"events\": [], \"branches\": {}}}\n\n            # Group events by branch\n            for event in all_events:\n                event_summary = {\"eventId\": event[\"eventId\"], \"timestamp\": event[\"eventTimestamp\"], \"messages\": []}\n\n                # Extract message summaries\n                if \"payload\" in event:\n                    for payload_item in event.get(\"payload\", []):\n                        if \"conversational\" in payload_item:\n                            conv = payload_item[\"conversational\"]\n                            event_summary[\"messages\"].append(\n                                {\"role\": conv.get(\"role\"), \"text\": conv.get(\"content\", {}).get(\"text\", \"\")[:50] + \"...\"}\n                            )\n\n                branch_info = event.get(\"branch\")\n                if branch_info:\n                    branch_name = branch_info[\"name\"]\n                    root_event = branch_info.get(\"rootEventId\")  # Use .get() to handle missing field\n\n                    if branch_name not in tree[\"main_branch\"][\"branches\"]:\n                        tree[\"main_branch\"][\"branches\"][branch_name] = {\"root_event_id\": root_event, \"events\": []}\n\n                    tree[\"main_branch\"][\"branches\"][branch_name][\"events\"].append(event_summary)\n                else:\n                    tree[\"main_branch\"][\"events\"].append(event_summary)\n\n            logger.info(\"Built conversation tree with %d branches\", len(tree[\"main_branch\"][\"branches\"]))\n            return tree\n\n        except ClientError as e:\n            logger.error(\"Failed to build conversation tree: %s\", e)\n            raise\n\n    def merge_branch_context(\n        self, memory_id: str, actor_id: str, session_id: str, branch_name: str, include_parent: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get all messages from a branch for context building.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Branch to get context from\n            include_parent: Whether to include parent branch events\n\n        Returns:\n            List of all messages in chronological order\n        \"\"\"\n        events = self.list_branch_events(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            branch_name=branch_name,\n            include_parent_events=include_parent,\n            max_results=100,\n        )\n\n        messages = []\n        for event in events:\n            if \"payload\" in event:\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        conv = payload_item[\"conversational\"]\n                        messages.append(\n                            {\n                                \"timestamp\": event[\"eventTimestamp\"],\n                                \"eventId\": event[\"eventId\"],\n                                \"branch\": event.get(\"branch\", {}).get(\"name\", \"main\"),\n                                \"role\": conv.get(\"role\"),\n                                \"content\": conv.get(\"content\", {}).get(\"text\", \"\"),\n                            }\n                        )\n\n        # Sort by timestamp\n        messages.sort(key=lambda x: x[\"timestamp\"])\n\n        logger.info(\"Retrieved %d messages from branch '%s'\", len(messages), branch_name)\n        return messages\n\n    def get_last_k_turns(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        k: int = 5,\n        branch_name: Optional[str] = None,\n        include_branches: bool = False,\n        max_results: int = 100,\n    ) -&gt; List[List[Dict[str, Any]]]:\n        \"\"\"Get the last K conversation turns.\n\n        A \"turn\" typically consists of a user message followed by assistant response(s).\n        This method groups messages into logical turns for easier processing.\n\n        Returns:\n            List of turns, where each turn is a list of message dictionaries\n        \"\"\"\n        try:\n            # Use the new list_events method\n            events = self.list_events(\n                memory_id=memory_id,\n                actor_id=actor_id,\n                session_id=session_id,\n                branch_name=branch_name,\n                include_parent_events=False,\n                max_results=max_results,\n            )\n\n            if not events:\n                return []\n\n            # Process events to group into turns\n            turns = []\n            current_turn = []\n\n            # Process events in chronological order\n            for _, event in enumerate(events):\n                if \"payload\" in event and event[\"payload\"]:\n                    for payload_item in event[\"payload\"]:\n                        if \"conversational\" in payload_item:\n                            role = payload_item[\"conversational\"].get(\"role\")\n\n                            # Start a new turn when we see a USER message and already have messages\n                            if role == Role.USER.value and current_turn:\n                                turns.append(current_turn)\n                                current_turn = []\n\n                            current_turn.append(payload_item[\"conversational\"])\n\n            # Don't forget the last turn\n            if current_turn:\n                turns.append(current_turn)\n\n            # Return the last k turns\n            if len(turns) &gt; k:\n                result = turns[-k:]  # Get last k turns\n            else:\n                result = turns\n\n            return result\n\n        except ClientError as e:\n            logger.error(\"Failed to get last K turns: %s\", e)\n            raise\n\n    def fork_conversation(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        root_event_id: str,\n        branch_name: str,\n        new_messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n        try:\n            branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n            event = self.create_event(\n                memory_id=memory_id,\n                actor_id=actor_id,\n                session_id=session_id,\n                messages=new_messages,\n                branch=branch,\n                event_timestamp=event_timestamp,\n            )\n\n            logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to fork conversation: %s\", e)\n            raise\n\n    def get_memory_strategies(self, memory_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get all strategies for a memory.\"\"\"\n        try:\n            response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            memory = response[\"memory\"]\n\n            # Handle both old and new field names in response\n            strategies = memory.get(\"strategies\", memory.get(\"memoryStrategies\", []))\n\n            # Normalize strategy fields\n            normalized_strategies = []\n            for strategy in strategies:\n                # Create normalized version with both old and new field names\n                normalized = strategy.copy()\n\n                # Ensure both field name versions exist\n                if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                    normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n                elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                    normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n                if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                    normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n                elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                    normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n                normalized_strategies.append(normalized)\n\n            return normalized_strategies\n        except ClientError as e:\n            logger.error(\"Failed to get memory strategies: %s\", e)\n            raise\n\n    def get_memory_status(self, memory_id: str) -&gt; str:\n        \"\"\"Get current memory status.\"\"\"\n        try:\n            response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            return response[\"memory\"][\"status\"]\n        except ClientError as e:\n            logger.error(\"Failed to get memory status: %s\", e)\n            raise\n\n    def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all memories for the account.\"\"\"\n        try:\n            # Ensure max_results doesn't exceed API limit per request\n            results_per_request = min(max_results, 100)\n\n            response = self.gmcp_client.list_memories(maxResults=results_per_request)\n            memories = response.get(\"memories\", [])\n\n            next_token = response.get(\"nextToken\")\n            while next_token and len(memories) &lt; max_results:\n                remaining = max_results - len(memories)\n                results_per_request = min(remaining, 100)\n\n                response = self.gmcp_client.list_memories(maxResults=results_per_request, nextToken=next_token)\n                memories.extend(response.get(\"memories\", []))\n                next_token = response.get(\"nextToken\")\n\n            # Normalize memory summaries if they contain new field names\n            normalized_memories = []\n            for memory in memories[:max_results]:\n                normalized = memory.copy()\n                # Ensure both field name versions exist\n                if \"id\" in memory and \"memoryId\" not in normalized:\n                    normalized[\"memoryId\"] = memory[\"id\"]\n                elif \"memoryId\" in memory and \"id\" not in normalized:\n                    normalized[\"id\"] = memory[\"memoryId\"]\n                normalized_memories.append(normalized)\n\n            return normalized_memories\n\n        except ClientError as e:\n            logger.error(\"Failed to list memories: %s\", e)\n            raise\n\n    def delete_memory(self, memory_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory resource.\"\"\"\n        try:\n            response = self.gmcp_client.delete_memory(\n                memoryId=memory_id, clientToken=str(uuid.uuid4())\n            )  # Input uses old field name\n            logger.info(\"Deleted memory: %s\", memory_id)\n            return response\n        except ClientError as e:\n            logger.error(\"Failed to delete memory: %s\", e)\n            raise\n\n    def delete_memory_and_wait(self, memory_id: str, max_wait: int = 300, poll_interval: int = 10) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory and wait for deletion to complete.\n\n        This method deletes a memory and polls until it's fully deleted,\n        ensuring clean resource cleanup.\n\n        Args:\n            memory_id: Memory resource ID to delete\n            max_wait: Maximum seconds to wait (default: 300)\n            poll_interval: Seconds between checks (default: 10)\n\n        Returns:\n            Final deletion response\n\n        Raises:\n            TimeoutError: If deletion doesn't complete within max_wait\n        \"\"\"\n        # Initiate deletion\n        response = self.delete_memory(memory_id)\n        logger.info(\"Initiated deletion of memory %s\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                # Try to get the memory - if it doesn't exist, deletion is complete\n                self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                logger.debug(\"Memory still exists, waiting... (%d seconds elapsed)\", elapsed)\n\n            except ClientError as e:\n                if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                    logger.info(\"Memory %s successfully deleted (took %d seconds)\", memory_id, elapsed)\n                    return response\n                else:\n                    logger.error(\"Error checking memory status: %s\", e)\n                    raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s was not deleted within %d seconds\" % (memory_id, max_wait))\n\n    def add_semantic_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a semantic memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.SEMANTIC.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.SEMANTIC.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.SEMANTIC.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_semantic_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a semantic strategy and wait for memory to return to ACTIVE state.\n\n        This addresses the issue where adding a strategy puts the memory into\n        CREATING state temporarily, preventing subsequent operations.\n        \"\"\"\n        # Add the strategy\n        self.add_semantic_strategy(memory_id, name, description, namespaces)\n\n        # Wait for memory to return to ACTIVE\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_summary_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a summary memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.SUMMARY.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.SUMMARY.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.SUMMARY.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_summary_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a summary strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_summary_strategy(memory_id, name, description, namespaces)\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_user_preference_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a user preference memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.USER_PREFERENCE.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.USER_PREFERENCE.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.USER_PREFERENCE.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_user_preference_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a user preference strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_user_preference_strategy(memory_id, name, description, namespaces)\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_custom_semantic_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        extraction_config: Dict[str, Any],\n        consolidation_config: Dict[str, Any],\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a custom semantic strategy with prompts.\n\n        Args:\n            memory_id: Memory resource ID\n            name: Strategy name\n            extraction_config: Extraction configuration with prompt and model:\n                {\"prompt\": \"...\", \"modelId\": \"...\"}\n            consolidation_config: Consolidation configuration with prompt and model:\n                {\"prompt\": \"...\", \"modelId\": \"...\"}\n            description: Optional description\n            namespaces: Optional namespaces list\n        \"\"\"\n        strategy = {\n            StrategyType.CUSTOM.value: {\n                \"name\": name,\n                \"configuration\": {\n                    \"semanticOverride\": {\n                        \"extraction\": {\n                            \"appendToPrompt\": extraction_config[\"prompt\"],\n                            \"modelId\": extraction_config[\"modelId\"],\n                        },\n                        \"consolidation\": {\n                            \"appendToPrompt\": consolidation_config[\"prompt\"],\n                            \"modelId\": consolidation_config[\"modelId\"],\n                        },\n                    }\n                },\n            }\n        }\n\n        if description:\n            strategy[StrategyType.CUSTOM.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.CUSTOM.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_custom_semantic_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        extraction_config: Dict[str, Any],\n        consolidation_config: Dict[str, Any],\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a custom semantic strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_custom_semantic_strategy(\n            memory_id, name, extraction_config, consolidation_config, description, namespaces\n        )\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def modify_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        configuration: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Modify a strategy with full control over configuration.\"\"\"\n        modify_config: Dict = {\"memoryStrategyId\": strategy_id}  # Using old field name for input\n\n        if description is not None:\n            modify_config[\"description\"] = description\n        if namespaces is not None:\n            modify_config[\"namespaces\"] = namespaces\n        if configuration is not None:\n            modify_config[\"configuration\"] = configuration\n\n        return self.update_memory_strategies(memory_id=memory_id, modify_strategies=[modify_config])\n\n    def delete_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Delete a strategy from a memory.\"\"\"\n        return self.update_memory_strategies(memory_id=memory_id, delete_strategy_ids=[strategy_id])\n\n    def update_memory_strategies(\n        self,\n        memory_id: str,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update memory strategies - add, modify, or delete.\"\"\"\n        try:\n            memory_strategies = {}\n\n            if add_strategies:\n                processed_add = self._add_default_namespaces(add_strategies)\n                memory_strategies[\"addMemoryStrategies\"] = processed_add  # Using old field name for input\n\n            if modify_strategies:\n                current_strategies = self.get_memory_strategies(memory_id)\n                strategy_map = {s[\"memoryStrategyId\"]: s for s in current_strategies}  # Using normalized field\n\n                modify_list = []\n                for strategy in modify_strategies:\n                    if \"memoryStrategyId\" not in strategy:  # Using old field name\n                        raise ValueError(\"Each modify strategy must include memoryStrategyId\")\n\n                    strategy_id = strategy[\"memoryStrategyId\"]  # Using old field name\n                    strategy_info = strategy_map.get(strategy_id)\n\n                    if not strategy_info:\n                        raise ValueError(\"Strategy %s not found in memory %s\" % (strategy_id, memory_id))\n\n                    strategy_type = strategy_info[\"memoryStrategyType\"]  # Using normalized field\n                    override_type = strategy_info.get(\"configuration\", {}).get(\"type\")\n\n                    strategy_copy = copy.deepcopy(strategy)\n\n                    if \"configuration\" in strategy_copy:\n                        wrapped_config = self._wrap_configuration(\n                            strategy_copy[\"configuration\"], strategy_type, override_type\n                        )\n                        strategy_copy[\"configuration\"] = wrapped_config\n\n                    modify_list.append(strategy_copy)\n\n                memory_strategies[\"modifyMemoryStrategies\"] = modify_list  # Using old field name for input\n\n            if delete_strategy_ids:\n                delete_list = [{\"memoryStrategyId\": sid} for sid in delete_strategy_ids]  # Using old field name\n                memory_strategies[\"deleteMemoryStrategies\"] = delete_list  # Using old field name for input\n\n            if not memory_strategies:\n                raise ValueError(\"No strategy operations provided\")\n\n            response = self.gmcp_client.update_memory(\n                memoryId=memory_id,\n                memoryStrategies=memory_strategies,\n                clientToken=str(uuid.uuid4()),  # Using old field names for input\n            )\n\n            logger.info(\"Updated memory strategies for: %s\", memory_id)\n            memory = self._normalize_memory_response(response[\"memory\"])\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to update memory strategies: %s\", e)\n            raise\n\n    def update_memory_strategies_and_wait(\n        self,\n        memory_id: str,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update memory strategies and wait for memory to return to ACTIVE state.\n\n        This method handles the temporary CREATING state that occurs when\n        updating strategies, preventing subsequent update errors.\n        \"\"\"\n        # Update strategies\n        self.update_memory_strategies(memory_id, add_strategies, modify_strategies, delete_strategy_ids)\n\n        # Wait for memory to return to ACTIVE\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def wait_for_memories(\n        self, memory_id: str, namespace: str, test_query: str = \"test\", max_wait: int = 180, poll_interval: int = 15\n    ) -&gt; bool:\n        \"\"\"Wait for memory extraction to complete by polling.\n\n        IMPORTANT LIMITATIONS:\n        1. This method only works reliably on empty namespaces. If there are already\n           existing memories in the namespace, this method may return True immediately\n           even if new extractions haven't completed.\n        2. Wildcards (*) are NOT supported in namespaces. You must provide the exact\n           namespace path with all variables resolved (e.g., \"support/facts/session-123\"\n           not \"support/facts/*\").\n\n        For subsequent extractions in populated namespaces, use a fixed wait time:\n            time.sleep(150)  # Wait 2.5 minutes for extraction\n\n        Args:\n            memory_id: Memory resource ID\n            namespace: Exact namespace to check (no wildcards)\n            test_query: Query to test with (default: \"test\")\n            max_wait: Maximum seconds to wait (default: 180)\n            poll_interval: Seconds between checks (default: 15)\n\n        Returns:\n            True if memories found, False if timeout\n\n        Note:\n            This method will be deprecated in future versions once the API\n            provides extraction status or timestamps.\n        \"\"\"\n        if \"*\" in namespace:\n            logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n            return False\n\n        logger.warning(\n            \"wait_for_memories() only works reliably on empty namespaces. \"\n            \"For populated namespaces, consider using a fixed wait time instead.\"\n        )\n\n        logger.info(\"Waiting for memory extraction in namespace: %s\", namespace)\n        start_time = time.time()\n        service_errors = 0\n\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                memories = self.retrieve_memories(memory_id=memory_id, namespace=namespace, query=test_query, top_k=1)\n\n                if memories:\n                    logger.info(\"Memory extraction complete after %d seconds\", elapsed)\n                    return True\n\n                # Reset service error count on successful call\n                service_errors = 0\n\n            except Exception as e:\n                if \"ServiceException\" in str(e):\n                    service_errors += 1\n                    if service_errors &gt;= 3:\n                        logger.warning(\"Multiple service errors - the service may be experiencing issues\")\n                logger.debug(\"Retrieval attempt failed: %s\", e)\n\n            if time.time() - start_time &lt; max_wait:\n                time.sleep(poll_interval)\n\n        logger.warning(\"No memories found after %d seconds\", max_wait)\n        if service_errors &gt; 0:\n            logger.info(\"Note: Encountered %d service errors during polling\", service_errors)\n        return False\n\n    def add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Add a strategy to a memory (without waiting).\n\n        WARNING: After adding a strategy, the memory enters CREATING state temporarily.\n        Use add_*_strategy_and_wait() methods instead to avoid errors.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy: Strategy configuration dictionary\n\n        Returns:\n            Updated memory response\n        \"\"\"\n        warnings.warn(\n            \"add_strategy() may leave memory in CREATING state. \"\n            \"Use add_*_strategy_and_wait() methods to avoid subsequent errors.\",\n            UserWarning,\n            stacklevel=2,\n        )\n        return self._add_strategy(memory_id, strategy)\n\n    # Private methods\n\n    def _normalize_memory_response(self, memory: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Normalize memory response to include both old and new field names.\n\n        The API returns new field names but SDK users might expect old ones.\n        This ensures compatibility by providing both.\n        \"\"\"\n        # Ensure both versions of memory ID exist\n        if \"id\" in memory and \"memoryId\" not in memory:\n            memory[\"memoryId\"] = memory[\"id\"]\n        elif \"memoryId\" in memory and \"id\" not in memory:\n            memory[\"id\"] = memory[\"memoryId\"]\n\n        # Ensure both versions of strategies exist\n        if \"strategies\" in memory and \"memoryStrategies\" not in memory:\n            memory[\"memoryStrategies\"] = memory[\"strategies\"]\n        elif \"memoryStrategies\" in memory and \"strategies\" not in memory:\n            memory[\"strategies\"] = memory[\"memoryStrategies\"]\n\n        # Normalize strategies within memory\n        if \"strategies\" in memory:\n            normalized_strategies = []\n            for strategy in memory[\"strategies\"]:\n                normalized = strategy.copy()\n\n                # Ensure both field name versions exist for strategies\n                if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                    normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n                elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                    normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n                if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                    normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n                elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                    normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n                normalized_strategies.append(normalized)\n\n            memory[\"strategies\"] = normalized_strategies\n            memory[\"memoryStrategies\"] = normalized_strategies\n\n        return memory\n\n    def _add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Internal method to add a single strategy.\"\"\"\n        return self.update_memory_strategies(memory_id=memory_id, add_strategies=[strategy])\n\n    def _wait_for_memory_active(self, memory_id: str, max_wait: int, poll_interval: int) -&gt; Dict[str, Any]:\n        \"\"\"Wait for memory to return to ACTIVE state after strategy update.\"\"\"\n        logger.info(\"Waiting for memory %s to return to ACTIVE state...\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                status = self.get_memory_status(memory_id)\n\n                if status == MemoryStatus.ACTIVE.value:\n                    logger.info(\"Memory %s is ACTIVE again (took %d seconds)\", memory_id, elapsed)\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    memory = self._normalize_memory_response(response[\"memory\"])\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(\"Memory update failed: %s\" % failure_reason)\n                else:\n                    logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s did not return to ACTIVE state within %d seconds\" % (memory_id, max_wait))\n\n    def _add_default_namespaces(self, strategies: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Add default namespaces to strategies that don't have them.\"\"\"\n        processed = []\n\n        for strategy in strategies:\n            strategy_copy = copy.deepcopy(strategy)\n\n            strategy_type_key = list(strategy.keys())[0]\n            strategy_config = strategy_copy[strategy_type_key]\n\n            if \"namespaces\" not in strategy_config:\n                strategy_type = StrategyType(strategy_type_key)\n                strategy_config[\"namespaces\"] = DEFAULT_NAMESPACES.get(strategy_type, [\"custom/{actorId}/{sessionId}\"])\n\n            self._validate_strategy_config(strategy_copy, strategy_type_key)\n\n            processed.append(strategy_copy)\n\n        return processed\n\n    def _validate_namespace(self, namespace: str) -&gt; bool:\n        \"\"\"Validate namespace format - basic check only.\"\"\"\n        # Only check for template variables in namespace definition\n        # Note: Using memoryStrategyId (old name) as it's still used in input parameters\n        if \"{\" in namespace and not (\n            \"{actorId}\" in namespace or \"{sessionId}\" in namespace or \"{memoryStrategyId}\" in namespace\n        ):\n            logger.warning(\"Namespace with templates should contain valid variables: %s\", namespace)\n\n        return True\n\n    def _validate_strategy_config(self, strategy: Dict[str, Any], strategy_type: str) -&gt; None:\n        \"\"\"Validate strategy configuration parameters.\"\"\"\n        strategy_config = strategy[strategy_type]\n\n        namespaces = strategy_config.get(\"namespaces\", [])\n        for namespace in namespaces:\n            self._validate_namespace(namespace)\n\n    def _wrap_configuration(\n        self, config: Dict[str, Any], strategy_type: str, override_type: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Wrap configuration based on strategy type.\"\"\"\n        wrapped_config = {}\n\n        if \"extraction\" in config:\n            extraction = config[\"extraction\"]\n\n            if any(key in extraction for key in [\"triggerEveryNMessages\", \"historicalContextWindowSize\"]):\n                strategy_type_enum = MemoryStrategyTypeEnum(strategy_type)\n\n                if strategy_type == \"SEMANTIC\":\n                    wrapped_config[\"extraction\"] = {EXTRACTION_WRAPPER_KEYS[strategy_type_enum]: extraction}\n                elif strategy_type == \"USER_PREFERENCE\":\n                    wrapped_config[\"extraction\"] = {EXTRACTION_WRAPPER_KEYS[strategy_type_enum]: extraction}\n                elif strategy_type == \"CUSTOM\" and override_type:\n                    override_enum = OverrideType(override_type)\n                    if override_type in [\"SEMANTIC_OVERRIDE\", \"USER_PREFERENCE_OVERRIDE\"]:\n                        wrapped_config[\"extraction\"] = {\n                            \"customExtractionConfiguration\": {CUSTOM_EXTRACTION_WRAPPER_KEYS[override_enum]: extraction}\n                        }\n            else:\n                wrapped_config[\"extraction\"] = extraction\n\n        if \"consolidation\" in config:\n            consolidation = config[\"consolidation\"]\n\n            raw_keys = [\"triggerEveryNMessages\", \"appendToPrompt\", \"modelId\"]\n            if any(key in consolidation for key in raw_keys):\n                if strategy_type == \"SUMMARIZATION\":\n                    if \"triggerEveryNMessages\" in consolidation:\n                        wrapped_config[\"consolidation\"] = {\n                            \"summaryConsolidationConfiguration\": {\n                                \"triggerEveryNMessages\": consolidation[\"triggerEveryNMessages\"]\n                            }\n                        }\n                elif strategy_type == \"CUSTOM\" and override_type:\n                    override_enum = OverrideType(override_type)\n                    if override_enum in CUSTOM_CONSOLIDATION_WRAPPER_KEYS:\n                        wrapped_config[\"consolidation\"] = {\n                            \"customConsolidationConfiguration\": {\n                                CUSTOM_CONSOLIDATION_WRAPPER_KEYS[override_enum]: consolidation\n                            }\n                        }\n            else:\n                wrapped_config[\"consolidation\"] = consolidation\n\n        return wrapped_config\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.__init__","title":"<code>__init__(region_name=None)</code>","text":"<p>Initialize the Memory client.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def __init__(self, region_name: Optional[str] = None):\n    \"\"\"Initialize the Memory client.\"\"\"\n    self.region_name = region_name or boto3.Session().region_name or \"us-west-2\"\n\n    self.gmcp_client = boto3.client(\"bedrock-agentcore-control\", region_name=self.region_name)\n    self.gmdp_client = boto3.client(\"bedrock-agentcore\", region_name=self.region_name)\n\n    logger.info(\n        \"Initialized MemoryClient for control plane: %s, data plane: %s\",\n        self.gmcp_client.meta.region_name,\n        self.gmdp_client.meta.region_name,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_custom_semantic_strategy","title":"<code>add_custom_semantic_strategy(memory_id, name, extraction_config, consolidation_config, description=None, namespaces=None)</code>","text":"<p>Add a custom semantic strategy with prompts.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>name</code> <code>str</code> <p>Strategy name</p> required <code>extraction_config</code> <code>Dict[str, Any]</code> <p>Extraction configuration with prompt and model:</p> required <code>consolidation_config</code> <code>Dict[str, Any]</code> <p>Consolidation configuration with prompt and model:</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>namespaces</code> <code>Optional[List[str]]</code> <p>Optional namespaces list</p> <code>None</code> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_custom_semantic_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    extraction_config: Dict[str, Any],\n    consolidation_config: Dict[str, Any],\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a custom semantic strategy with prompts.\n\n    Args:\n        memory_id: Memory resource ID\n        name: Strategy name\n        extraction_config: Extraction configuration with prompt and model:\n            {\"prompt\": \"...\", \"modelId\": \"...\"}\n        consolidation_config: Consolidation configuration with prompt and model:\n            {\"prompt\": \"...\", \"modelId\": \"...\"}\n        description: Optional description\n        namespaces: Optional namespaces list\n    \"\"\"\n    strategy = {\n        StrategyType.CUSTOM.value: {\n            \"name\": name,\n            \"configuration\": {\n                \"semanticOverride\": {\n                    \"extraction\": {\n                        \"appendToPrompt\": extraction_config[\"prompt\"],\n                        \"modelId\": extraction_config[\"modelId\"],\n                    },\n                    \"consolidation\": {\n                        \"appendToPrompt\": consolidation_config[\"prompt\"],\n                        \"modelId\": consolidation_config[\"modelId\"],\n                    },\n                }\n            },\n        }\n    }\n\n    if description:\n        strategy[StrategyType.CUSTOM.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.CUSTOM.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_custom_semantic_strategy_and_wait","title":"<code>add_custom_semantic_strategy_and_wait(memory_id, name, extraction_config, consolidation_config, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a custom semantic strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_custom_semantic_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    extraction_config: Dict[str, Any],\n    consolidation_config: Dict[str, Any],\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a custom semantic strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_custom_semantic_strategy(\n        memory_id, name, extraction_config, consolidation_config, description, namespaces\n    )\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_semantic_strategy","title":"<code>add_semantic_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a semantic memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_semantic_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a semantic memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.SEMANTIC.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.SEMANTIC.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.SEMANTIC.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_semantic_strategy_and_wait","title":"<code>add_semantic_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a semantic strategy and wait for memory to return to ACTIVE state.</p> <p>This addresses the issue where adding a strategy puts the memory into CREATING state temporarily, preventing subsequent operations.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_semantic_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a semantic strategy and wait for memory to return to ACTIVE state.\n\n    This addresses the issue where adding a strategy puts the memory into\n    CREATING state temporarily, preventing subsequent operations.\n    \"\"\"\n    # Add the strategy\n    self.add_semantic_strategy(memory_id, name, description, namespaces)\n\n    # Wait for memory to return to ACTIVE\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_strategy","title":"<code>add_strategy(memory_id, strategy)</code>","text":"<p>Add a strategy to a memory (without waiting).</p> <p>WARNING: After adding a strategy, the memory enters CREATING state temporarily. Use add_*_strategy_and_wait() methods instead to avoid errors.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy</code> <code>Dict[str, Any]</code> <p>Strategy configuration dictionary</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory response</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Add a strategy to a memory (without waiting).\n\n    WARNING: After adding a strategy, the memory enters CREATING state temporarily.\n    Use add_*_strategy_and_wait() methods instead to avoid errors.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy: Strategy configuration dictionary\n\n    Returns:\n        Updated memory response\n    \"\"\"\n    warnings.warn(\n        \"add_strategy() may leave memory in CREATING state. \"\n        \"Use add_*_strategy_and_wait() methods to avoid subsequent errors.\",\n        UserWarning,\n        stacklevel=2,\n    )\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_summary_strategy","title":"<code>add_summary_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a summary memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_summary_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a summary memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.SUMMARY.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.SUMMARY.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.SUMMARY.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_summary_strategy_and_wait","title":"<code>add_summary_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a summary strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_summary_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a summary strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_summary_strategy(memory_id, name, description, namespaces)\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_user_preference_strategy","title":"<code>add_user_preference_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a user preference memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_user_preference_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a user preference memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.USER_PREFERENCE.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.USER_PREFERENCE.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.USER_PREFERENCE.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_user_preference_strategy_and_wait","title":"<code>add_user_preference_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a user preference strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_user_preference_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a user preference strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_user_preference_strategy(memory_id, name, description, namespaces)\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event","title":"<code>create_event(memory_id, actor_id, session_id, messages, event_timestamp=None, branch=None)</code>","text":"<p>Save an event of an agent interaction or conversation with a user.</p> <p>This is the basis of short-term memory. If you configured your Memory resource to have MemoryStrategies, then events that are saved in short-term memory via create_event will be used to extract long-term memory records.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier (could be id of your user or an agent)</p> required <code>session_id</code> <code>str</code> <p>Session identifier (meant to logically group a series of events)</p> required <code>messages</code> <code>List[Tuple[str, str]]</code> <p>List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>timestamp for the entire event (not per message)</p> <code>None</code> <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}    For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}    A branch is used when you want to have a different history of events.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created event</p> Example <p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     messages=[         (\"What's the weather?\", \"USER\"),         (\"Today is sunny\", \"ASSISTANT\")     ] ) root_event_id = event.get(\"eventId\") print(event)</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_event(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n    branch: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Save an event of an agent interaction or conversation with a user.\n\n    This is the basis of short-term memory. If you configured your Memory resource\n    to have MemoryStrategies, then events that are saved in short-term memory via\n    create_event will be used to extract long-term memory records.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier (could be id of your user or an agent)\n        session_id: Session identifier (meant to logically group a series of events)\n        messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n        event_timestamp: timestamp for the entire event (not per message)\n        branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n               For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n               A branch is used when you want to have a different history of events.\n\n    Returns:\n        Created event\n\n    Example:\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            messages=[\n                (\"What's the weather?\", \"USER\"),\n                (\"Today is sunny\", \"ASSISTANT\")\n            ]\n        )\n        root_event_id = event.get(\"eventId\")\n        print(event)\n\n        # Continue the conversation\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            messages=[\n                (\"How about the weather tomorrow\", \"USER\"),\n                (\"Tomorrow is cold!\", \"ASSISTANT\")\n            ]\n        )\n        print(event)\n\n        # branch the conversation so that the previous message is not part of the history\n        # (suppose you did not mean to ask about the weather tomorrow and want to undo\n        # that, and replace with a new message)\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},\n            messages=[\n                (\"How about the weather a year from now\", \"USER\"),\n                (\"I can't predict that far into the future!\", \"ASSISTANT\")\n            ]\n        )\n        print(event)\n    \"\"\"\n    try:\n        if not messages:\n            raise ValueError(\"At least one message is required\")\n\n        payload = []\n        for msg in messages:\n            if len(msg) != 2:\n                raise ValueError(\"Each message must be (text, role)\")\n\n            text, role = msg\n\n            try:\n                role_enum = MessageRole(role.upper())\n            except ValueError as err:\n                raise ValueError(\n                    \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                ) from err\n\n            payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n        # Use provided timestamp or current time\n        if event_timestamp is None:\n            event_timestamp = datetime.utcnow()\n\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n\n        response = self.gmdp_client.create_event(**params)\n\n        event = response[\"event\"]\n        logger.info(\"Created event: %s\", event[\"eventId\"])\n\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to create event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--continue-the-conversation","title":"Continue the conversation","text":"<p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     messages=[         (\"How about the weather tomorrow\", \"USER\"),         (\"Tomorrow is cold!\", \"ASSISTANT\")     ] ) print(event)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--branch-the-conversation-so-that-the-previous-message-is-not-part-of-the-history","title":"branch the conversation so that the previous message is not part of the history","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--suppose-you-did-not-mean-to-ask-about-the-weather-tomorrow-and-want-to-undo","title":"(suppose you did not mean to ask about the weather tomorrow and want to undo","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--that-and-replace-with-a-new-message","title":"that, and replace with a new message)","text":"<p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},     messages=[         (\"How about the weather a year from now\", \"USER\"),         (\"I can't predict that far into the future!\", \"ASSISTANT\")     ] ) print(event)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_memory","title":"<code>create_memory(name, strategies=None, description=None, event_expiry_days=90, memory_execution_role_arn=None)</code>","text":"<p>Create a memory with simplified configuration.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_memory(\n    self,\n    name: str,\n    strategies: Optional[List[Dict[str, Any]]] = None,\n    description: Optional[str] = None,\n    event_expiry_days: int = 90,\n    memory_execution_role_arn: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory with simplified configuration.\"\"\"\n    if strategies is None:\n        strategies = []\n\n    try:\n        processed_strategies = self._add_default_namespaces(strategies)\n\n        params = {\n            \"name\": name,\n            \"eventExpiryDuration\": event_expiry_days,\n            \"memoryStrategies\": processed_strategies,  # Using old field name for input\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if description is not None:\n            params[\"description\"] = description\n\n        if memory_execution_role_arn is not None:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        response = self.gmcp_client.create_memory(**params)\n\n        memory = response[\"memory\"]\n        # Normalize response to handle new field names\n        memory = self._normalize_memory_response(memory)\n\n        logger.info(\"Created memory: %s\", memory[\"memoryId\"])\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to create memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_memory_and_wait","title":"<code>create_memory_and_wait(name, strategies, description=None, event_expiry_days=90, memory_execution_role_arn=None, max_wait=300, poll_interval=10)</code>","text":"<p>Create a memory and wait for it to become ACTIVE.</p> <p>This method creates a memory and polls until it reaches ACTIVE status, providing a convenient way to ensure the memory is ready for use.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the memory resource</p> required <code>strategies</code> <code>List[Dict[str, Any]]</code> <p>List of strategy configurations</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>event_expiry_days</code> <code>int</code> <p>How long to retain events (default: 90 days)</p> <code>90</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>IAM role ARN for memory execution</p> <code>None</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 300)</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks (default: 10)</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created memory object in ACTIVE status</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If memory doesn't become ACTIVE within max_wait</p> <code>RuntimeError</code> <p>If memory creation fails</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_memory_and_wait(\n    self,\n    name: str,\n    strategies: List[Dict[str, Any]],\n    description: Optional[str] = None,\n    event_expiry_days: int = 90,\n    memory_execution_role_arn: Optional[str] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory and wait for it to become ACTIVE.\n\n    This method creates a memory and polls until it reaches ACTIVE status,\n    providing a convenient way to ensure the memory is ready for use.\n\n    Args:\n        name: Name for the memory resource\n        strategies: List of strategy configurations\n        description: Optional description\n        event_expiry_days: How long to retain events (default: 90 days)\n        memory_execution_role_arn: IAM role ARN for memory execution\n        max_wait: Maximum seconds to wait (default: 300)\n        poll_interval: Seconds between status checks (default: 10)\n\n    Returns:\n        Created memory object in ACTIVE status\n\n    Raises:\n        TimeoutError: If memory doesn't become ACTIVE within max_wait\n        RuntimeError: If memory creation fails\n    \"\"\"\n    # Create the memory\n    memory = self.create_memory(\n        name=name,\n        strategies=strategies,\n        description=description,\n        event_expiry_days=event_expiry_days,\n        memory_execution_role_arn=memory_execution_role_arn,\n    )\n\n    memory_id = memory.get(\"memoryId\", memory.get(\"id\"))  # Handle both field names\n    if memory_id is None:\n        memory_id = \"\"\n    logger.info(\"Created memory %s, waiting for ACTIVE status...\", memory_id)\n\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            status = self.get_memory_status(memory_id)\n\n            if status == MemoryStatus.ACTIVE.value:\n                logger.info(\"Memory %s is now ACTIVE (took %d seconds)\", memory_id, elapsed)\n                # Get fresh memory details\n                response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                memory = self._normalize_memory_response(response[\"memory\"])\n                return memory\n            elif status == MemoryStatus.FAILED.value:\n                # Get failure reason if available\n                response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                raise RuntimeError(\"Memory creation failed: %s\" % failure_reason)\n            else:\n                logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n        except ClientError as e:\n            logger.error(\"Error checking memory status: %s\", e)\n            raise\n\n        time.sleep(poll_interval)\n\n    raise TimeoutError(\"Memory %s did not become ACTIVE within %d seconds\" % (memory_id, max_wait))\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_memory","title":"<code>delete_memory(memory_id)</code>","text":"<p>Delete a memory resource.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_memory(self, memory_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory resource.\"\"\"\n    try:\n        response = self.gmcp_client.delete_memory(\n            memoryId=memory_id, clientToken=str(uuid.uuid4())\n        )  # Input uses old field name\n        logger.info(\"Deleted memory: %s\", memory_id)\n        return response\n    except ClientError as e:\n        logger.error(\"Failed to delete memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_memory_and_wait","title":"<code>delete_memory_and_wait(memory_id, max_wait=300, poll_interval=10)</code>","text":"<p>Delete a memory and wait for deletion to complete.</p> <p>This method deletes a memory and polls until it's fully deleted, ensuring clean resource cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID to delete</p> required <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 300)</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks (default: 10)</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Final deletion response</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If deletion doesn't complete within max_wait</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_memory_and_wait(self, memory_id: str, max_wait: int = 300, poll_interval: int = 10) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory and wait for deletion to complete.\n\n    This method deletes a memory and polls until it's fully deleted,\n    ensuring clean resource cleanup.\n\n    Args:\n        memory_id: Memory resource ID to delete\n        max_wait: Maximum seconds to wait (default: 300)\n        poll_interval: Seconds between checks (default: 10)\n\n    Returns:\n        Final deletion response\n\n    Raises:\n        TimeoutError: If deletion doesn't complete within max_wait\n    \"\"\"\n    # Initiate deletion\n    response = self.delete_memory(memory_id)\n    logger.info(\"Initiated deletion of memory %s\", memory_id)\n\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            # Try to get the memory - if it doesn't exist, deletion is complete\n            self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            logger.debug(\"Memory still exists, waiting... (%d seconds elapsed)\", elapsed)\n\n        except ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                logger.info(\"Memory %s successfully deleted (took %d seconds)\", memory_id, elapsed)\n                return response\n            else:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n        time.sleep(poll_interval)\n\n    raise TimeoutError(\"Memory %s was not deleted within %d seconds\" % (memory_id, max_wait))\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_strategy","title":"<code>delete_strategy(memory_id, strategy_id)</code>","text":"<p>Delete a strategy from a memory.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Delete a strategy from a memory.\"\"\"\n    return self.update_memory_strategies(memory_id=memory_id, delete_strategy_ids=[strategy_id])\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.fork_conversation","title":"<code>fork_conversation(memory_id, actor_id, session_id, root_event_id, branch_name, new_messages, event_timestamp=None)</code>","text":"<p>Fork a conversation from a specific event to create a new branch.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def fork_conversation(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    root_event_id: str,\n    branch_name: str,\n    new_messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n    try:\n        branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n        event = self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=new_messages,\n            branch=branch,\n            event_timestamp=event_timestamp,\n        )\n\n        logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to fork conversation: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_conversation_tree","title":"<code>get_conversation_tree(memory_id, actor_id, session_id)</code>","text":"<p>Get a tree structure of the conversation with all branches.</p> <p>This method transforms a flat list of events into a hierarchical tree structure, providing visualization-ready data that would be complex to build from raw events. It handles: - Full pagination to get all events - Grouping by branches - Message summarization - Tree structure building</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representing the conversation tree structure</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_conversation_tree(self, memory_id: str, actor_id: str, session_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Get a tree structure of the conversation with all branches.\n\n    This method transforms a flat list of events into a hierarchical tree structure,\n    providing visualization-ready data that would be complex to build from raw events.\n    It handles:\n    - Full pagination to get all events\n    - Grouping by branches\n    - Message summarization\n    - Tree structure building\n\n    Returns:\n        Dictionary representing the conversation tree structure\n    \"\"\"\n    try:\n        # Get all events - need to handle pagination for complete list\n        all_events = []\n        next_token = None\n\n        while True:\n            params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.gmdp_client.list_events(**params)\n            all_events.extend(response.get(\"events\", []))\n\n            next_token = response.get(\"nextToken\")\n            if not next_token:\n                break\n\n        # Build tree structure\n        tree = {\"session_id\": session_id, \"actor_id\": actor_id, \"main_branch\": {\"events\": [], \"branches\": {}}}\n\n        # Group events by branch\n        for event in all_events:\n            event_summary = {\"eventId\": event[\"eventId\"], \"timestamp\": event[\"eventTimestamp\"], \"messages\": []}\n\n            # Extract message summaries\n            if \"payload\" in event:\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        conv = payload_item[\"conversational\"]\n                        event_summary[\"messages\"].append(\n                            {\"role\": conv.get(\"role\"), \"text\": conv.get(\"content\", {}).get(\"text\", \"\")[:50] + \"...\"}\n                        )\n\n            branch_info = event.get(\"branch\")\n            if branch_info:\n                branch_name = branch_info[\"name\"]\n                root_event = branch_info.get(\"rootEventId\")  # Use .get() to handle missing field\n\n                if branch_name not in tree[\"main_branch\"][\"branches\"]:\n                    tree[\"main_branch\"][\"branches\"][branch_name] = {\"root_event_id\": root_event, \"events\": []}\n\n                tree[\"main_branch\"][\"branches\"][branch_name][\"events\"].append(event_summary)\n            else:\n                tree[\"main_branch\"][\"events\"].append(event_summary)\n\n        logger.info(\"Built conversation tree with %d branches\", len(tree[\"main_branch\"][\"branches\"]))\n        return tree\n\n    except ClientError as e:\n        logger.error(\"Failed to build conversation tree: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_last_k_turns","title":"<code>get_last_k_turns(memory_id, actor_id, session_id, k=5, branch_name=None, include_branches=False, max_results=100)</code>","text":"<p>Get the last K conversation turns.</p> <p>A \"turn\" typically consists of a user message followed by assistant response(s). This method groups messages into logical turns for easier processing.</p> <p>Returns:</p> Type Description <code>List[List[Dict[str, Any]]]</code> <p>List of turns, where each turn is a list of message dictionaries</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_last_k_turns(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    k: int = 5,\n    branch_name: Optional[str] = None,\n    include_branches: bool = False,\n    max_results: int = 100,\n) -&gt; List[List[Dict[str, Any]]]:\n    \"\"\"Get the last K conversation turns.\n\n    A \"turn\" typically consists of a user message followed by assistant response(s).\n    This method groups messages into logical turns for easier processing.\n\n    Returns:\n        List of turns, where each turn is a list of message dictionaries\n    \"\"\"\n    try:\n        # Use the new list_events method\n        events = self.list_events(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            branch_name=branch_name,\n            include_parent_events=False,\n            max_results=max_results,\n        )\n\n        if not events:\n            return []\n\n        # Process events to group into turns\n        turns = []\n        current_turn = []\n\n        # Process events in chronological order\n        for _, event in enumerate(events):\n            if \"payload\" in event and event[\"payload\"]:\n                for payload_item in event[\"payload\"]:\n                    if \"conversational\" in payload_item:\n                        role = payload_item[\"conversational\"].get(\"role\")\n\n                        # Start a new turn when we see a USER message and already have messages\n                        if role == Role.USER.value and current_turn:\n                            turns.append(current_turn)\n                            current_turn = []\n\n                        current_turn.append(payload_item[\"conversational\"])\n\n        # Don't forget the last turn\n        if current_turn:\n            turns.append(current_turn)\n\n        # Return the last k turns\n        if len(turns) &gt; k:\n            result = turns[-k:]  # Get last k turns\n        else:\n            result = turns\n\n        return result\n\n    except ClientError as e:\n        logger.error(\"Failed to get last K turns: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_memory_status","title":"<code>get_memory_status(memory_id)</code>","text":"<p>Get current memory status.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_memory_status(self, memory_id: str) -&gt; str:\n    \"\"\"Get current memory status.\"\"\"\n    try:\n        response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n        return response[\"memory\"][\"status\"]\n    except ClientError as e:\n        logger.error(\"Failed to get memory status: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_memory_strategies","title":"<code>get_memory_strategies(memory_id)</code>","text":"<p>Get all strategies for a memory.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_memory_strategies(self, memory_id: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all strategies for a memory.\"\"\"\n    try:\n        response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n        memory = response[\"memory\"]\n\n        # Handle both old and new field names in response\n        strategies = memory.get(\"strategies\", memory.get(\"memoryStrategies\", []))\n\n        # Normalize strategy fields\n        normalized_strategies = []\n        for strategy in strategies:\n            # Create normalized version with both old and new field names\n            normalized = strategy.copy()\n\n            # Ensure both field name versions exist\n            if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n            elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n            if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n            elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n            normalized_strategies.append(normalized)\n\n        return normalized_strategies\n    except ClientError as e:\n        logger.error(\"Failed to get memory strategies: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_branch_events","title":"<code>list_branch_events(memory_id, actor_id, session_id, branch_name=None, include_parent_events=False, max_results=100)</code>","text":"<p>List events in a specific branch.</p> <p>This method provides complex filtering and pagination that would require significant boilerplate code with raw boto3. It handles: - Automatic pagination across multiple API calls - Branch filtering with parent event inclusion logic - Main branch isolation (events without branch info)</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>Optional[str]</code> <p>Branch name (None for main branch)</p> <code>None</code> <code>include_parent_events</code> <code>bool</code> <p>Whether to include events from parent branches</p> <code>False</code> <code>max_results</code> <code>int</code> <p>Maximum events to return</p> <code>100</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of events in the branch</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_branch_events(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    branch_name: Optional[str] = None,\n    include_parent_events: bool = False,\n    max_results: int = 100,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List events in a specific branch.\n\n    This method provides complex filtering and pagination that would require\n    significant boilerplate code with raw boto3. It handles:\n    - Automatic pagination across multiple API calls\n    - Branch filtering with parent event inclusion logic\n    - Main branch isolation (events without branch info)\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Branch name (None for main branch)\n        include_parent_events: Whether to include events from parent branches\n        max_results: Maximum events to return\n\n    Returns:\n        List of events in the branch\n    \"\"\"\n    try:\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"maxResults\": min(100, max_results),\n        }\n\n        # Only add filter when we have a specific branch name\n        if branch_name:\n            params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n        response = self.gmdp_client.list_events(**params)\n        events = response.get(\"events\", [])\n\n        # Handle pagination\n        next_token = response.get(\"nextToken\")\n        while next_token and len(events) &lt; max_results:\n            params[\"nextToken\"] = next_token\n            params[\"maxResults\"] = min(100, max_results - len(events))\n            response = self.gmdp_client.list_events(**params)\n            events.extend(response.get(\"events\", []))\n            next_token = response.get(\"nextToken\")\n\n        # Filter for main branch if no branch specified\n        if not branch_name:\n            events = [e for e in events if not e.get(\"branch\")]\n\n        logger.info(\"Retrieved %d events from branch '%s'\", len(events), branch_name or \"main\")\n        return events\n\n    except ClientError as e:\n        logger.error(\"Failed to list branch events: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_branches","title":"<code>list_branches(memory_id, actor_id, session_id)</code>","text":"<p>List all branches in a session.</p> <p>This method handles pagination automatically and provides a structured view of all conversation branches, which would require complex pagination and grouping logic if done with raw boto3 calls.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of branch information including name and root event</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_branches(self, memory_id: str, actor_id: str, session_id: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all branches in a session.\n\n    This method handles pagination automatically and provides a structured view\n    of all conversation branches, which would require complex pagination and\n    grouping logic if done with raw boto3 calls.\n\n    Returns:\n        List of branch information including name and root event\n    \"\"\"\n    try:\n        # Get all events - need to handle pagination for complete list\n        all_events = []\n        next_token = None\n\n        while True:\n            params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.gmdp_client.list_events(**params)\n            all_events.extend(response.get(\"events\", []))\n\n            next_token = response.get(\"nextToken\")\n            if not next_token:\n                break\n\n        branches = {}\n        main_branch_events = []\n\n        for event in all_events:\n            branch_info = event.get(\"branch\")\n            if branch_info:\n                branch_name = branch_info[\"name\"]\n                if branch_name not in branches:\n                    branches[branch_name] = {\n                        \"name\": branch_name,\n                        \"rootEventId\": branch_info.get(\"rootEventId\"),\n                        \"firstEventId\": event[\"eventId\"],\n                        \"eventCount\": 1,\n                        \"created\": event[\"eventTimestamp\"],\n                    }\n                else:\n                    branches[branch_name][\"eventCount\"] += 1\n            else:\n                main_branch_events.append(event)\n\n        # Build result list\n        result = []\n\n        # Only add main branch if there are actual events\n        if main_branch_events:\n            result.append(\n                {\n                    \"name\": \"main\",\n                    \"rootEventId\": None,\n                    \"firstEventId\": main_branch_events[0][\"eventId\"],\n                    \"eventCount\": len(main_branch_events),\n                    \"created\": main_branch_events[0][\"eventTimestamp\"],\n                }\n            )\n\n        # Add other branches\n        result.extend(list(branches.values()))\n\n        logger.info(\"Found %d branches in session %s\", len(result), session_id)\n        return result\n\n    except ClientError as e:\n        logger.error(\"Failed to list branches: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events","title":"<code>list_events(memory_id, actor_id, session_id, branch_name=None, include_parent_events=False, max_results=100, include_payload=True)</code>","text":"<p>List all events in a session with pagination support.</p> <p>This method provides direct access to the raw events API, allowing developers to retrieve all events without the turn grouping logic of get_last_k_turns.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>Optional[str]</code> <p>Optional branch name to filter events (None for all branches)</p> <code>None</code> <code>include_parent_events</code> <code>bool</code> <p>Whether to include parent branch events (only applies with branch_name)</p> <code>False</code> <code>max_results</code> <code>int</code> <p>Maximum number of events to return</p> <code>100</code> <code>include_payload</code> <code>bool</code> <p>Whether to include event payloads in response</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of event dictionaries in chronological order</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_events(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    branch_name: Optional[str] = None,\n    include_parent_events: bool = False,\n    max_results: int = 100,\n    include_payload: bool = True,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all events in a session with pagination support.\n\n    This method provides direct access to the raw events API, allowing developers\n    to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Optional branch name to filter events (None for all branches)\n        include_parent_events: Whether to include parent branch events (only applies with branch_name)\n        max_results: Maximum number of events to return\n        include_payload: Whether to include event payloads in response\n\n    Returns:\n        List of event dictionaries in chronological order\n\n    Example:\n        # Get all events\n        events = client.list_events(memory_id, actor_id, session_id)\n\n        # Get only main branch events\n        main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")\n\n        # Get events from a specific branch\n        branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")\n    \"\"\"\n    try:\n        all_events = []\n        next_token = None\n\n        while len(all_events) &lt; max_results:\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"maxResults\": min(100, max_results - len(all_events)),\n            }\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            # Add branch filter if specified (but not for \"main\")\n            if branch_name and branch_name != \"main\":\n                params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_events}}\n\n            response = self.gmdp_client.list_events(**params)\n\n            events = response.get(\"events\", [])\n            all_events.extend(events)\n\n            next_token = response.get(\"nextToken\")\n            if not next_token or len(all_events) &gt;= max_results:\n                break\n\n        logger.info(\"Retrieved total of %d events\", len(all_events))\n        return all_events[:max_results]\n\n    except ClientError as e:\n        logger.error(\"Failed to list events: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-all-events","title":"Get all events","text":"<p>events = client.list_events(memory_id, actor_id, session_id)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-only-main-branch-events","title":"Get only main branch events","text":"<p>main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-events-from-a-specific-branch","title":"Get events from a specific branch","text":"<p>branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_memories","title":"<code>list_memories(max_results=100)</code>","text":"<p>List all memories for the account.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all memories for the account.\"\"\"\n    try:\n        # Ensure max_results doesn't exceed API limit per request\n        results_per_request = min(max_results, 100)\n\n        response = self.gmcp_client.list_memories(maxResults=results_per_request)\n        memories = response.get(\"memories\", [])\n\n        next_token = response.get(\"nextToken\")\n        while next_token and len(memories) &lt; max_results:\n            remaining = max_results - len(memories)\n            results_per_request = min(remaining, 100)\n\n            response = self.gmcp_client.list_memories(maxResults=results_per_request, nextToken=next_token)\n            memories.extend(response.get(\"memories\", []))\n            next_token = response.get(\"nextToken\")\n\n        # Normalize memory summaries if they contain new field names\n        normalized_memories = []\n        for memory in memories[:max_results]:\n            normalized = memory.copy()\n            # Ensure both field name versions exist\n            if \"id\" in memory and \"memoryId\" not in normalized:\n                normalized[\"memoryId\"] = memory[\"id\"]\n            elif \"memoryId\" in memory and \"id\" not in normalized:\n                normalized[\"id\"] = memory[\"memoryId\"]\n            normalized_memories.append(normalized)\n\n        return normalized_memories\n\n    except ClientError as e:\n        logger.error(\"Failed to list memories: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.merge_branch_context","title":"<code>merge_branch_context(memory_id, actor_id, session_id, branch_name, include_parent=True)</code>","text":"<p>Get all messages from a branch for context building.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>str</code> <p>Branch to get context from</p> required <code>include_parent</code> <code>bool</code> <p>Whether to include parent branch events</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of all messages in chronological order</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def merge_branch_context(\n    self, memory_id: str, actor_id: str, session_id: str, branch_name: str, include_parent: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all messages from a branch for context building.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Branch to get context from\n        include_parent: Whether to include parent branch events\n\n    Returns:\n        List of all messages in chronological order\n    \"\"\"\n    events = self.list_branch_events(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        branch_name=branch_name,\n        include_parent_events=include_parent,\n        max_results=100,\n    )\n\n    messages = []\n    for event in events:\n        if \"payload\" in event:\n            for payload_item in event.get(\"payload\", []):\n                if \"conversational\" in payload_item:\n                    conv = payload_item[\"conversational\"]\n                    messages.append(\n                        {\n                            \"timestamp\": event[\"eventTimestamp\"],\n                            \"eventId\": event[\"eventId\"],\n                            \"branch\": event.get(\"branch\", {}).get(\"name\", \"main\"),\n                            \"role\": conv.get(\"role\"),\n                            \"content\": conv.get(\"content\", {}).get(\"text\", \"\"),\n                        }\n                    )\n\n    # Sort by timestamp\n    messages.sort(key=lambda x: x[\"timestamp\"])\n\n    logger.info(\"Retrieved %d messages from branch '%s'\", len(messages), branch_name)\n    return messages\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.modify_strategy","title":"<code>modify_strategy(memory_id, strategy_id, description=None, namespaces=None, configuration=None)</code>","text":"<p>Modify a strategy with full control over configuration.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def modify_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    configuration: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Modify a strategy with full control over configuration.\"\"\"\n    modify_config: Dict = {\"memoryStrategyId\": strategy_id}  # Using old field name for input\n\n    if description is not None:\n        modify_config[\"description\"] = description\n    if namespaces is not None:\n        modify_config[\"namespaces\"] = namespaces\n    if configuration is not None:\n        modify_config[\"configuration\"] = configuration\n\n    return self.update_memory_strategies(memory_id=memory_id, modify_strategies=[modify_config])\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.process_turn","title":"<code>process_turn(memory_id, actor_id, session_id, user_input, agent_response, event_timestamp=None, retrieval_namespace=None, retrieval_query=None, top_k=3)</code>","text":"<p>DEPRECATED: Use retrieve_memories() and save_conversation() separately.</p> <p>This method will be removed in v1.0.0.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def process_turn(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    agent_response: str,\n    event_timestamp: Optional[datetime] = None,\n    retrieval_namespace: Optional[str] = None,\n    retrieval_query: Optional[str] = None,\n    top_k: int = 3,\n) -&gt; Tuple[List[Dict[str, Any]], Dict[str, Any]]:\n    \"\"\"DEPRECATED: Use retrieve_memories() and save_conversation() separately.\n\n    This method will be removed in v1.0.0.\n    \"\"\"\n    warnings.warn(\n        \"process_turn() is deprecated and will be removed in v1.0.0. \"\n        \"Use retrieve_memories() and save_conversation() separately, or use process_turn_with_llm().\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    retrieved_memories = []\n\n    if retrieval_namespace:\n        search_query = retrieval_query or user_input\n        retrieved_memories = self.retrieve_memories(\n            memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n        )\n\n    event = self.save_turn(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        user_input=user_input,\n        agent_response=agent_response,\n        event_timestamp=event_timestamp,\n    )\n\n    return retrieved_memories, event\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.process_turn_with_llm","title":"<code>process_turn_with_llm(memory_id, actor_id, session_id, user_input, llm_callback, retrieval_namespace=None, retrieval_query=None, top_k=3, event_timestamp=None)</code>","text":"<p>Complete conversation turn with LLM callback integration.</p> <p>This method combines memory retrieval, LLM invocation, and response storage in a single call using a callback pattern.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier (e.g., \"user-123\")</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>user_input</code> <code>str</code> <p>The user's message</p> required <code>llm_callback</code> <code>Callable[[str, List[Dict[str, Any]]], str]</code> <p>Function that takes (user_input, memories) and returns agent_response          The callback receives the user input and retrieved memories,          and should return the agent's response string</p> required <code>retrieval_namespace</code> <code>Optional[str]</code> <p>Namespace to search for memories (optional)</p> <code>None</code> <code>retrieval_query</code> <code>Optional[str]</code> <p>Custom search query (defaults to user_input)</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of memories to retrieve</p> <code>3</code> <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the event</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[Dict[str, Any]], str, Dict[str, Any]]</code> <p>Tuple of (retrieved_memories, agent_response, created_event)</p> Example <p>def my_llm(user_input: str, memories: List[Dict]) -&gt; str:     # Format context from memories     context = \"\\n\".join([m['content']['text'] for m in memories])</p> <pre><code># Call your LLM (Bedrock, OpenAI, etc.)\nresponse = bedrock.invoke_model(\n    messages=[\n        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n        {\"role\": \"user\", \"content\": user_input}\n    ]\n)\nreturn response['content']\n</code></pre> <p>memories, response, event = client.process_turn_with_llm(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     user_input=\"What did we discuss yesterday?\",     llm_callback=my_llm,     retrieval_namespace=\"support/facts/{sessionId}\" )</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def process_turn_with_llm(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n    retrieval_namespace: Optional[str] = None,\n    retrieval_query: Optional[str] = None,\n    top_k: int = 3,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n    r\"\"\"Complete conversation turn with LLM callback integration.\n\n    This method combines memory retrieval, LLM invocation, and response storage\n    in a single call using a callback pattern.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier (e.g., \"user-123\")\n        session_id: Session identifier\n        user_input: The user's message\n        llm_callback: Function that takes (user_input, memories) and returns agent_response\n                     The callback receives the user input and retrieved memories,\n                     and should return the agent's response string\n        retrieval_namespace: Namespace to search for memories (optional)\n        retrieval_query: Custom search query (defaults to user_input)\n        top_k: Number of memories to retrieve\n        event_timestamp: Optional timestamp for the event\n\n    Returns:\n        Tuple of (retrieved_memories, agent_response, created_event)\n\n    Example:\n        def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n            # Format context from memories\n            context = \"\\\\n\".join([m['content']['text'] for m in memories])\n\n            # Call your LLM (Bedrock, OpenAI, etc.)\n            response = bedrock.invoke_model(\n                messages=[\n                    {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                    {\"role\": \"user\", \"content\": user_input}\n                ]\n            )\n            return response['content']\n\n        memories, response, event = client.process_turn_with_llm(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            user_input=\"What did we discuss yesterday?\",\n            llm_callback=my_llm,\n            retrieval_namespace=\"support/facts/{sessionId}\"\n        )\n    \"\"\"\n    # Step 1: Retrieve relevant memories\n    retrieved_memories = []\n    if retrieval_namespace:\n        search_query = retrieval_query or user_input\n        retrieved_memories = self.retrieve_memories(\n            memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n        )\n        logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n    # Step 2: Invoke LLM callback\n    try:\n        agent_response = llm_callback(user_input, retrieved_memories)\n        if not isinstance(agent_response, str):\n            raise ValueError(\"LLM callback must return a string response\")\n        logger.info(\"LLM callback generated response\")\n    except Exception as e:\n        logger.error(\"LLM callback failed: %s\", e)\n        raise\n\n    # Step 3: Save the conversation turn\n    event = self.create_event(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        messages=[(user_input, \"USER\"), (agent_response, \"ASSISTANT\")],\n        event_timestamp=event_timestamp,\n    )\n\n    logger.info(\"Completed full conversation turn with LLM\")\n    return retrieved_memories, agent_response, event\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories","title":"<code>retrieve_memories(memory_id, namespace, query, actor_id=None, top_k=3)</code>","text":"<p>Retrieve relevant memories from a namespace.</p> <p>Note: Wildcards (*) are NOT supported in namespaces. You must provide the exact namespace path with all variables resolved.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>namespace</code> <code>str</code> <p>Exact namespace path (no wildcards)</p> required <code>query</code> <code>str</code> <p>Search query</p> required <code>actor_id</code> <code>Optional[str]</code> <p>Optional actor ID (deprecated, use namespace)</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of results to return</p> <code>3</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of memory records</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def retrieve_memories(\n    self, memory_id: str, namespace: str, query: str, actor_id: Optional[str] = None, top_k: int = 3\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Retrieve relevant memories from a namespace.\n\n    Note: Wildcards (*) are NOT supported in namespaces. You must provide the\n    exact namespace path with all variables resolved.\n\n    Args:\n        memory_id: Memory resource ID\n        namespace: Exact namespace path (no wildcards)\n        query: Search query\n        actor_id: Optional actor ID (deprecated, use namespace)\n        top_k: Number of results to return\n\n    Returns:\n        List of memory records\n\n    Example:\n        # Correct - exact namespace\n        memories = client.retrieve_memories(\n            memory_id=\"mem-123\",\n            namespace=\"support/facts/session-456\",\n            query=\"customer preferences\"\n        )\n\n        # Incorrect - wildcards not supported\n        # memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)\n    \"\"\"\n    if \"*\" in namespace:\n        logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n        return []\n\n    try:\n        # Let service handle all namespace validation\n        response = self.gmdp_client.retrieve_memory_records(\n            memoryId=memory_id, namespace=namespace, searchCriteria={\"searchQuery\": query, \"topK\": top_k}\n        )\n\n        memories = response.get(\"memoryRecordSummaries\", [])\n        logger.info(\"Retrieved %d memories from namespace: %s\", len(memories), namespace)\n        return memories\n\n    except ClientError as e:\n        error_code = e.response[\"Error\"][\"Code\"]\n        error_msg = e.response[\"Error\"][\"Message\"]\n\n        if error_code == \"ResourceNotFoundException\":\n            logger.warning(\n                \"Memory or namespace not found. Ensure memory %s exists and namespace '%s' is configured\",\n                memory_id,\n                namespace,\n            )\n        elif error_code == \"ValidationException\":\n            logger.warning(\"Invalid search parameters: %s\", error_msg)\n        elif error_code == \"ServiceException\":\n            logger.warning(\"Service error: %s. This may be temporary - try again later\", error_msg)\n        else:\n            logger.warning(\"Memory retrieval failed (%s): %s\", error_code, error_msg)\n\n        return []\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--correct-exact-namespace","title":"Correct - exact namespace","text":"<p>memories = client.retrieve_memories(     memory_id=\"mem-123\",     namespace=\"support/facts/session-456\",     query=\"customer preferences\" )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--incorrect-wildcards-not-supported","title":"Incorrect - wildcards not supported","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--memories-clientretrieve_memories-namespacesupportfacts","title":"memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation","title":"<code>save_conversation(memory_id, actor_id, session_id, messages, event_timestamp=None, branch=None)</code>","text":"<p>DEPRECATED: Use create_event() instead.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>messages</code> <code>List[Tuple[str, str]]</code> <p>List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the entire event (not per message)</p> <code>None</code> <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}    For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created event</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def save_conversation(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n    branch: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"DEPRECATED: Use create_event() instead.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n        event_timestamp: Optional timestamp for the entire event (not per message)\n        branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n               For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n\n    Returns:\n        Created event\n\n    Example:\n        # Save multi-turn conversation\n        event = client.save_conversation(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            messages=[\n                (\"What's the weather?\", \"USER\"),\n                (\"And tomorrow?\", \"USER\"),\n                (\"Checking weather...\", \"TOOL\"),\n                (\"Today sunny, tomorrow rain\", \"ASSISTANT\")\n            ]\n        )\n\n        # Continue existing branch (only name required)\n        event = client.save_conversation(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            messages=[(\"Continue conversation\", \"USER\")],\n            branch={\"name\": \"existing-branch\"}\n        )\n    \"\"\"\n    try:\n        if not messages:\n            raise ValueError(\"At least one message is required\")\n\n        # Build payload\n        payload = []\n\n        for msg in messages:\n            if len(msg) != 2:\n                raise ValueError(\"Each message must be (text, role)\")\n\n            text, role = msg\n\n            # Validate role\n            try:\n                role_enum = MessageRole(role.upper())\n            except ValueError as err:\n                raise ValueError(\n                    \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                ) from err\n\n            payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n        # Use provided timestamp or current time\n        if event_timestamp is None:\n            event_timestamp = datetime.utcnow()\n\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n\n        response = self.gmdp_client.create_event(**params)\n\n        event = response[\"event\"]\n        logger.info(\"Created event: %s\", event[\"eventId\"])\n\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to create event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation--save-multi-turn-conversation","title":"Save multi-turn conversation","text":"<p>event = client.save_conversation(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     messages=[         (\"What's the weather?\", \"USER\"),         (\"And tomorrow?\", \"USER\"),         (\"Checking weather...\", \"TOOL\"),         (\"Today sunny, tomorrow rain\", \"ASSISTANT\")     ] )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation--continue-existing-branch-only-name-required","title":"Continue existing branch (only name required)","text":"<p>event = client.save_conversation(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     messages=[(\"Continue conversation\", \"USER\")],     branch={\"name\": \"existing-branch\"} )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_turn","title":"<code>save_turn(memory_id, actor_id, session_id, user_input, agent_response, event_timestamp=None)</code>","text":"<p>DEPRECATED: Use save_conversation() for more flexibility.</p> <p>This method will be removed in v1.0.0.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def save_turn(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    agent_response: str,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"DEPRECATED: Use save_conversation() for more flexibility.\n\n    This method will be removed in v1.0.0.\n    \"\"\"\n    warnings.warn(\n        \"save_turn() is deprecated and will be removed in v1.0.0. \"\n        \"Use save_conversation() for flexible message handling.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    messages = [(user_input, \"USER\"), (agent_response, \"ASSISTANT\")]\n\n    return self.create_event(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        messages=messages,\n        event_timestamp=event_timestamp,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.update_memory_strategies","title":"<code>update_memory_strategies(memory_id, add_strategies=None, modify_strategies=None, delete_strategy_ids=None)</code>","text":"<p>Update memory strategies - add, modify, or delete.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def update_memory_strategies(\n    self,\n    memory_id: str,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update memory strategies - add, modify, or delete.\"\"\"\n    try:\n        memory_strategies = {}\n\n        if add_strategies:\n            processed_add = self._add_default_namespaces(add_strategies)\n            memory_strategies[\"addMemoryStrategies\"] = processed_add  # Using old field name for input\n\n        if modify_strategies:\n            current_strategies = self.get_memory_strategies(memory_id)\n            strategy_map = {s[\"memoryStrategyId\"]: s for s in current_strategies}  # Using normalized field\n\n            modify_list = []\n            for strategy in modify_strategies:\n                if \"memoryStrategyId\" not in strategy:  # Using old field name\n                    raise ValueError(\"Each modify strategy must include memoryStrategyId\")\n\n                strategy_id = strategy[\"memoryStrategyId\"]  # Using old field name\n                strategy_info = strategy_map.get(strategy_id)\n\n                if not strategy_info:\n                    raise ValueError(\"Strategy %s not found in memory %s\" % (strategy_id, memory_id))\n\n                strategy_type = strategy_info[\"memoryStrategyType\"]  # Using normalized field\n                override_type = strategy_info.get(\"configuration\", {}).get(\"type\")\n\n                strategy_copy = copy.deepcopy(strategy)\n\n                if \"configuration\" in strategy_copy:\n                    wrapped_config = self._wrap_configuration(\n                        strategy_copy[\"configuration\"], strategy_type, override_type\n                    )\n                    strategy_copy[\"configuration\"] = wrapped_config\n\n                modify_list.append(strategy_copy)\n\n            memory_strategies[\"modifyMemoryStrategies\"] = modify_list  # Using old field name for input\n\n        if delete_strategy_ids:\n            delete_list = [{\"memoryStrategyId\": sid} for sid in delete_strategy_ids]  # Using old field name\n            memory_strategies[\"deleteMemoryStrategies\"] = delete_list  # Using old field name for input\n\n        if not memory_strategies:\n            raise ValueError(\"No strategy operations provided\")\n\n        response = self.gmcp_client.update_memory(\n            memoryId=memory_id,\n            memoryStrategies=memory_strategies,\n            clientToken=str(uuid.uuid4()),  # Using old field names for input\n        )\n\n        logger.info(\"Updated memory strategies for: %s\", memory_id)\n        memory = self._normalize_memory_response(response[\"memory\"])\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to update memory strategies: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.update_memory_strategies_and_wait","title":"<code>update_memory_strategies_and_wait(memory_id, add_strategies=None, modify_strategies=None, delete_strategy_ids=None, max_wait=300, poll_interval=10)</code>","text":"<p>Update memory strategies and wait for memory to return to ACTIVE state.</p> <p>This method handles the temporary CREATING state that occurs when updating strategies, preventing subsequent update errors.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def update_memory_strategies_and_wait(\n    self,\n    memory_id: str,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update memory strategies and wait for memory to return to ACTIVE state.\n\n    This method handles the temporary CREATING state that occurs when\n    updating strategies, preventing subsequent update errors.\n    \"\"\"\n    # Update strategies\n    self.update_memory_strategies(memory_id, add_strategies, modify_strategies, delete_strategy_ids)\n\n    # Wait for memory to return to ACTIVE\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.wait_for_memories","title":"<code>wait_for_memories(memory_id, namespace, test_query='test', max_wait=180, poll_interval=15)</code>","text":"<p>Wait for memory extraction to complete by polling.</p> <p>IMPORTANT LIMITATIONS: 1. This method only works reliably on empty namespaces. If there are already    existing memories in the namespace, this method may return True immediately    even if new extractions haven't completed. 2. Wildcards () are NOT supported in namespaces. You must provide the exact    namespace path with all variables resolved (e.g., \"support/facts/session-123\"    not \"support/facts/\").</p> <p>For subsequent extractions in populated namespaces, use a fixed wait time:     time.sleep(150)  # Wait 2.5 minutes for extraction</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>namespace</code> <code>str</code> <p>Exact namespace to check (no wildcards)</p> required <code>test_query</code> <code>str</code> <p>Query to test with (default: \"test\")</p> <code>'test'</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 180)</p> <code>180</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks (default: 15)</p> <code>15</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if memories found, False if timeout</p> Note <p>This method will be deprecated in future versions once the API provides extraction status or timestamps.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def wait_for_memories(\n    self, memory_id: str, namespace: str, test_query: str = \"test\", max_wait: int = 180, poll_interval: int = 15\n) -&gt; bool:\n    \"\"\"Wait for memory extraction to complete by polling.\n\n    IMPORTANT LIMITATIONS:\n    1. This method only works reliably on empty namespaces. If there are already\n       existing memories in the namespace, this method may return True immediately\n       even if new extractions haven't completed.\n    2. Wildcards (*) are NOT supported in namespaces. You must provide the exact\n       namespace path with all variables resolved (e.g., \"support/facts/session-123\"\n       not \"support/facts/*\").\n\n    For subsequent extractions in populated namespaces, use a fixed wait time:\n        time.sleep(150)  # Wait 2.5 minutes for extraction\n\n    Args:\n        memory_id: Memory resource ID\n        namespace: Exact namespace to check (no wildcards)\n        test_query: Query to test with (default: \"test\")\n        max_wait: Maximum seconds to wait (default: 180)\n        poll_interval: Seconds between checks (default: 15)\n\n    Returns:\n        True if memories found, False if timeout\n\n    Note:\n        This method will be deprecated in future versions once the API\n        provides extraction status or timestamps.\n    \"\"\"\n    if \"*\" in namespace:\n        logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n        return False\n\n    logger.warning(\n        \"wait_for_memories() only works reliably on empty namespaces. \"\n        \"For populated namespaces, consider using a fixed wait time instead.\"\n    )\n\n    logger.info(\"Waiting for memory extraction in namespace: %s\", namespace)\n    start_time = time.time()\n    service_errors = 0\n\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            memories = self.retrieve_memories(memory_id=memory_id, namespace=namespace, query=test_query, top_k=1)\n\n            if memories:\n                logger.info(\"Memory extraction complete after %d seconds\", elapsed)\n                return True\n\n            # Reset service error count on successful call\n            service_errors = 0\n\n        except Exception as e:\n            if \"ServiceException\" in str(e):\n                service_errors += 1\n                if service_errors &gt;= 3:\n                    logger.warning(\"Multiple service errors - the service may be experiencing issues\")\n            logger.debug(\"Retrieval attempt failed: %s\", e)\n\n        if time.time() - start_time &lt; max_wait:\n            time.sleep(poll_interval)\n\n    logger.warning(\"No memories found after %d seconds\", max_wait)\n    if service_errors &gt; 0:\n        logger.info(\"Note: Encountered %d service errors during polling\", service_errors)\n    return False\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient","title":"<code>MemoryControlPlaneClient</code>","text":"<p>Client for Bedrock AgentCore Memory control plane operations.</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>class MemoryControlPlaneClient:\n    \"\"\"Client for Bedrock AgentCore Memory control plane operations.\"\"\"\n\n    def __init__(self, region_name: str = \"us-west-2\", environment: str = \"prod\"):\n        \"\"\"Initialize the Memory Control Plane client.\n\n        Args:\n            region_name: AWS region name\n            environment: Environment name (prod, gamma, etc.)\n        \"\"\"\n        self.region_name = region_name\n        self.environment = environment\n\n        self.endpoint = os.getenv(\n            \"BEDROCK_AGENTCORE_CONTROL_ENDPOINT\", f\"https://bedrock-agentcore-control.{region_name}.amazonaws.com\"\n        )\n\n        service_name = os.getenv(\"BEDROCK_AGENTCORE_CONTROL_SERVICE\", \"bedrock-agentcore-control\")\n        self.client = boto3.client(service_name, region_name=self.region_name, endpoint_url=self.endpoint)\n\n        logger.info(\"Initialized MemoryControlPlaneClient for %s in %s\", environment, region_name)\n\n    # ==================== MEMORY OPERATIONS ====================\n\n    def create_memory(\n        self,\n        name: str,\n        event_expiry_days: int = 90,\n        description: Optional[str] = None,\n        memory_execution_role_arn: Optional[str] = None,\n        strategies: Optional[List[Dict[str, Any]]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory resource with optional strategies.\n\n        Args:\n            name: Name for the memory resource\n            event_expiry_days: How long to retain events (default: 90 days)\n            description: Optional description\n            memory_execution_role_arn: IAM role ARN for memory execution\n            strategies: Optional list of strategy configurations\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Created memory object\n        \"\"\"\n        params = {\n            \"name\": name,\n            \"eventExpiryDuration\": event_expiry_days,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if description:\n            params[\"description\"] = description\n\n        if memory_execution_role_arn:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        if strategies:\n            params[\"memoryStrategies\"] = strategies\n\n        try:\n            response = self.client.create_memory(**params)\n            memory = response[\"memory\"]\n            memory_id = memory[\"id\"]\n\n            logger.info(\"Created memory: %s\", memory_id)\n\n            if wait_for_active:\n                return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to create memory: %s\", e)\n            raise\n\n    def get_memory(self, memory_id: str, include_strategies: bool = True) -&gt; Dict[str, Any]:\n        \"\"\"Get a memory resource by ID.\n\n        Args:\n            memory_id: Memory resource ID\n            include_strategies: Whether to include strategy details in response\n\n        Returns:\n            Memory resource details\n        \"\"\"\n        try:\n            response = self.client.get_memory(memoryId=memory_id)\n            memory = response[\"memory\"]\n\n            # Add strategy count\n            strategies = memory.get(\"strategies\", [])\n            memory[\"strategyCount\"] = len(strategies)\n\n            # Remove strategies if not requested\n            if not include_strategies and \"strategies\" in memory:\n                del memory[\"strategies\"]\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to get memory: %s\", e)\n            raise\n\n    def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all memories for the account with pagination support.\n\n        Args:\n            max_results: Maximum number of memories to return\n\n        Returns:\n            List of memory summaries\n        \"\"\"\n        try:\n            memories = []\n            next_token = None\n\n            while len(memories) &lt; max_results:\n                params = {\"maxResults\": min(100, max_results - len(memories))}\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.client.list_memories(**params)\n                batch = response.get(\"memories\", [])\n                memories.extend(batch)\n\n                next_token = response.get(\"nextToken\")\n                if not next_token or len(memories) &gt;= max_results:\n                    break\n\n            # Add strategy count to each memory summary\n            for memory in memories:\n                memory[\"strategyCount\"] = 0  # List memories doesn't include strategies\n\n            return memories[:max_results]\n\n        except ClientError as e:\n            logger.error(\"Failed to list memories: %s\", e)\n            raise\n\n    def update_memory(\n        self,\n        memory_id: str,\n        description: Optional[str] = None,\n        event_expiry_days: Optional[int] = None,\n        memory_execution_role_arn: Optional[str] = None,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update a memory resource properties and/or strategies.\n\n        Args:\n            memory_id: Memory resource ID\n            description: Optional new description\n            event_expiry_days: Optional new event expiry duration\n            memory_execution_role_arn: Optional new execution role ARN\n            add_strategies: Optional list of strategies to add\n            modify_strategies: Optional list of strategies to modify\n            delete_strategy_ids: Optional list of strategy IDs to delete\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        params: Dict = {\n            \"memoryId\": memory_id,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        # Add memory properties if provided\n        if description is not None:\n            params[\"description\"] = description\n\n        if event_expiry_days is not None:\n            params[\"eventExpiryDuration\"] = event_expiry_days\n\n        if memory_execution_role_arn is not None:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        # Add strategy operations if provided\n        memory_strategies = {}\n\n        if add_strategies:\n            memory_strategies[\"addMemoryStrategies\"] = add_strategies\n\n        if modify_strategies:\n            memory_strategies[\"modifyMemoryStrategies\"] = modify_strategies\n\n        if delete_strategy_ids:\n            memory_strategies[\"deleteMemoryStrategies\"] = [\n                {\"memoryStrategyId\": strategy_id} for strategy_id in delete_strategy_ids\n            ]\n\n        if memory_strategies:\n            params[\"memoryStrategies\"] = memory_strategies\n\n        try:\n            response = self.client.update_memory(**params)\n            memory = response[\"memory\"]\n            logger.info(\"Updated memory: %s\", memory_id)\n\n            if wait_for_active:\n                return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to update memory: %s\", e)\n            raise\n\n    def delete_memory(\n        self,\n        memory_id: str,\n        wait_for_deletion: bool = False,\n        wait_for_strategies: bool = False,  # Changed default to False\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory resource.\n\n        Args:\n            memory_id: Memory resource ID to delete\n            wait_for_deletion: Whether to wait for complete deletion\n            wait_for_strategies: Whether to wait for strategies to become ACTIVE before deletion\n            max_wait: Maximum seconds to wait if wait_for_deletion is True\n            poll_interval: Seconds between checks if wait_for_deletion is True\n\n        Returns:\n            Deletion response\n        \"\"\"\n        try:\n            # If requested, wait for all strategies to become ACTIVE before deletion\n            if wait_for_strategies:\n                try:\n                    memory = self.get_memory(memory_id)\n                    strategies = memory.get(\"strategies\", [])\n\n                    # Check if any strategies are in a transitional state\n                    transitional_strategies = [\n                        s\n                        for s in strategies\n                        if s.get(\"status\") not in [MemoryStatus.ACTIVE.value, MemoryStatus.FAILED.value]\n                    ]\n\n                    if transitional_strategies:\n                        logger.info(\n                            \"Waiting for %d strategies to become ACTIVE before deletion\", len(transitional_strategies)\n                        )\n                        self._wait_for_status(\n                            memory_id=memory_id,\n                            target_status=MemoryStatus.ACTIVE.value,\n                            max_wait=max_wait,\n                            poll_interval=poll_interval,\n                            check_strategies=True,\n                        )\n                except Exception as e:\n                    logger.warning(\"Error waiting for strategies to become ACTIVE: %s\", e)\n\n            # Now delete the memory\n            response = self.client.delete_memory(memoryId=memory_id, clientToken=str(uuid.uuid4()))\n\n            logger.info(\"Initiated deletion of memory: %s\", memory_id)\n\n            if not wait_for_deletion:\n                return response\n\n            # Wait for deletion to complete\n            start_time = time.time()\n            while time.time() - start_time &lt; max_wait:\n                try:\n                    self.client.get_memory(memoryId=memory_id)\n                    time.sleep(poll_interval)\n                except ClientError as e:\n                    if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                        logger.info(\"Memory %s successfully deleted\", memory_id)\n                        return response\n                    raise\n\n            raise TimeoutError(f\"Memory {memory_id} was not deleted within {max_wait} seconds\")\n\n        except ClientError as e:\n            logger.error(\"Failed to delete memory: %s\", e)\n            raise\n\n    # ==================== STRATEGY OPERATIONS ====================\n\n    def add_strategy(\n        self,\n        memory_id: str,\n        strategy: Dict[str, Any],\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a strategy to a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy: Strategy configuration dictionary\n            wait_for_active: Whether to wait for strategy to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object with strategyId field\n        \"\"\"\n        # Get the strategy type and name for identification\n        strategy_type = list(strategy.keys())[0]  # e.g., 'semanticMemoryStrategy'\n        strategy_name = strategy[strategy_type].get(\"name\")\n\n        logger.info(\"Adding strategy %s of type %s to memory %s\", strategy_name, strategy_type, memory_id)\n\n        # Use update_memory with add_strategies parameter but don't wait for memory\n        memory = self.update_memory(\n            memory_id=memory_id,\n            add_strategies=[strategy],\n            wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n        )\n\n        # If we need to wait for the strategy to become active\n        if wait_for_active:\n            # First, get the memory again to ensure we have the latest state\n            memory = self.get_memory(memory_id)\n\n            # Find the newly added strategy by matching name\n            strategies = memory.get(\"strategies\", [])\n            strategy_id = None\n\n            for s in strategies:\n                # Match by name since that's unique within a memory\n                if s.get(\"name\") == strategy_name:\n                    strategy_id = s.get(\"strategyId\")\n                    logger.info(\"Found newly added strategy %s with ID %s\", strategy_name, strategy_id)\n                    break\n\n            if strategy_id:\n                return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n            else:\n                logger.warning(\"Could not identify newly added strategy %s to wait for activation\", strategy_name)\n\n        return memory\n\n    def get_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get a specific strategy from a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID\n\n        Returns:\n            Strategy details\n        \"\"\"\n        try:\n            memory = self.get_memory(memory_id)\n            strategies = memory.get(\"strategies\", [])\n\n            for strategy in strategies:\n                if strategy.get(\"strategyId\") == strategy_id:\n                    return strategy\n\n            raise ValueError(f\"Strategy {strategy_id} not found in memory {memory_id}\")\n\n        except ClientError as e:\n            logger.error(\"Failed to get strategy: %s\", e)\n            raise\n\n    def update_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        configuration: Optional[Dict[str, Any]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update a strategy in a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID to update\n            description: Optional new description\n            namespaces: Optional new namespaces list\n            configuration: Optional new configuration\n            wait_for_active: Whether to wait for strategy to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        # Note: API expects memoryStrategyId for input but returns strategyId in response\n        modify_config: Dict = {\"memoryStrategyId\": strategy_id}\n\n        if description is not None:\n            modify_config[\"description\"] = description\n\n        if namespaces is not None:\n            modify_config[\"namespaces\"] = namespaces\n\n        if configuration is not None:\n            modify_config[\"configuration\"] = configuration\n\n        # Use update_memory with modify_strategies parameter but don't wait for memory\n        memory = self.update_memory(\n            memory_id=memory_id,\n            modify_strategies=[modify_config],\n            wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n        )\n\n        # If we need to wait for the strategy to become active\n        if wait_for_active:\n            return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n\n        return memory\n\n    def remove_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Remove a strategy from a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID to remove\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        # For remove_strategy, we only need to wait for memory to be active\n        # since the strategy will be gone\n        return self.update_memory(\n            memory_id=memory_id,\n            delete_strategy_ids=[strategy_id],\n            wait_for_active=wait_for_active,\n            max_wait=max_wait,\n            poll_interval=poll_interval,\n        )\n\n    # ==================== HELPER METHODS ====================\n\n    def _wait_for_memory_active(self, memory_id: str, max_wait: int, poll_interval: int) -&gt; Dict[str, Any]:\n        \"\"\"Wait for memory to return to ACTIVE state.\"\"\"\n        logger.info(\"Waiting for memory %s to become ACTIVE...\", memory_id)\n        return self._wait_for_status(\n            memory_id=memory_id, target_status=MemoryStatus.ACTIVE.value, max_wait=max_wait, poll_interval=poll_interval\n        )\n\n    def _wait_for_strategy_active(\n        self, memory_id: str, strategy_id: str, max_wait: int, poll_interval: int\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Wait for specific memory strategy to become ACTIVE.\"\"\"\n        logger.info(\"Waiting for strategy %s to become ACTIVE (max wait: %d seconds)...\", strategy_id, max_wait)\n\n        start_time = time.time()\n        last_status = None\n\n        while time.time() - start_time &lt; max_wait:\n            try:\n                memory = self.get_memory(memory_id)\n                strategies = memory.get(\"strategies\", [])\n\n                for strategy in strategies:\n                    if strategy.get(\"strategyId\") == strategy_id:\n                        status = strategy[\"status\"]\n\n                        # Log status changes\n                        if status != last_status:\n                            logger.info(\"Strategy %s status: %s\", strategy_id, status)\n                            last_status = status\n\n                        if status == MemoryStatus.ACTIVE.value:\n                            elapsed = time.time() - start_time\n                            logger.info(\"Strategy %s is now ACTIVE (took %.1f seconds)\", strategy_id, elapsed)\n                            return memory\n                        elif status == MemoryStatus.FAILED.value:\n                            failure_reason = strategy.get(\"failureReason\", \"Unknown\")\n                            raise RuntimeError(f\"Strategy {strategy_id} failed to activate: {failure_reason}\")\n\n                        break\n                else:\n                    logger.warning(\"Strategy %s not found in memory %s\", strategy_id, memory_id)\n\n                # Wait before checking again\n                time.sleep(poll_interval)\n\n            except ClientError as e:\n                logger.error(\"Error checking strategy status: %s\", e)\n                raise\n\n        elapsed = time.time() - start_time\n        raise TimeoutError(\n            f\"Strategy {strategy_id} did not become ACTIVE within {max_wait} seconds (last status: {last_status})\"\n        )\n\n    def _wait_for_status(\n        self, memory_id: str, target_status: str, max_wait: int, poll_interval: int, check_strategies: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Generic method to wait for a memory to reach a specific status.\n\n        Args:\n            memory_id: The ID of the memory to check\n            target_status: The status to wait for (e.g., \"ACTIVE\")\n            max_wait: Maximum time to wait in seconds\n            poll_interval: Time between status checks in seconds\n            check_strategies: Whether to also check that all strategies are in the target status\n\n        Returns:\n            The memory object once it reaches the target status\n\n        Raises:\n            TimeoutError: If the memory doesn't reach the target status within max_wait\n            RuntimeError: If the memory or any strategy reaches a FAILED state\n        \"\"\"\n        logger.info(\"Waiting for memory %s to reach status %s...\", memory_id, target_status)\n\n        start_time = time.time()\n        last_memory_status = None\n        strategy_statuses = {}\n\n        while time.time() - start_time &lt; max_wait:\n            try:\n                memory = self.get_memory(memory_id)\n                status = memory.get(\"status\")\n\n                # Log status changes for memory\n                if status != last_memory_status:\n                    logger.info(\"Memory %s status: %s\", memory_id, status)\n                    last_memory_status = status\n\n                if status == target_status:\n                    # Check if all strategies are also in the target status\n                    if check_strategies and target_status == MemoryStatus.ACTIVE.value:\n                        strategies = memory.get(\"strategies\", [])\n                        all_strategies_active = True\n\n                        for strategy in strategies:\n                            strategy_id = strategy.get(\"strategyId\")\n                            strategy_status = strategy.get(\"status\")\n\n                            # Log strategy status changes\n                            if (\n                                strategy_id not in strategy_statuses\n                                or strategy_statuses[strategy_id] != strategy_status\n                            ):\n                                logger.info(\"Strategy %s status: %s\", strategy_id, strategy_status)\n                                strategy_statuses[strategy_id] = strategy_status\n\n                            if strategy_status != target_status:\n                                if strategy_status == MemoryStatus.FAILED.value:\n                                    failure_reason = strategy.get(\"failureReason\", \"Unknown\")\n                                    raise RuntimeError(f\"Strategy {strategy_id} failed: {failure_reason}\")\n\n                                all_strategies_active = False\n\n                        if not all_strategies_active:\n                            logger.info(\n                                \"Memory %s is %s but %d strategies are still processing\",\n                                memory_id,\n                                target_status,\n                                len([s for s in strategies if s.get(\"status\") != target_status]),\n                            )\n                            time.sleep(poll_interval)\n                            continue\n\n                    elapsed = time.time() - start_time\n                    logger.info(\n                        \"Memory %s and all strategies are now %s (took %.1f seconds)\", memory_id, target_status, elapsed\n                    )\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    failure_reason = memory.get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(f\"Memory operation failed: {failure_reason}\")\n\n                time.sleep(poll_interval)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n        elapsed = time.time() - start_time\n        raise TimeoutError(\n            f\"Memory {memory_id} did not reach status {target_status} within {max_wait} seconds \"\n            f\"(elapsed: {elapsed:.1f}s)\"\n        )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.__init__","title":"<code>__init__(region_name='us-west-2', environment='prod')</code>","text":"<p>Initialize the Memory Control Plane client.</p> <p>Parameters:</p> Name Type Description Default <code>region_name</code> <code>str</code> <p>AWS region name</p> <code>'us-west-2'</code> <code>environment</code> <code>str</code> <p>Environment name (prod, gamma, etc.)</p> <code>'prod'</code> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def __init__(self, region_name: str = \"us-west-2\", environment: str = \"prod\"):\n    \"\"\"Initialize the Memory Control Plane client.\n\n    Args:\n        region_name: AWS region name\n        environment: Environment name (prod, gamma, etc.)\n    \"\"\"\n    self.region_name = region_name\n    self.environment = environment\n\n    self.endpoint = os.getenv(\n        \"BEDROCK_AGENTCORE_CONTROL_ENDPOINT\", f\"https://bedrock-agentcore-control.{region_name}.amazonaws.com\"\n    )\n\n    service_name = os.getenv(\"BEDROCK_AGENTCORE_CONTROL_SERVICE\", \"bedrock-agentcore-control\")\n    self.client = boto3.client(service_name, region_name=self.region_name, endpoint_url=self.endpoint)\n\n    logger.info(\"Initialized MemoryControlPlaneClient for %s in %s\", environment, region_name)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.add_strategy","title":"<code>add_strategy(memory_id, strategy, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Add a strategy to a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy</code> <code>Dict[str, Any]</code> <p>Strategy configuration dictionary</p> required <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for strategy to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object with strategyId field</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def add_strategy(\n    self,\n    memory_id: str,\n    strategy: Dict[str, Any],\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a strategy to a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy: Strategy configuration dictionary\n        wait_for_active: Whether to wait for strategy to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object with strategyId field\n    \"\"\"\n    # Get the strategy type and name for identification\n    strategy_type = list(strategy.keys())[0]  # e.g., 'semanticMemoryStrategy'\n    strategy_name = strategy[strategy_type].get(\"name\")\n\n    logger.info(\"Adding strategy %s of type %s to memory %s\", strategy_name, strategy_type, memory_id)\n\n    # Use update_memory with add_strategies parameter but don't wait for memory\n    memory = self.update_memory(\n        memory_id=memory_id,\n        add_strategies=[strategy],\n        wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n    )\n\n    # If we need to wait for the strategy to become active\n    if wait_for_active:\n        # First, get the memory again to ensure we have the latest state\n        memory = self.get_memory(memory_id)\n\n        # Find the newly added strategy by matching name\n        strategies = memory.get(\"strategies\", [])\n        strategy_id = None\n\n        for s in strategies:\n            # Match by name since that's unique within a memory\n            if s.get(\"name\") == strategy_name:\n                strategy_id = s.get(\"strategyId\")\n                logger.info(\"Found newly added strategy %s with ID %s\", strategy_name, strategy_id)\n                break\n\n        if strategy_id:\n            return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n        else:\n            logger.warning(\"Could not identify newly added strategy %s to wait for activation\", strategy_name)\n\n    return memory\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.create_memory","title":"<code>create_memory(name, event_expiry_days=90, description=None, memory_execution_role_arn=None, strategies=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Create a memory resource with optional strategies.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the memory resource</p> required <code>event_expiry_days</code> <code>int</code> <p>How long to retain events (default: 90 days)</p> <code>90</code> <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>IAM role ARN for memory execution</p> <code>None</code> <code>strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategy configurations</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def create_memory(\n    self,\n    name: str,\n    event_expiry_days: int = 90,\n    description: Optional[str] = None,\n    memory_execution_role_arn: Optional[str] = None,\n    strategies: Optional[List[Dict[str, Any]]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory resource with optional strategies.\n\n    Args:\n        name: Name for the memory resource\n        event_expiry_days: How long to retain events (default: 90 days)\n        description: Optional description\n        memory_execution_role_arn: IAM role ARN for memory execution\n        strategies: Optional list of strategy configurations\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Created memory object\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"eventExpiryDuration\": event_expiry_days,\n        \"clientToken\": str(uuid.uuid4()),\n    }\n\n    if description:\n        params[\"description\"] = description\n\n    if memory_execution_role_arn:\n        params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n    if strategies:\n        params[\"memoryStrategies\"] = strategies\n\n    try:\n        response = self.client.create_memory(**params)\n        memory = response[\"memory\"]\n        memory_id = memory[\"id\"]\n\n        logger.info(\"Created memory: %s\", memory_id)\n\n        if wait_for_active:\n            return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to create memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.delete_memory","title":"<code>delete_memory(memory_id, wait_for_deletion=False, wait_for_strategies=False, max_wait=300, poll_interval=10)</code>","text":"<p>Delete a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID to delete</p> required <code>wait_for_deletion</code> <code>bool</code> <p>Whether to wait for complete deletion</p> <code>False</code> <code>wait_for_strategies</code> <code>bool</code> <p>Whether to wait for strategies to become ACTIVE before deletion</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_deletion is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks if wait_for_deletion is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Deletion response</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def delete_memory(\n    self,\n    memory_id: str,\n    wait_for_deletion: bool = False,\n    wait_for_strategies: bool = False,  # Changed default to False\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory resource.\n\n    Args:\n        memory_id: Memory resource ID to delete\n        wait_for_deletion: Whether to wait for complete deletion\n        wait_for_strategies: Whether to wait for strategies to become ACTIVE before deletion\n        max_wait: Maximum seconds to wait if wait_for_deletion is True\n        poll_interval: Seconds between checks if wait_for_deletion is True\n\n    Returns:\n        Deletion response\n    \"\"\"\n    try:\n        # If requested, wait for all strategies to become ACTIVE before deletion\n        if wait_for_strategies:\n            try:\n                memory = self.get_memory(memory_id)\n                strategies = memory.get(\"strategies\", [])\n\n                # Check if any strategies are in a transitional state\n                transitional_strategies = [\n                    s\n                    for s in strategies\n                    if s.get(\"status\") not in [MemoryStatus.ACTIVE.value, MemoryStatus.FAILED.value]\n                ]\n\n                if transitional_strategies:\n                    logger.info(\n                        \"Waiting for %d strategies to become ACTIVE before deletion\", len(transitional_strategies)\n                    )\n                    self._wait_for_status(\n                        memory_id=memory_id,\n                        target_status=MemoryStatus.ACTIVE.value,\n                        max_wait=max_wait,\n                        poll_interval=poll_interval,\n                        check_strategies=True,\n                    )\n            except Exception as e:\n                logger.warning(\"Error waiting for strategies to become ACTIVE: %s\", e)\n\n        # Now delete the memory\n        response = self.client.delete_memory(memoryId=memory_id, clientToken=str(uuid.uuid4()))\n\n        logger.info(\"Initiated deletion of memory: %s\", memory_id)\n\n        if not wait_for_deletion:\n            return response\n\n        # Wait for deletion to complete\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            try:\n                self.client.get_memory(memoryId=memory_id)\n                time.sleep(poll_interval)\n            except ClientError as e:\n                if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                    logger.info(\"Memory %s successfully deleted\", memory_id)\n                    return response\n                raise\n\n        raise TimeoutError(f\"Memory {memory_id} was not deleted within {max_wait} seconds\")\n\n    except ClientError as e:\n        logger.error(\"Failed to delete memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.get_memory","title":"<code>get_memory(memory_id, include_strategies=True)</code>","text":"<p>Get a memory resource by ID.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>include_strategies</code> <code>bool</code> <p>Whether to include strategy details in response</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Memory resource details</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def get_memory(self, memory_id: str, include_strategies: bool = True) -&gt; Dict[str, Any]:\n    \"\"\"Get a memory resource by ID.\n\n    Args:\n        memory_id: Memory resource ID\n        include_strategies: Whether to include strategy details in response\n\n    Returns:\n        Memory resource details\n    \"\"\"\n    try:\n        response = self.client.get_memory(memoryId=memory_id)\n        memory = response[\"memory\"]\n\n        # Add strategy count\n        strategies = memory.get(\"strategies\", [])\n        memory[\"strategyCount\"] = len(strategies)\n\n        # Remove strategies if not requested\n        if not include_strategies and \"strategies\" in memory:\n            del memory[\"strategies\"]\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to get memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.get_strategy","title":"<code>get_strategy(memory_id, strategy_id)</code>","text":"<p>Get a specific strategy from a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Strategy details</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def get_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Get a specific strategy from a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID\n\n    Returns:\n        Strategy details\n    \"\"\"\n    try:\n        memory = self.get_memory(memory_id)\n        strategies = memory.get(\"strategies\", [])\n\n        for strategy in strategies:\n            if strategy.get(\"strategyId\") == strategy_id:\n                return strategy\n\n        raise ValueError(f\"Strategy {strategy_id} not found in memory {memory_id}\")\n\n    except ClientError as e:\n        logger.error(\"Failed to get strategy: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.list_memories","title":"<code>list_memories(max_results=100)</code>","text":"<p>List all memories for the account with pagination support.</p> <p>Parameters:</p> Name Type Description Default <code>max_results</code> <code>int</code> <p>Maximum number of memories to return</p> <code>100</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of memory summaries</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all memories for the account with pagination support.\n\n    Args:\n        max_results: Maximum number of memories to return\n\n    Returns:\n        List of memory summaries\n    \"\"\"\n    try:\n        memories = []\n        next_token = None\n\n        while len(memories) &lt; max_results:\n            params = {\"maxResults\": min(100, max_results - len(memories))}\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.client.list_memories(**params)\n            batch = response.get(\"memories\", [])\n            memories.extend(batch)\n\n            next_token = response.get(\"nextToken\")\n            if not next_token or len(memories) &gt;= max_results:\n                break\n\n        # Add strategy count to each memory summary\n        for memory in memories:\n            memory[\"strategyCount\"] = 0  # List memories doesn't include strategies\n\n        return memories[:max_results]\n\n    except ClientError as e:\n        logger.error(\"Failed to list memories: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.remove_strategy","title":"<code>remove_strategy(memory_id, strategy_id, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Remove a strategy from a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID to remove</p> required <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def remove_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Remove a strategy from a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID to remove\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    # For remove_strategy, we only need to wait for memory to be active\n    # since the strategy will be gone\n    return self.update_memory(\n        memory_id=memory_id,\n        delete_strategy_ids=[strategy_id],\n        wait_for_active=wait_for_active,\n        max_wait=max_wait,\n        poll_interval=poll_interval,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.update_memory","title":"<code>update_memory(memory_id, description=None, event_expiry_days=None, memory_execution_role_arn=None, add_strategies=None, modify_strategies=None, delete_strategy_ids=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Update a memory resource properties and/or strategies.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>description</code> <code>Optional[str]</code> <p>Optional new description</p> <code>None</code> <code>event_expiry_days</code> <code>Optional[int]</code> <p>Optional new event expiry duration</p> <code>None</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>Optional new execution role ARN</p> <code>None</code> <code>add_strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategies to add</p> <code>None</code> <code>modify_strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategies to modify</p> <code>None</code> <code>delete_strategy_ids</code> <code>Optional[List[str]]</code> <p>Optional list of strategy IDs to delete</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def update_memory(\n    self,\n    memory_id: str,\n    description: Optional[str] = None,\n    event_expiry_days: Optional[int] = None,\n    memory_execution_role_arn: Optional[str] = None,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update a memory resource properties and/or strategies.\n\n    Args:\n        memory_id: Memory resource ID\n        description: Optional new description\n        event_expiry_days: Optional new event expiry duration\n        memory_execution_role_arn: Optional new execution role ARN\n        add_strategies: Optional list of strategies to add\n        modify_strategies: Optional list of strategies to modify\n        delete_strategy_ids: Optional list of strategy IDs to delete\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    params: Dict = {\n        \"memoryId\": memory_id,\n        \"clientToken\": str(uuid.uuid4()),\n    }\n\n    # Add memory properties if provided\n    if description is not None:\n        params[\"description\"] = description\n\n    if event_expiry_days is not None:\n        params[\"eventExpiryDuration\"] = event_expiry_days\n\n    if memory_execution_role_arn is not None:\n        params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n    # Add strategy operations if provided\n    memory_strategies = {}\n\n    if add_strategies:\n        memory_strategies[\"addMemoryStrategies\"] = add_strategies\n\n    if modify_strategies:\n        memory_strategies[\"modifyMemoryStrategies\"] = modify_strategies\n\n    if delete_strategy_ids:\n        memory_strategies[\"deleteMemoryStrategies\"] = [\n            {\"memoryStrategyId\": strategy_id} for strategy_id in delete_strategy_ids\n        ]\n\n    if memory_strategies:\n        params[\"memoryStrategies\"] = memory_strategies\n\n    try:\n        response = self.client.update_memory(**params)\n        memory = response[\"memory\"]\n        logger.info(\"Updated memory: %s\", memory_id)\n\n        if wait_for_active:\n            return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to update memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.update_strategy","title":"<code>update_strategy(memory_id, strategy_id, description=None, namespaces=None, configuration=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Update a strategy in a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID to update</p> required <code>description</code> <code>Optional[str]</code> <p>Optional new description</p> <code>None</code> <code>namespaces</code> <code>Optional[List[str]]</code> <p>Optional new namespaces list</p> <code>None</code> <code>configuration</code> <code>Optional[Dict[str, Any]]</code> <p>Optional new configuration</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for strategy to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def update_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    configuration: Optional[Dict[str, Any]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update a strategy in a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID to update\n        description: Optional new description\n        namespaces: Optional new namespaces list\n        configuration: Optional new configuration\n        wait_for_active: Whether to wait for strategy to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    # Note: API expects memoryStrategyId for input but returns strategyId in response\n    modify_config: Dict = {\"memoryStrategyId\": strategy_id}\n\n    if description is not None:\n        modify_config[\"description\"] = description\n\n    if namespaces is not None:\n        modify_config[\"namespaces\"] = namespaces\n\n    if configuration is not None:\n        modify_config[\"configuration\"] = configuration\n\n    # Use update_memory with modify_strategies parameter but don't wait for memory\n    memory = self.update_memory(\n        memory_id=memory_id,\n        modify_strategies=[modify_config],\n        wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n    )\n\n    # If we need to wait for the strategy to become active\n    if wait_for_active:\n        return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n\n    return memory\n</code></pre>"},{"location":"api-reference/runtime.html","title":"Runtime","text":"<p>Runtime management and application context for Bedrock AgentCore.</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime","title":"<code>bedrock_agentcore.runtime</code>","text":"<p>BedrockAgentCore Runtime Package.</p> <p>This package contains the core runtime components for Bedrock AgentCore applications: - BedrockAgentCoreApp: Main application class - RequestContext: HTTP request context - BedrockAgentCoreContext: Agent identity context</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp","title":"<code>BedrockAgentCoreApp</code>","text":"<p>               Bases: <code>Starlette</code></p> <p>Bedrock AgentCore application class that extends Starlette for AI agent deployment.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>class BedrockAgentCoreApp(Starlette):\n    \"\"\"Bedrock AgentCore application class that extends Starlette for AI agent deployment.\"\"\"\n\n    def __init__(self, debug: bool = False):\n        \"\"\"Initialize Bedrock AgentCore application.\n\n        Args:\n            debug: Enable debug actions for task management (default: False)\n        \"\"\"\n        self.handlers: Dict[str, Callable] = {}\n        self._ping_handler: Optional[Callable] = None\n        self._active_tasks: Dict[int, Dict[str, Any]] = {}\n        self._task_counter_lock: threading.Lock = threading.Lock()\n        self._forced_ping_status: Optional[PingStatus] = None\n        self._last_status_update_time: float = time.time()\n\n        routes = [\n            Route(\"/invocations\", self._handle_invocation, methods=[\"POST\"]),\n            Route(\"/ping\", self._handle_ping, methods=[\"GET\"]),\n        ]\n        super().__init__(routes=routes)\n        self.debug = debug  # Set after super().__init__ to avoid override\n\n        self.logger = logging.getLogger(\"bedrock_agentcore.app\")\n        if not self.logger.handlers:\n            handler = logging.StreamHandler()\n            formatter = RequestContextFormatter(\"%(asctime)s - %(name)s - %(levelname)s - %(request_id)s%(message)s\")\n            handler.setFormatter(formatter)\n            self.logger.addHandler(handler)\n            self.logger.setLevel(logging.INFO)\n\n    def entrypoint(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to register a function as the main entrypoint.\n\n        Args:\n            func: The function to register as entrypoint\n\n        Returns:\n            The decorated function with added serve method\n        \"\"\"\n        self.handlers[\"main\"] = func\n        func.run = lambda port=8080, host=None: self.run(port, host)\n        return func\n\n    def ping(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to register a custom ping status handler.\n\n        Args:\n            func: The function to register as ping status handler\n\n        Returns:\n            The decorated function\n        \"\"\"\n        self._ping_handler = func\n        return func\n\n    def async_task(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to track async tasks for ping status.\n\n        When a function is decorated with @async_task, it will:\n        - Set ping status to HEALTHY_BUSY while running\n        - Revert to HEALTHY when complete\n        \"\"\"\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"@async_task can only be applied to async functions\")\n\n        async def wrapper(*args, **kwargs):\n            task_id = self.add_async_task(func.__name__)\n\n            try:\n                self.logger.debug(\"Starting async task: %s\", func.__name__)\n                start_time = time.time()\n                result = await func(*args, **kwargs)\n                duration = time.time() - start_time\n                self.logger.info(\"Async task completed: %s (%.3fs)\", func.__name__, duration)\n                return result\n            except Exception as e:\n                duration = time.time() - start_time\n                self.logger.error(\n                    \"Async task failed: %s (%.3fs) - %s: %s\", func.__name__, duration, type(e).__name__, e\n                )\n                raise\n            finally:\n                self.complete_async_task(task_id)\n\n        wrapper.__name__ = func.__name__\n        return wrapper\n\n    def get_current_ping_status(self) -&gt; PingStatus:\n        \"\"\"Get current ping status (forced &gt; custom &gt; automatic).\"\"\"\n        current_status = None\n\n        if self._forced_ping_status is not None:\n            current_status = self._forced_ping_status\n        elif self._ping_handler:\n            try:\n                result = self._ping_handler()\n                if isinstance(result, str):\n                    current_status = PingStatus(result)\n                else:\n                    current_status = result\n            except Exception as e:\n                self.logger.warning(\n                    \"Custom ping handler failed, falling back to automatic: %s: %s\", type(e).__name__, e\n                )\n\n        if current_status is None:\n            current_status = PingStatus.HEALTHY_BUSY if self._active_tasks else PingStatus.HEALTHY\n        if not hasattr(self, \"_last_known_status\") or self._last_known_status != current_status:\n            self._last_known_status = current_status\n            self._last_status_update_time = time.time()\n\n        return current_status\n\n    def force_ping_status(self, status: PingStatus):\n        \"\"\"Force ping status to a specific value.\"\"\"\n        self._forced_ping_status = status\n\n    def clear_forced_ping_status(self):\n        \"\"\"Clear forced status and resume automatic.\"\"\"\n        self._forced_ping_status = None\n\n    def get_async_task_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Get info about running async tasks.\"\"\"\n        running_jobs = []\n        for t in self._active_tasks.values():\n            try:\n                running_jobs.append(\n                    {\"name\": t.get(\"name\", \"unknown\"), \"duration\": time.time() - t.get(\"start_time\", time.time())}\n                )\n            except Exception as e:\n                self.logger.warning(\"Caught exception, continuing...: %s\", e)\n                continue\n\n        return {\"active_count\": len(self._active_tasks), \"running_jobs\": running_jobs}\n\n    def add_async_task(self, name: str, metadata: Optional[Dict] = None) -&gt; int:\n        \"\"\"Register an async task for interactive health tracking.\n\n        This method provides granular control over async task lifecycle,\n        allowing developers to interactively start tracking tasks for health monitoring.\n        Use this when you need precise control over when tasks begin and end.\n\n        Args:\n            name: Human-readable task name for monitoring\n            metadata: Optional additional task metadata\n\n        Returns:\n            Task ID for tracking and completion\n\n        Example:\n            task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})\n            # ... do background work ...\n            app.complete_async_task(task_id)\n        \"\"\"\n        with self._task_counter_lock:\n            task_id = hash(str(uuid.uuid4()))  # Generate truly unique hash-based ID\n\n            # Register task start with same structure as @async_task decorator\n            task_info = {\"name\": name, \"start_time\": time.time()}\n            if metadata:\n                task_info[\"metadata\"] = metadata\n\n            self._active_tasks[task_id] = task_info\n\n        self.logger.info(\"Async task started: %s (ID: %s)\", name, task_id)\n        return task_id\n\n    def complete_async_task(self, task_id: int) -&gt; bool:\n        \"\"\"Mark an async task as complete for interactive health tracking.\n\n        This method provides granular control over async task lifecycle,\n        allowing developers to interactively complete tasks for health monitoring.\n        Call this when your background work finishes.\n\n        Args:\n            task_id: Task ID returned from add_async_task\n\n        Returns:\n            True if task was found and completed, False otherwise\n\n        Example:\n            task_id = app.add_async_task(\"file_processing\")\n            # ... do background work ...\n            completed = app.complete_async_task(task_id)\n        \"\"\"\n        with self._task_counter_lock:\n            task_info = self._active_tasks.pop(task_id, None)\n            if task_info:\n                task_name = task_info.get(\"name\", \"unknown\")\n                duration = time.time() - task_info.get(\"start_time\", time.time())\n\n                self.logger.info(\"Async task completed: %s (ID: %s, Duration: %.2fs)\", task_name, task_id, duration)\n                return True\n            else:\n                self.logger.warning(\"Attempted to complete unknown task ID: %s\", task_id)\n                return False\n\n    def _build_request_context(self, request) -&gt; RequestContext:\n        \"\"\"Build request context and setup auth if present.\"\"\"\n        try:\n            agent_identity_token = request.headers.get(ACCESS_TOKEN_HEADER) or request.headers.get(\n                ACCESS_TOKEN_HEADER.lower()\n            )\n            if agent_identity_token:\n                BedrockAgentCoreContext.set_workload_access_token(agent_identity_token)\n            session_id = request.headers.get(SESSION_HEADER) or request.headers.get(SESSION_HEADER.lower())\n            return RequestContext(session_id=session_id)\n        except Exception as e:\n            self.logger.warning(\"Failed to build request context: %s: %s\", type(e).__name__, e)\n            return RequestContext(session_id=None)\n\n    def _takes_context(self, handler: Callable) -&gt; bool:\n        try:\n            params = list(inspect.signature(handler).parameters.keys())\n            return len(params) &gt;= 2 and params[1] == \"context\"\n        except Exception:\n            return False\n\n    async def _handle_invocation(self, request):\n        request_id = str(uuid.uuid4())[:8]\n        request_id_context.set(request_id)\n        start_time = time.time()\n\n        try:\n            payload = await request.json()\n            self.logger.debug(\"Processing invocation request\")\n\n            if self.debug:\n                task_response = self._handle_task_action(payload)\n                if task_response:\n                    duration = time.time() - start_time\n                    self.logger.info(\"Debug action completed (%.3fs)\", duration)\n                    return task_response\n\n            handler = self.handlers.get(\"main\")\n            if not handler:\n                self.logger.error(\"No entrypoint defined\")\n                return JSONResponse({\"error\": \"No entrypoint defined\"}, status_code=500)\n\n            request_context = self._build_request_context(request)\n            takes_context = self._takes_context(handler)\n\n            handler_name = handler.__name__ if hasattr(handler, \"__name__\") else \"unknown\"\n            self.logger.debug(\"Invoking handler: %s\", handler_name)\n            result = await self._invoke_handler(handler, request_context, takes_context, payload)\n\n            duration = time.time() - start_time\n            if inspect.isgenerator(result):\n                self.logger.info(\"Returning streaming response (generator) (%.3fs)\", duration)\n                return StreamingResponse(self._sync_stream_with_error_handling(result), media_type=\"text/event-stream\")\n            elif inspect.isasyncgen(result):\n                self.logger.info(\"Returning streaming response (async generator) (%.3fs)\", duration)\n                return StreamingResponse(self._stream_with_error_handling(result), media_type=\"text/event-stream\")\n\n            self.logger.info(\"Invocation completed successfully (%.3fs)\", duration)\n            # Use safe serialization for consistency with streaming paths\n            safe_json_string = self._safe_serialize_to_json_string(result)\n            return Response(safe_json_string, media_type=\"application/json\")\n\n        except json.JSONDecodeError as e:\n            duration = time.time() - start_time\n            self.logger.warning(\"Invalid JSON in request (%.3fs): %s\", duration, e)\n            return JSONResponse({\"error\": \"Invalid JSON\", \"details\": str(e)}, status_code=400)\n        except Exception as e:\n            duration = time.time() - start_time\n            self.logger.exception(\"Invocation failed (%.3fs)\", duration)\n            return JSONResponse({\"error\": str(e)}, status_code=500)\n\n    def _handle_ping(self, request):\n        try:\n            status = self.get_current_ping_status()\n            self.logger.debug(\"Ping request - status: %s\", status.value)\n            return JSONResponse({\"status\": status.value, \"time_of_last_update\": int(self._last_status_update_time)})\n        except Exception as e:\n            self.logger.error(\"Ping endpoint failed: %s: %s\", type(e).__name__, e)\n            return JSONResponse({\"status\": PingStatus.HEALTHY.value, \"time_of_last_update\": int(time.time())})\n\n    def run(self, port: int = 8080, host: Optional[str] = None):\n        \"\"\"Start the Bedrock AgentCore server.\n\n        Args:\n            port: Port to serve on, defaults to 8080\n            host: Host to bind to, auto-detected if None\n        \"\"\"\n        import os\n\n        import uvicorn\n\n        if host is None:\n            if os.path.exists(\"/.dockerenv\") or os.environ.get(\"DOCKER_CONTAINER\"):\n                host = \"0.0.0.0\"  # nosec B104 - Docker needs this to expose the port\n            else:\n                host = \"127.0.0.1\"\n        uvicorn.run(self, host=host, port=port)\n\n    async def _invoke_handler(self, handler, request_context, takes_context, payload):\n        try:\n            args = (payload, request_context) if takes_context else (payload,)\n\n            if asyncio.iscoroutinefunction(handler):\n                return await handler(*args)\n            else:\n                loop = asyncio.get_event_loop()\n                return await loop.run_in_executor(None, handler, *args)\n        except Exception as e:\n            handler_name = getattr(handler, \"__name__\", \"unknown\")\n            self.logger.error(\"Handler '%s' execution failed: %s: %s\", handler_name, type(e).__name__, e)\n            raise\n\n    def _handle_task_action(self, payload: dict) -&gt; Optional[JSONResponse]:\n        \"\"\"Handle task management actions if present in payload.\"\"\"\n        action = payload.get(\"_agent_core_app_action\")\n        if not action:\n            return None\n\n        self.logger.debug(\"Processing debug action: %s\", action)\n\n        try:\n            actions = {\n                TASK_ACTION_PING_STATUS: lambda: JSONResponse(\n                    {\n                        \"status\": self.get_current_ping_status().value,\n                        \"time_of_last_update\": int(self._last_status_update_time),\n                    }\n                ),\n                TASK_ACTION_JOB_STATUS: lambda: JSONResponse(self.get_async_task_info()),\n                TASK_ACTION_FORCE_HEALTHY: lambda: (\n                    self.force_ping_status(PingStatus.HEALTHY),\n                    self.logger.info(\"Ping status forced to Healthy\"),\n                    JSONResponse({\"forced_status\": \"Healthy\"}),\n                )[2],\n                TASK_ACTION_FORCE_BUSY: lambda: (\n                    self.force_ping_status(PingStatus.HEALTHY_BUSY),\n                    self.logger.info(\"Ping status forced to HealthyBusy\"),\n                    JSONResponse({\"forced_status\": \"HealthyBusy\"}),\n                )[2],\n                TASK_ACTION_CLEAR_FORCED_STATUS: lambda: (\n                    self.clear_forced_ping_status(),\n                    self.logger.info(\"Forced ping status cleared\"),\n                    JSONResponse({\"forced_status\": \"Cleared\"}),\n                )[2],\n            }\n\n            if action in actions:\n                response = actions[action]()\n                self.logger.debug(\"Debug action '%s' completed successfully\", action)\n                return response\n\n            self.logger.warning(\"Unknown debug action requested: %s\", action)\n            return JSONResponse({\"error\": f\"Unknown action: {action}\"}, status_code=400)\n\n        except Exception as e:\n            self.logger.error(\"Debug action '%s' failed: %s: %s\", action, type(e).__name__, e)\n            return JSONResponse({\"error\": \"Debug action failed\", \"details\": str(e)}, status_code=500)\n\n    async def _stream_with_error_handling(self, generator):\n        \"\"\"Wrap async generator to handle errors and convert to SSE format.\"\"\"\n        try:\n            async for value in generator:\n                yield self._convert_to_sse(value)\n        except Exception as e:\n            self.logger.error(\"Error in async streaming: %s: %s\", type(e).__name__, e)\n            error_event = {\n                \"error\": str(e),\n                \"error_type\": type(e).__name__,\n                \"message\": \"An error occurred during streaming\",\n            }\n            yield self._convert_to_sse(error_event)\n\n    def _safe_serialize_to_json_string(self, obj):\n        \"\"\"Safely serialize object directly to JSON string with progressive fallback handling.\n\n        This method eliminates double JSON encoding by returning the JSON string directly,\n        avoiding the test-then-encode pattern that leads to redundant json.dumps() calls.\n        Used by both streaming and non-streaming responses for consistent behavior.\n\n        Returns:\n            str: JSON string representation of the object\n        \"\"\"\n        try:\n            # First attempt: direct JSON serialization with Unicode support\n            return json.dumps(obj, ensure_ascii=False)\n        except (TypeError, ValueError, UnicodeEncodeError):\n            try:\n                # Second attempt: convert to string, then JSON encode the string\n                return json.dumps(str(obj), ensure_ascii=False)\n            except Exception as e:\n                # Final fallback: JSON encode error object with ASCII fallback for problematic Unicode\n                self.logger.warning(\"Failed to serialize object: %s: %s\", type(e).__name__, e)\n                error_obj = {\"error\": \"Serialization failed\", \"original_type\": type(obj).__name__}\n                return json.dumps(error_obj, ensure_ascii=False)\n\n    def _convert_to_sse(self, obj) -&gt; bytes:\n        \"\"\"Convert object to Server-Sent Events format using safe serialization.\n\n        Args:\n            obj: Object to convert to SSE format\n\n        Returns:\n            bytes: SSE-formatted data ready for streaming\n        \"\"\"\n        json_string = self._safe_serialize_to_json_string(obj)\n        sse_data = f\"data: {json_string}\\n\\n\"\n        return sse_data.encode(\"utf-8\")\n\n    def _sync_stream_with_error_handling(self, generator):\n        \"\"\"Wrap sync generator to handle errors and convert to SSE format.\"\"\"\n        try:\n            for value in generator:\n                yield self._convert_to_sse(value)\n        except Exception as e:\n            self.logger.error(\"Error in sync streaming: %s: %s\", type(e).__name__, e)\n            error_event = {\n                \"error\": str(e),\n                \"error_type\": type(e).__name__,\n                \"message\": \"An error occurred during streaming\",\n            }\n            yield self._convert_to_sse(error_event)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>Initialize Bedrock AgentCore application.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Enable debug actions for task management (default: False)</p> <code>False</code> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def __init__(self, debug: bool = False):\n    \"\"\"Initialize Bedrock AgentCore application.\n\n    Args:\n        debug: Enable debug actions for task management (default: False)\n    \"\"\"\n    self.handlers: Dict[str, Callable] = {}\n    self._ping_handler: Optional[Callable] = None\n    self._active_tasks: Dict[int, Dict[str, Any]] = {}\n    self._task_counter_lock: threading.Lock = threading.Lock()\n    self._forced_ping_status: Optional[PingStatus] = None\n    self._last_status_update_time: float = time.time()\n\n    routes = [\n        Route(\"/invocations\", self._handle_invocation, methods=[\"POST\"]),\n        Route(\"/ping\", self._handle_ping, methods=[\"GET\"]),\n    ]\n    super().__init__(routes=routes)\n    self.debug = debug  # Set after super().__init__ to avoid override\n\n    self.logger = logging.getLogger(\"bedrock_agentcore.app\")\n    if not self.logger.handlers:\n        handler = logging.StreamHandler()\n        formatter = RequestContextFormatter(\"%(asctime)s - %(name)s - %(levelname)s - %(request_id)s%(message)s\")\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.add_async_task","title":"<code>add_async_task(name, metadata=None)</code>","text":"<p>Register an async task for interactive health tracking.</p> <p>This method provides granular control over async task lifecycle, allowing developers to interactively start tracking tasks for health monitoring. Use this when you need precise control over when tasks begin and end.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable task name for monitoring</p> required <code>metadata</code> <code>Optional[Dict]</code> <p>Optional additional task metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Task ID for tracking and completion</p> Example <p>task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def add_async_task(self, name: str, metadata: Optional[Dict] = None) -&gt; int:\n    \"\"\"Register an async task for interactive health tracking.\n\n    This method provides granular control over async task lifecycle,\n    allowing developers to interactively start tracking tasks for health monitoring.\n    Use this when you need precise control over when tasks begin and end.\n\n    Args:\n        name: Human-readable task name for monitoring\n        metadata: Optional additional task metadata\n\n    Returns:\n        Task ID for tracking and completion\n\n    Example:\n        task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})\n        # ... do background work ...\n        app.complete_async_task(task_id)\n    \"\"\"\n    with self._task_counter_lock:\n        task_id = hash(str(uuid.uuid4()))  # Generate truly unique hash-based ID\n\n        # Register task start with same structure as @async_task decorator\n        task_info = {\"name\": name, \"start_time\": time.time()}\n        if metadata:\n            task_info[\"metadata\"] = metadata\n\n        self._active_tasks[task_id] = task_info\n\n    self.logger.info(\"Async task started: %s (ID: %s)\", name, task_id)\n    return task_id\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.add_async_task--do-background-work","title":"... do background work ...","text":"<p>app.complete_async_task(task_id)</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.async_task","title":"<code>async_task(func)</code>","text":"<p>Decorator to track async tasks for ping status.</p> <p>When a function is decorated with @async_task, it will: - Set ping status to HEALTHY_BUSY while running - Revert to HEALTHY when complete</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def async_task(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to track async tasks for ping status.\n\n    When a function is decorated with @async_task, it will:\n    - Set ping status to HEALTHY_BUSY while running\n    - Revert to HEALTHY when complete\n    \"\"\"\n    if not asyncio.iscoroutinefunction(func):\n        raise ValueError(\"@async_task can only be applied to async functions\")\n\n    async def wrapper(*args, **kwargs):\n        task_id = self.add_async_task(func.__name__)\n\n        try:\n            self.logger.debug(\"Starting async task: %s\", func.__name__)\n            start_time = time.time()\n            result = await func(*args, **kwargs)\n            duration = time.time() - start_time\n            self.logger.info(\"Async task completed: %s (%.3fs)\", func.__name__, duration)\n            return result\n        except Exception as e:\n            duration = time.time() - start_time\n            self.logger.error(\n                \"Async task failed: %s (%.3fs) - %s: %s\", func.__name__, duration, type(e).__name__, e\n            )\n            raise\n        finally:\n            self.complete_async_task(task_id)\n\n    wrapper.__name__ = func.__name__\n    return wrapper\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.clear_forced_ping_status","title":"<code>clear_forced_ping_status()</code>","text":"<p>Clear forced status and resume automatic.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def clear_forced_ping_status(self):\n    \"\"\"Clear forced status and resume automatic.\"\"\"\n    self._forced_ping_status = None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.complete_async_task","title":"<code>complete_async_task(task_id)</code>","text":"<p>Mark an async task as complete for interactive health tracking.</p> <p>This method provides granular control over async task lifecycle, allowing developers to interactively complete tasks for health monitoring. Call this when your background work finishes.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Task ID returned from add_async_task</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if task was found and completed, False otherwise</p> Example <p>task_id = app.add_async_task(\"file_processing\")</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def complete_async_task(self, task_id: int) -&gt; bool:\n    \"\"\"Mark an async task as complete for interactive health tracking.\n\n    This method provides granular control over async task lifecycle,\n    allowing developers to interactively complete tasks for health monitoring.\n    Call this when your background work finishes.\n\n    Args:\n        task_id: Task ID returned from add_async_task\n\n    Returns:\n        True if task was found and completed, False otherwise\n\n    Example:\n        task_id = app.add_async_task(\"file_processing\")\n        # ... do background work ...\n        completed = app.complete_async_task(task_id)\n    \"\"\"\n    with self._task_counter_lock:\n        task_info = self._active_tasks.pop(task_id, None)\n        if task_info:\n            task_name = task_info.get(\"name\", \"unknown\")\n            duration = time.time() - task_info.get(\"start_time\", time.time())\n\n            self.logger.info(\"Async task completed: %s (ID: %s, Duration: %.2fs)\", task_name, task_id, duration)\n            return True\n        else:\n            self.logger.warning(\"Attempted to complete unknown task ID: %s\", task_id)\n            return False\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.complete_async_task--do-background-work","title":"... do background work ...","text":"<p>completed = app.complete_async_task(task_id)</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.entrypoint","title":"<code>entrypoint(func)</code>","text":"<p>Decorator to register a function as the main entrypoint.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to register as entrypoint</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function with added serve method</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def entrypoint(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to register a function as the main entrypoint.\n\n    Args:\n        func: The function to register as entrypoint\n\n    Returns:\n        The decorated function with added serve method\n    \"\"\"\n    self.handlers[\"main\"] = func\n    func.run = lambda port=8080, host=None: self.run(port, host)\n    return func\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.force_ping_status","title":"<code>force_ping_status(status)</code>","text":"<p>Force ping status to a specific value.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def force_ping_status(self, status: PingStatus):\n    \"\"\"Force ping status to a specific value.\"\"\"\n    self._forced_ping_status = status\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.get_async_task_info","title":"<code>get_async_task_info()</code>","text":"<p>Get info about running async tasks.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def get_async_task_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get info about running async tasks.\"\"\"\n    running_jobs = []\n    for t in self._active_tasks.values():\n        try:\n            running_jobs.append(\n                {\"name\": t.get(\"name\", \"unknown\"), \"duration\": time.time() - t.get(\"start_time\", time.time())}\n            )\n        except Exception as e:\n            self.logger.warning(\"Caught exception, continuing...: %s\", e)\n            continue\n\n    return {\"active_count\": len(self._active_tasks), \"running_jobs\": running_jobs}\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.get_current_ping_status","title":"<code>get_current_ping_status()</code>","text":"<p>Get current ping status (forced &gt; custom &gt; automatic).</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def get_current_ping_status(self) -&gt; PingStatus:\n    \"\"\"Get current ping status (forced &gt; custom &gt; automatic).\"\"\"\n    current_status = None\n\n    if self._forced_ping_status is not None:\n        current_status = self._forced_ping_status\n    elif self._ping_handler:\n        try:\n            result = self._ping_handler()\n            if isinstance(result, str):\n                current_status = PingStatus(result)\n            else:\n                current_status = result\n        except Exception as e:\n            self.logger.warning(\n                \"Custom ping handler failed, falling back to automatic: %s: %s\", type(e).__name__, e\n            )\n\n    if current_status is None:\n        current_status = PingStatus.HEALTHY_BUSY if self._active_tasks else PingStatus.HEALTHY\n    if not hasattr(self, \"_last_known_status\") or self._last_known_status != current_status:\n        self._last_known_status = current_status\n        self._last_status_update_time = time.time()\n\n    return current_status\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.ping","title":"<code>ping(func)</code>","text":"<p>Decorator to register a custom ping status handler.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to register as ping status handler</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def ping(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to register a custom ping status handler.\n\n    Args:\n        func: The function to register as ping status handler\n\n    Returns:\n        The decorated function\n    \"\"\"\n    self._ping_handler = func\n    return func\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.run","title":"<code>run(port=8080, host=None)</code>","text":"<p>Start the Bedrock AgentCore server.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to serve on, defaults to 8080</p> <code>8080</code> <code>host</code> <code>Optional[str]</code> <p>Host to bind to, auto-detected if None</p> <code>None</code> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def run(self, port: int = 8080, host: Optional[str] = None):\n    \"\"\"Start the Bedrock AgentCore server.\n\n    Args:\n        port: Port to serve on, defaults to 8080\n        host: Host to bind to, auto-detected if None\n    \"\"\"\n    import os\n\n    import uvicorn\n\n    if host is None:\n        if os.path.exists(\"/.dockerenv\") or os.environ.get(\"DOCKER_CONTAINER\"):\n            host = \"0.0.0.0\"  # nosec B104 - Docker needs this to expose the port\n        else:\n            host = \"127.0.0.1\"\n    uvicorn.run(self, host=host, port=port)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext","title":"<code>BedrockAgentCoreContext</code>","text":"<p>Context manager for Bedrock AgentCore.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>class BedrockAgentCoreContext:\n    \"\"\"Context manager for Bedrock AgentCore.\"\"\"\n\n    _workload_access_token: ContextVar[str] = ContextVar(\"workload_access_token\")\n\n    @classmethod\n    def set_workload_access_token(cls, token: str):\n        \"\"\"Set the workload access token in the context.\"\"\"\n        cls._workload_access_token.set(token)\n\n    @classmethod\n    def get_workload_access_token(cls) -&gt; Optional[str]:\n        \"\"\"Get the workload access token from the context.\"\"\"\n        try:\n            return cls._workload_access_token.get()\n        except LookupError:\n            return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.get_workload_access_token","title":"<code>get_workload_access_token()</code>  <code>classmethod</code>","text":"<p>Get the workload access token from the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef get_workload_access_token(cls) -&gt; Optional[str]:\n    \"\"\"Get the workload access token from the context.\"\"\"\n    try:\n        return cls._workload_access_token.get()\n    except LookupError:\n        return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.set_workload_access_token","title":"<code>set_workload_access_token(token)</code>  <code>classmethod</code>","text":"<p>Set the workload access token in the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef set_workload_access_token(cls, token: str):\n    \"\"\"Set the workload access token in the context.\"\"\"\n    cls._workload_access_token.set(token)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.PingStatus","title":"<code>PingStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Ping status enum for health check responses.</p> Source code in <code>bedrock_agentcore/runtime/models.py</code> <pre><code>class PingStatus(str, Enum):\n    \"\"\"Ping status enum for health check responses.\"\"\"\n\n    HEALTHY = \"Healthy\"\n    HEALTHY_BUSY = \"HealthyBusy\"\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.RequestContext","title":"<code>RequestContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request context containing metadata from HTTP requests.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>class RequestContext(BaseModel):\n    \"\"\"Request context containing metadata from HTTP requests.\"\"\"\n\n    session_id: Optional[str] = Field(None)\n</code></pre>"},{"location":"api-reference/tools.html","title":"Tools","text":"<p>Tools and utilities for Bedrock AgentCore SDK including browser and code interpreter tools.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client","title":"<code>bedrock_agentcore.tools.code_interpreter_client</code>","text":"<p>Client for interacting with the Code Interpreter sandbox service.</p> <p>This module provides a client for the AWS Code Interpreter sandbox, allowing applications to start, stop, and invoke code execution in a managed sandbox environment.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter","title":"<code>CodeInterpreter</code>","text":"<p>Client for interacting with the AWS Code Interpreter sandbox service.</p> <p>This client handles the session lifecycle and method invocation for Code Interpreter sandboxes, providing an interface to execute code in a secure, managed environment.</p> <p>Attributes:</p> Name Type Description <code>data_plane_service_name</code> <code>str</code> <p>AWS service name for the data plane.</p> <code>client</code> <p>The boto3 client for interacting with the service.</p> <code>identifier</code> <code>str</code> <p>The code interpreter identifier.</p> <code>session_id</code> <code>str</code> <p>The active session ID.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>class CodeInterpreter:\n    \"\"\"Client for interacting with the AWS Code Interpreter sandbox service.\n\n    This client handles the session lifecycle and method invocation for\n    Code Interpreter sandboxes, providing an interface to execute code\n    in a secure, managed environment.\n\n    Attributes:\n        data_plane_service_name (str): AWS service name for the data plane.\n        client: The boto3 client for interacting with the service.\n        identifier (str, optional): The code interpreter identifier.\n        session_id (str, optional): The active session ID.\n    \"\"\"\n\n    def __init__(self, region: str) -&gt; None:\n        \"\"\"Initialize a Code Interpreter client for the specified AWS region.\n\n        Args:\n            region (str): The AWS region to use for the Code Interpreter service.\n        \"\"\"\n        self.data_plane_service_name = \"bedrock-agentcore\"\n        self.client = boto3.client(\n            self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self._identifier = None\n        self._session_id = None\n\n    @property\n    def identifier(self) -&gt; Optional[str]:\n        \"\"\"Get the current code interpreter identifier.\n\n        Returns:\n            Optional[str]: The current identifier or None if not set.\n        \"\"\"\n        return self._identifier\n\n    @identifier.setter\n    def identifier(self, value: Optional[str]):\n        \"\"\"Set the code interpreter identifier.\n\n        Args:\n            value (Optional[str]): The identifier to set.\n        \"\"\"\n        self._identifier = value\n\n    @property\n    def session_id(self) -&gt; Optional[str]:\n        \"\"\"Get the current session ID.\n\n        Returns:\n            Optional[str]: The current session ID or None if not set.\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, value: Optional[str]):\n        \"\"\"Set the session ID.\n\n        Args:\n            value (Optional[str]): The session ID to set.\n        \"\"\"\n        self._session_id = value\n\n    def start(\n        self,\n        identifier: Optional[str] = DEFAULT_IDENTIFIER,\n        name: Optional[str] = None,\n        session_timeout_seconds: Optional[int] = DEFAULT_TIMEOUT,\n    ) -&gt; str:\n        \"\"\"Start a code interpreter sandbox session.\n\n        This method initializes a new code interpreter session with the provided parameters.\n\n        Args:\n            identifier (Optional[str]): The code interpreter sandbox identifier to use.\n                Defaults to DEFAULT_IDENTIFIER.\n            name (Optional[str]): A name for this session. If not provided, a name\n                will be generated using a UUID.\n            session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n                Defaults to DEFAULT_TIMEOUT.\n            description (Optional[str]): A description for this session.\n                Defaults to an empty string.\n\n        Returns:\n            str: The session ID of the newly created session.\n        \"\"\"\n        response = self.client.start_code_interpreter_session(\n            codeInterpreterIdentifier=identifier,\n            name=name or f\"code-session-{uuid.uuid4().hex[:8]}\",\n            sessionTimeoutSeconds=session_timeout_seconds,\n        )\n\n        self.identifier = response[\"codeInterpreterIdentifier\"]\n        self.session_id = response[\"sessionId\"]\n\n        return self.session_id\n\n    def stop(self):\n        \"\"\"Stop the current code interpreter session if one is active.\n\n        This method stops any active session and clears the session state.\n        If no session is active, this method does nothing.\n\n        Returns:\n            bool: True if no session was active or the session was successfully stopped.\n        \"\"\"\n        if not self.session_id or not self.identifier:\n            return True\n\n        self.client.stop_code_interpreter_session(\n            **{\"codeInterpreterIdentifier\": self.identifier, \"sessionId\": self.session_id}\n        )\n\n        self.identifier = None\n        self.session_id = None\n\n    def invoke(self, method: str, params: Optional[Dict] = None):\n        \"\"\"Invoke a method in the code interpreter sandbox.\n\n        If no session is active, this method automatically starts a new session\n        before invoking the requested method.\n\n        Args:\n            method (str): The name of the method to invoke in the sandbox.\n            params (Optional[Dict]): Parameters to pass to the method. Defaults to None.\n            request_id (Optional[str]): A custom request ID. If not provided, a unique ID is generated.\n\n        Returns:\n            dict: The response from the code interpreter service.\n        \"\"\"\n        if not self.session_id or not self.identifier:\n            self.start()\n\n        return self.client.invoke_code_interpreter(\n            **{\n                \"codeInterpreterIdentifier\": self.identifier,\n                \"sessionId\": self.session_id,\n                \"name\": method,\n                \"arguments\": params or {},\n            }\n        )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.identifier","title":"<code>identifier</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current code interpreter identifier.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current identifier or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.session_id","title":"<code>session_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current session ID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current session ID or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize a Code Interpreter client for the specified AWS region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Code Interpreter service.</p> required Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def __init__(self, region: str) -&gt; None:\n    \"\"\"Initialize a Code Interpreter client for the specified AWS region.\n\n    Args:\n        region (str): The AWS region to use for the Code Interpreter service.\n    \"\"\"\n    self.data_plane_service_name = \"bedrock-agentcore\"\n    self.client = boto3.client(\n        self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self._identifier = None\n    self._session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.invoke","title":"<code>invoke(method, params=None)</code>","text":"<p>Invoke a method in the code interpreter sandbox.</p> <p>If no session is active, this method automatically starts a new session before invoking the requested method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The name of the method to invoke in the sandbox.</p> required <code>params</code> <code>Optional[Dict]</code> <p>Parameters to pass to the method. Defaults to None.</p> <code>None</code> <code>request_id</code> <code>Optional[str]</code> <p>A custom request ID. If not provided, a unique ID is generated.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the code interpreter service.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def invoke(self, method: str, params: Optional[Dict] = None):\n    \"\"\"Invoke a method in the code interpreter sandbox.\n\n    If no session is active, this method automatically starts a new session\n    before invoking the requested method.\n\n    Args:\n        method (str): The name of the method to invoke in the sandbox.\n        params (Optional[Dict]): Parameters to pass to the method. Defaults to None.\n        request_id (Optional[str]): A custom request ID. If not provided, a unique ID is generated.\n\n    Returns:\n        dict: The response from the code interpreter service.\n    \"\"\"\n    if not self.session_id or not self.identifier:\n        self.start()\n\n    return self.client.invoke_code_interpreter(\n        **{\n            \"codeInterpreterIdentifier\": self.identifier,\n            \"sessionId\": self.session_id,\n            \"name\": method,\n            \"arguments\": params or {},\n        }\n    )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.start","title":"<code>start(identifier=DEFAULT_IDENTIFIER, name=None, session_timeout_seconds=DEFAULT_TIMEOUT)</code>","text":"<p>Start a code interpreter sandbox session.</p> <p>This method initializes a new code interpreter session with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Optional[str]</code> <p>The code interpreter sandbox identifier to use. Defaults to DEFAULT_IDENTIFIER.</p> <code>DEFAULT_IDENTIFIER</code> <code>name</code> <code>Optional[str]</code> <p>A name for this session. If not provided, a name will be generated using a UUID.</p> <code>None</code> <code>session_timeout_seconds</code> <code>Optional[int]</code> <p>The timeout for the session in seconds. Defaults to DEFAULT_TIMEOUT.</p> <code>DEFAULT_TIMEOUT</code> <code>description</code> <code>Optional[str]</code> <p>A description for this session. Defaults to an empty string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session ID of the newly created session.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def start(\n    self,\n    identifier: Optional[str] = DEFAULT_IDENTIFIER,\n    name: Optional[str] = None,\n    session_timeout_seconds: Optional[int] = DEFAULT_TIMEOUT,\n) -&gt; str:\n    \"\"\"Start a code interpreter sandbox session.\n\n    This method initializes a new code interpreter session with the provided parameters.\n\n    Args:\n        identifier (Optional[str]): The code interpreter sandbox identifier to use.\n            Defaults to DEFAULT_IDENTIFIER.\n        name (Optional[str]): A name for this session. If not provided, a name\n            will be generated using a UUID.\n        session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n            Defaults to DEFAULT_TIMEOUT.\n        description (Optional[str]): A description for this session.\n            Defaults to an empty string.\n\n    Returns:\n        str: The session ID of the newly created session.\n    \"\"\"\n    response = self.client.start_code_interpreter_session(\n        codeInterpreterIdentifier=identifier,\n        name=name or f\"code-session-{uuid.uuid4().hex[:8]}\",\n        sessionTimeoutSeconds=session_timeout_seconds,\n    )\n\n    self.identifier = response[\"codeInterpreterIdentifier\"]\n    self.session_id = response[\"sessionId\"]\n\n    return self.session_id\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.stop","title":"<code>stop()</code>","text":"<p>Stop the current code interpreter session if one is active.</p> <p>This method stops any active session and clears the session state. If no session is active, this method does nothing.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if no session was active or the session was successfully stopped.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the current code interpreter session if one is active.\n\n    This method stops any active session and clears the session state.\n    If no session is active, this method does nothing.\n\n    Returns:\n        bool: True if no session was active or the session was successfully stopped.\n    \"\"\"\n    if not self.session_id or not self.identifier:\n        return True\n\n    self.client.stop_code_interpreter_session(\n        **{\"codeInterpreterIdentifier\": self.identifier, \"sessionId\": self.session_id}\n    )\n\n    self.identifier = None\n    self.session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.code_session","title":"<code>code_session(region)</code>","text":"<p>Context manager for creating and managing a code interpreter session.</p> <p>This context manager handles creating a client, starting a session, and ensuring the session is properly cleaned up when the context exits.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Code Interpreter service.</p> required <p>Yields:</p> Name Type Description <code>CodeInterpreterClient</code> <code>CodeInterpreter</code> <p>An initialized and started code interpreter client.</p> Example <p>with code_session('us-west-2') as client: ...     result = client.invoke('listFiles') ...     # Process result here</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>@contextmanager\ndef code_session(region: str) -&gt; Generator[CodeInterpreter, None, None]:\n    \"\"\"Context manager for creating and managing a code interpreter session.\n\n    This context manager handles creating a client, starting a session, and\n    ensuring the session is properly cleaned up when the context exits.\n\n    Args:\n        region (str): The AWS region to use for the Code Interpreter service.\n\n    Yields:\n        CodeInterpreterClient: An initialized and started code interpreter client.\n\n    Example:\n        &gt;&gt;&gt; with code_session('us-west-2') as client:\n        ...     result = client.invoke('listFiles')\n        ...     # Process result here\n    \"\"\"\n    client = CodeInterpreter(region)\n    client.start()\n\n    try:\n        yield client\n    finally:\n        client.stop()\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client","title":"<code>bedrock_agentcore.tools.browser_client</code>","text":"<p>Client for interacting with the Browser sandbox service.</p> <p>This module provides a client for the AWS Browser sandbox, allowing applications to start, stop, and automate browser interactions in a managed sandbox environment using Playwright.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient","title":"<code>BrowserClient</code>","text":"<p>Client for interacting with the AWS Browser sandbox service.</p> <p>This client handles the session lifecycle and browser automation for Browser sandboxes, providing an interface to perform web automation tasks in a secure, managed environment.</p> <p>Attributes:</p> Name Type Description <code>region</code> <code>str</code> <p>The AWS region being used.</p> <code>data_plane_service_name</code> <code>str</code> <p>AWS service name for the data plane.</p> <code>client</code> <p>The boto3 client for interacting with the service.</p> <code>identifier</code> <code>str</code> <p>The browser identifier.</p> <code>session_id</code> <code>str</code> <p>The active session ID.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>class BrowserClient:\n    \"\"\"Client for interacting with the AWS Browser sandbox service.\n\n    This client handles the session lifecycle and browser automation for\n    Browser sandboxes, providing an interface to perform web automation\n    tasks in a secure, managed environment.\n\n    Attributes:\n        region (str): The AWS region being used.\n        data_plane_service_name (str): AWS service name for the data plane.\n        client: The boto3 client for interacting with the service.\n        identifier (str, optional): The browser identifier.\n        session_id (str, optional): The active session ID.\n    \"\"\"\n\n    def __init__(self, region: str) -&gt; None:\n        \"\"\"Initialize a Browser client for the specified AWS region.\n\n        Args:\n            region (str): The AWS region to use for the Browser service.\n        \"\"\"\n        self.region = region\n        self.data_plane_service_name = \"bedrock-agentcore\"\n        self.client = boto3.client(\n            self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self._identifier = None\n        self._session_id = None\n        self.logger = logging.getLogger(__name__)\n\n    @property\n    def identifier(self) -&gt; Optional[str]:\n        \"\"\"Get the current browser identifier.\n\n        Returns:\n            Optional[str]: The current identifier or None if not set.\n        \"\"\"\n        return self._identifier\n\n    @identifier.setter\n    def identifier(self, value: Optional[str]):\n        \"\"\"Set the browser identifier.\n\n        Args:\n            value (Optional[str]): The identifier to set.\n        \"\"\"\n        self._identifier = value\n\n    @property\n    def session_id(self) -&gt; Optional[str]:\n        \"\"\"Get the current session ID.\n\n        Returns:\n            Optional[str]: The current session ID or None if not set.\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, value: Optional[str]):\n        \"\"\"Set the session ID.\n\n        Args:\n            value (Optional[str]): The session ID to set.\n        \"\"\"\n        self._session_id = value\n\n    def start(\n        self,\n        identifier: Optional[str] = DEFAULT_IDENTIFIER,\n        name: Optional[str] = None,\n        session_timeout_seconds: Optional[int] = DEFAULT_SESSION_TIMEOUT,\n    ) -&gt; str:\n        \"\"\"Start a browser sandbox session.\n\n        This method initializes a new browser session with the provided parameters.\n\n        Args:\n            identifier (Optional[str]): The browser sandbox identifier to use.\n                Defaults to DEFAULT_IDENTIFIER.\n            name (Optional[str]): A name for this session. If not provided, a name\n                will be generated using a UUID.\n            session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n                Defaults to DEFAULT_TIMEOUT.\n            description (Optional[str]): A description for this session.\n                Defaults to an empty string.\n\n        Returns:\n            str: The session ID of the newly created session.\n        \"\"\"\n        self.logger.info(\"Starting browser session...\")\n\n        response = self.client.start_browser_session(\n            browserIdentifier=identifier,\n            name=name or f\"browser-session-{uuid.uuid4().hex[:8]}\",\n            sessionTimeoutSeconds=session_timeout_seconds,\n        )\n\n        self.identifier = response[\"browserIdentifier\"]\n        self.session_id = response[\"sessionId\"]\n\n        return self.session_id\n\n    def stop(self):\n        \"\"\"Stop the current browser session if one is active.\n\n        This method stops any active session and clears the session state.\n        If no session is active, this method does nothing.\n\n        Returns:\n            bool: True if no session was active or the session was successfully stopped.\n        \"\"\"\n        self.logger.info(\"Stopping browser session...\")\n\n        if not self.session_id or not self.identifier:\n            return True\n\n        self.client.stop_browser_session(**{\"browserIdentifier\": self.identifier, \"sessionId\": self.session_id})\n\n        self.identifier = None\n        self.session_id = None\n\n    def generate_ws_headers(self) -&gt; Tuple[str, Dict[str, str]]:\n        \"\"\"Generate the WebSocket headers needed for connecting to the browser sandbox.\n\n        This method creates properly signed WebSocket headers for connecting to\n        the browser automation endpoint.\n\n        Returns:\n            Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and\n                the headers dictionary.\n\n        Raises:\n            RuntimeError: If no AWS credentials are found.\n        \"\"\"\n        self.logger.info(\"Generating websocket headers...\")\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        host = get_data_plane_endpoint(self.region).replace(\"https://\", \"\")\n        path = f\"/browser-streams/{self.identifier}/sessions/{self.session_id}/automation\"\n        ws_url = f\"wss://{host}{path}\"\n\n        boto_session = boto3.Session()\n        credentials = boto_session.get_credentials()\n        if not credentials:\n            raise RuntimeError(\"No AWS credentials found\")\n\n        frozen_credentials = credentials.get_frozen_credentials()\n\n        request = AWSRequest(\n            method=\"GET\",\n            url=f\"https://{host}{path}\",\n            headers={\n                \"host\": host,\n                \"x-amz-date\": datetime.datetime.now(datetime.timezone.utc).strftime(\"%Y%m%dT%H%M%SZ\"),\n            },\n        )\n\n        auth = SigV4Auth(frozen_credentials, self.data_plane_service_name, self.region)\n        auth.add_auth(request)\n\n        headers = {\n            \"Host\": host,\n            \"X-Amz-Date\": request.headers[\"x-amz-date\"],\n            \"Authorization\": request.headers[\"Authorization\"],\n            \"Upgrade\": \"websocket\",\n            \"Connection\": \"Upgrade\",\n            \"Sec-WebSocket-Version\": \"13\",\n            \"Sec-WebSocket-Key\": base64.b64encode(secrets.token_bytes(16)).decode(),\n            \"User-Agent\": f\"BrowserSandbox-Client/1.0 (Session: {self.session_id})\",\n        }\n\n        if frozen_credentials.token:\n            headers[\"X-Amz-Security-Token\"] = frozen_credentials.token\n\n        return ws_url, headers\n\n    def generate_live_view_url(self, expires: int = DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT) -&gt; str:\n        \"\"\"Generate a pre-signed URL for viewing the browser session.\n\n        Creates a pre-signed URL that can be used to view the current browser session.\n        If no session is active, a new session will be started.\n\n        Args:\n            expires (int, optional): The number of seconds until the pre-signed URL expires.\n                Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds).\n                Maximum allowed value is MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n\n        Returns:\n            str: The pre-signed URL for viewing the browser session.\n\n        Raises:\n            ValueError: If expires exceeds MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n            RuntimeError: If the URL generation fails.\n        \"\"\"\n        self.logger.info(\"Generating live view url...\")\n\n        if expires &gt; MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT:\n            raise ValueError(\n                f\"Expiry timeout cannot exceed {MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT} seconds, got {expires}\"\n            )\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        url = urlparse(\n            f\"{get_data_plane_endpoint(self.region)}/browser-streams/{self.identifier}/sessions/{self.session_id}/live-view\"\n        )\n        boto_session = boto3.Session()\n        credentials = boto_session.get_credentials().get_frozen_credentials()\n        request = AWSRequest(method=\"GET\", url=url.geturl(), headers={\"host\": url.hostname})\n        signer = SigV4QueryAuth(\n            credentials=credentials, service_name=self.data_plane_service_name, region_name=self.region, expires=expires\n        )\n        signer.add_auth(request)\n\n        if not request.url:\n            raise RuntimeError(\"Failed to generate live view url\")\n\n        return request.url\n\n    def take_control(self):\n        \"\"\"Take control of the browser session by disabling the automation stream.\n\n        This method disables external automation capabilities of the browser session,\n        giving this client exclusive control. If no session is active, a new session\n        will be started.\n\n        Raises:\n            RuntimeError: If a session could not be found or started.\n        \"\"\"\n        self.logger.info(\"Taking control of browser session...\")\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        if not self.identifier or not self.session_id:\n            raise RuntimeError(\"Could not find or start a browser session\")\n\n        self._update_browser_stream(self.identifier, self.session_id, \"DISABLED\")\n\n    def release_control(self):\n        \"\"\"Release control of the browser session by enabling the automation stream.\n\n        This method enables external automation capabilities of the browser session,\n        relinquishing exclusive control. If no session exists, a warning is logged\n        and the method returns without taking action.\n        \"\"\"\n        self.logger.info(\"Releasing control of browser session...\")\n\n        if not self.identifier or not self.session_id:\n            self.logger.warning(\"Could not find a browser session when releasing control\")\n            return\n\n        self._update_browser_stream(self.identifier, self.session_id, \"ENABLED\")\n\n    def _update_browser_stream(self, identifier: str, session_id: str, stream_status: str) -&gt; None:\n        \"\"\"Update the browser stream status.\n\n        This private helper method updates the status of the browser automation stream.\n\n        Args:\n            identifier (str): The browser identifier.\n            session_id (str): The session ID.\n            stream_status (str): The status to set for the automation stream.\n                Valid values are \"ENABLED\" or \"DISABLED\".\n        \"\"\"\n        self.client.update_browser_stream(\n            **{\n                \"browserIdentifier\": identifier,\n                \"sessionId\": session_id,\n                \"streamUpdate\": {\"automationStreamUpdate\": {\"streamStatus\": stream_status}},\n            }\n        )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.identifier","title":"<code>identifier</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current browser identifier.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current identifier or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.session_id","title":"<code>session_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current session ID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current session ID or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize a Browser client for the specified AWS region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Browser service.</p> required Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def __init__(self, region: str) -&gt; None:\n    \"\"\"Initialize a Browser client for the specified AWS region.\n\n    Args:\n        region (str): The AWS region to use for the Browser service.\n    \"\"\"\n    self.region = region\n    self.data_plane_service_name = \"bedrock-agentcore\"\n    self.client = boto3.client(\n        self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self._identifier = None\n    self._session_id = None\n    self.logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.generate_live_view_url","title":"<code>generate_live_view_url(expires=DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT)</code>","text":"<p>Generate a pre-signed URL for viewing the browser session.</p> <p>Creates a pre-signed URL that can be used to view the current browser session. If no session is active, a new session will be started.</p> <p>Parameters:</p> Name Type Description Default <code>expires</code> <code>int</code> <p>The number of seconds until the pre-signed URL expires. Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds). Maximum allowed value is MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.</p> <code>DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The pre-signed URL for viewing the browser session.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If expires exceeds MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.</p> <code>RuntimeError</code> <p>If the URL generation fails.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def generate_live_view_url(self, expires: int = DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT) -&gt; str:\n    \"\"\"Generate a pre-signed URL for viewing the browser session.\n\n    Creates a pre-signed URL that can be used to view the current browser session.\n    If no session is active, a new session will be started.\n\n    Args:\n        expires (int, optional): The number of seconds until the pre-signed URL expires.\n            Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds).\n            Maximum allowed value is MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n\n    Returns:\n        str: The pre-signed URL for viewing the browser session.\n\n    Raises:\n        ValueError: If expires exceeds MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n        RuntimeError: If the URL generation fails.\n    \"\"\"\n    self.logger.info(\"Generating live view url...\")\n\n    if expires &gt; MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT:\n        raise ValueError(\n            f\"Expiry timeout cannot exceed {MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT} seconds, got {expires}\"\n        )\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    url = urlparse(\n        f\"{get_data_plane_endpoint(self.region)}/browser-streams/{self.identifier}/sessions/{self.session_id}/live-view\"\n    )\n    boto_session = boto3.Session()\n    credentials = boto_session.get_credentials().get_frozen_credentials()\n    request = AWSRequest(method=\"GET\", url=url.geturl(), headers={\"host\": url.hostname})\n    signer = SigV4QueryAuth(\n        credentials=credentials, service_name=self.data_plane_service_name, region_name=self.region, expires=expires\n    )\n    signer.add_auth(request)\n\n    if not request.url:\n        raise RuntimeError(\"Failed to generate live view url\")\n\n    return request.url\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.generate_ws_headers","title":"<code>generate_ws_headers()</code>","text":"<p>Generate the WebSocket headers needed for connecting to the browser sandbox.</p> <p>This method creates properly signed WebSocket headers for connecting to the browser automation endpoint.</p> <p>Returns:</p> Type Description <code>Tuple[str, Dict[str, str]]</code> <p>Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and the headers dictionary.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no AWS credentials are found.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def generate_ws_headers(self) -&gt; Tuple[str, Dict[str, str]]:\n    \"\"\"Generate the WebSocket headers needed for connecting to the browser sandbox.\n\n    This method creates properly signed WebSocket headers for connecting to\n    the browser automation endpoint.\n\n    Returns:\n        Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and\n            the headers dictionary.\n\n    Raises:\n        RuntimeError: If no AWS credentials are found.\n    \"\"\"\n    self.logger.info(\"Generating websocket headers...\")\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    host = get_data_plane_endpoint(self.region).replace(\"https://\", \"\")\n    path = f\"/browser-streams/{self.identifier}/sessions/{self.session_id}/automation\"\n    ws_url = f\"wss://{host}{path}\"\n\n    boto_session = boto3.Session()\n    credentials = boto_session.get_credentials()\n    if not credentials:\n        raise RuntimeError(\"No AWS credentials found\")\n\n    frozen_credentials = credentials.get_frozen_credentials()\n\n    request = AWSRequest(\n        method=\"GET\",\n        url=f\"https://{host}{path}\",\n        headers={\n            \"host\": host,\n            \"x-amz-date\": datetime.datetime.now(datetime.timezone.utc).strftime(\"%Y%m%dT%H%M%SZ\"),\n        },\n    )\n\n    auth = SigV4Auth(frozen_credentials, self.data_plane_service_name, self.region)\n    auth.add_auth(request)\n\n    headers = {\n        \"Host\": host,\n        \"X-Amz-Date\": request.headers[\"x-amz-date\"],\n        \"Authorization\": request.headers[\"Authorization\"],\n        \"Upgrade\": \"websocket\",\n        \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Version\": \"13\",\n        \"Sec-WebSocket-Key\": base64.b64encode(secrets.token_bytes(16)).decode(),\n        \"User-Agent\": f\"BrowserSandbox-Client/1.0 (Session: {self.session_id})\",\n    }\n\n    if frozen_credentials.token:\n        headers[\"X-Amz-Security-Token\"] = frozen_credentials.token\n\n    return ws_url, headers\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.release_control","title":"<code>release_control()</code>","text":"<p>Release control of the browser session by enabling the automation stream.</p> <p>This method enables external automation capabilities of the browser session, relinquishing exclusive control. If no session exists, a warning is logged and the method returns without taking action.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def release_control(self):\n    \"\"\"Release control of the browser session by enabling the automation stream.\n\n    This method enables external automation capabilities of the browser session,\n    relinquishing exclusive control. If no session exists, a warning is logged\n    and the method returns without taking action.\n    \"\"\"\n    self.logger.info(\"Releasing control of browser session...\")\n\n    if not self.identifier or not self.session_id:\n        self.logger.warning(\"Could not find a browser session when releasing control\")\n        return\n\n    self._update_browser_stream(self.identifier, self.session_id, \"ENABLED\")\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.start","title":"<code>start(identifier=DEFAULT_IDENTIFIER, name=None, session_timeout_seconds=DEFAULT_SESSION_TIMEOUT)</code>","text":"<p>Start a browser sandbox session.</p> <p>This method initializes a new browser session with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Optional[str]</code> <p>The browser sandbox identifier to use. Defaults to DEFAULT_IDENTIFIER.</p> <code>DEFAULT_IDENTIFIER</code> <code>name</code> <code>Optional[str]</code> <p>A name for this session. If not provided, a name will be generated using a UUID.</p> <code>None</code> <code>session_timeout_seconds</code> <code>Optional[int]</code> <p>The timeout for the session in seconds. Defaults to DEFAULT_TIMEOUT.</p> <code>DEFAULT_SESSION_TIMEOUT</code> <code>description</code> <code>Optional[str]</code> <p>A description for this session. Defaults to an empty string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session ID of the newly created session.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def start(\n    self,\n    identifier: Optional[str] = DEFAULT_IDENTIFIER,\n    name: Optional[str] = None,\n    session_timeout_seconds: Optional[int] = DEFAULT_SESSION_TIMEOUT,\n) -&gt; str:\n    \"\"\"Start a browser sandbox session.\n\n    This method initializes a new browser session with the provided parameters.\n\n    Args:\n        identifier (Optional[str]): The browser sandbox identifier to use.\n            Defaults to DEFAULT_IDENTIFIER.\n        name (Optional[str]): A name for this session. If not provided, a name\n            will be generated using a UUID.\n        session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n            Defaults to DEFAULT_TIMEOUT.\n        description (Optional[str]): A description for this session.\n            Defaults to an empty string.\n\n    Returns:\n        str: The session ID of the newly created session.\n    \"\"\"\n    self.logger.info(\"Starting browser session...\")\n\n    response = self.client.start_browser_session(\n        browserIdentifier=identifier,\n        name=name or f\"browser-session-{uuid.uuid4().hex[:8]}\",\n        sessionTimeoutSeconds=session_timeout_seconds,\n    )\n\n    self.identifier = response[\"browserIdentifier\"]\n    self.session_id = response[\"sessionId\"]\n\n    return self.session_id\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.stop","title":"<code>stop()</code>","text":"<p>Stop the current browser session if one is active.</p> <p>This method stops any active session and clears the session state. If no session is active, this method does nothing.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if no session was active or the session was successfully stopped.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the current browser session if one is active.\n\n    This method stops any active session and clears the session state.\n    If no session is active, this method does nothing.\n\n    Returns:\n        bool: True if no session was active or the session was successfully stopped.\n    \"\"\"\n    self.logger.info(\"Stopping browser session...\")\n\n    if not self.session_id or not self.identifier:\n        return True\n\n    self.client.stop_browser_session(**{\"browserIdentifier\": self.identifier, \"sessionId\": self.session_id})\n\n    self.identifier = None\n    self.session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.take_control","title":"<code>take_control()</code>","text":"<p>Take control of the browser session by disabling the automation stream.</p> <p>This method disables external automation capabilities of the browser session, giving this client exclusive control. If no session is active, a new session will be started.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a session could not be found or started.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def take_control(self):\n    \"\"\"Take control of the browser session by disabling the automation stream.\n\n    This method disables external automation capabilities of the browser session,\n    giving this client exclusive control. If no session is active, a new session\n    will be started.\n\n    Raises:\n        RuntimeError: If a session could not be found or started.\n    \"\"\"\n    self.logger.info(\"Taking control of browser session...\")\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    if not self.identifier or not self.session_id:\n        raise RuntimeError(\"Could not find or start a browser session\")\n\n    self._update_browser_stream(self.identifier, self.session_id, \"DISABLED\")\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.browser_session","title":"<code>browser_session(region)</code>","text":"<p>Context manager for creating and managing a browser sandbox session.</p> <p>This context manager handles creating a client, starting a session, and ensuring the session is properly cleaned up when the context exits.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Browser service.</p> required <p>Yields:</p> Name Type Description <code>BrowserClient</code> <code>BrowserClient</code> <p>An initialized and started browser client.</p> Example <p>with browser_session('us-west-2') as client: ...     browser = client.get_browser_obj() ...     page = browser.new_page() ...     page.goto('https://example.com')</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>@contextmanager\ndef browser_session(region: str) -&gt; Generator[BrowserClient, None, None]:\n    \"\"\"Context manager for creating and managing a browser sandbox session.\n\n    This context manager handles creating a client, starting a session, and\n    ensuring the session is properly cleaned up when the context exits.\n\n    Args:\n        region (str): The AWS region to use for the Browser service.\n\n    Yields:\n        BrowserClient: An initialized and started browser client.\n\n    Example:\n        &gt;&gt;&gt; with browser_session('us-west-2') as client:\n        ...     browser = client.get_browser_obj()\n        ...     page = browser.new_page()\n        ...     page.goto('https://example.com')\n    \"\"\"\n    client = BrowserClient(region)\n    client.start()\n\n    try:\n        yield client\n    finally:\n        client.stop()\n</code></pre>"},{"location":"examples/index.html","title":"Examples","text":"<p>These simple examples demonstrate key Amazon Bedrock AgentCore concepts and patterns. Each example focuses on a specific capability, making it easy to understand and adapt for your own agents. For more comprehensive examples and production-ready samples, explore the Amazon Bedrock AgentCore Samples repository.</p>"},{"location":"examples/async-processing.html","title":"Async Processing","text":"<p>This example demonstrates how to use Bedrock AgentCore's <code>@async_task</code> decorator for automatic health status management.</p>"},{"location":"examples/async-processing.html#overview","title":"Overview","text":"<p>Bedrock AgentCore provides automatic ping status management based on running async tasks:</p> <ul> <li>Automatic Health Reporting: Ping status automatically reflects system busyness</li> <li>Simple Integration: Just use the <code>@async_task</code> decorator</li> <li>Zero Configuration: Status tracking works out of the box</li> </ul>"},{"location":"examples/async-processing.html#key-concepts","title":"Key Concepts","text":"<ul> <li><code>Healthy</code>: System ready for new work</li> <li><code>HealthyBusy</code>: System busy with async tasks</li> </ul>"},{"location":"examples/async-processing.html#simple-agent-example","title":"Simple Agent Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple agent demonstrating @async_task decorator usage.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n# Long-running task that automatically affects ping status\n@app.async_task\nasync def process_data(data_id: str):\n    \"\"\"Process data asynchronously - status becomes 'HealthyBusy' during execution.\"\"\"\n    print(f\"[{datetime.now()}] Processing data: {data_id}\")\n\n    # Simulate processing work\n    await asyncio.sleep(30)  # Long-running task\n\n    print(f\"[{datetime.now()}] Completed processing: {data_id}\")\n    return f\"Processed {data_id}\"\n\n# Another background task\n@app.async_task\nasync def cleanup_task():\n    \"\"\"Cleanup task that also affects ping status.\"\"\"\n    print(f\"[{datetime.now()}] Starting cleanup...\")\n    await asyncio.sleep(10)\n    print(f\"[{datetime.now()}] Cleanup completed\")\n    return \"Cleanup done\"\n\n@app.entrypoint\nasync def handler(event):\n    \"\"\"Main handler - starts async tasks.\"\"\"\n    action = event.get(\"action\", \"info\")\n\n    if action == \"process\":\n        data_id = event.get(\"data_id\", \"default_data\")\n        # Start the async task (status will become HealthyBusy)\n        await process_data(data_id)\n        return {\"message\": f\"Processing {data_id}\", \"status\": \"completed\"}\n\n    elif action == \"cleanup\":\n        # Start cleanup task\n        await cleanup_task()\n        return {\"message\": \"Cleanup completed\"}\n\n    elif action == \"status\":\n        # Get current status\n        task_info = app.get_async_task_info()\n        current_status = app.get_current_ping_status()\n\n        return {\n            \"ping_status\": current_status.value,\n            \"active_tasks\": task_info[\"active_count\"],\n            \"running_jobs\": task_info[\"running_jobs\"]\n        }\n\n    else:\n        return {\n            \"message\": \"Simple BedrockAgentCore Agent\",\n            \"available_actions\": [\"process\", \"cleanup\", \"status\"],\n            \"usage\": \"Send {'action': 'process', 'data_id': 'my_data'}\"\n        }\n\nif __name__ == \"__main__\":\n    print(\"Starting simple BedrockAgentCore agent...\")\n    print(\"The agent will automatically report 'HealthyBusy' when processing tasks\")\n    app.run()\n</code></pre>"},{"location":"examples/async-processing.html#how-it-works","title":"How It Works","text":"<ol> <li>Decorate async functions with <code>@app.async_task</code></li> <li>Call the functions normally in your handler</li> <li>Status updates automatically:</li> <li><code>Healthy</code> when no tasks are running</li> <li><code>HealthyBusy</code> when any <code>@async_task</code> function is executing</li> </ol>"},{"location":"examples/async-processing.html#usage-examples","title":"Usage Examples","text":"<pre><code># Check current ping status\ncurl http://localhost:8080/ping\n\n# Start processing (status will become HealthyBusy)\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"process\", \"data_id\": \"sample_data\"}'\n\n# Check status while processing\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"status\"}'\n\n# Run cleanup task\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"cleanup\"}'\n</code></pre>"},{"location":"examples/async-processing.html#key-benefits","title":"Key Benefits","text":"<ol> <li>Automatic Status Tracking: No manual ping status management needed</li> <li>Cost Control: Status automatically prevents new work assignment when busy</li> <li>Simple to Use: Just add <code>@async_task</code> decorator to long-running functions</li> <li>Error Handling: Status correctly updates even if tasks fail</li> </ol> <p>This simple pattern provides automatic health monitoring for your BedrockAgentCore applications without any additional configuration.</p>"},{"location":"examples/gateway-integration.html","title":"Gateway Integration Examples","text":""},{"location":"examples/gateway-integration.html#lambda-function-as-mcp-tool","title":"Lambda Function as MCP Tool","text":"<pre><code>from bedrock_agentcore.gateway import GatewayClient\nimport json\n\nclient = GatewayClient(region_name='us-west-2')\n\n# Define Lambda tools with detailed schemas\nlambda_config = {\n    \"arn\": \"arn:aws:lambda:us-west-2:123:function:DataProcessor\",\n    \"tools\": [\n        {\n            \"name\": \"process_data\",\n            \"description\": \"Process user data in JSON or CSV format\",\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\"type\": \"string\"},\n                    \"format\": {\"type\": \"string\"}  # Note: enum not supported, document in description\n                },\n                \"required\": [\"data\", \"format\"]\n            }\n        },\n        {\n            \"name\": \"validate_data\",\n            \"description\": \"Validate data structure\",\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\"type\": \"string\"}\n                },\n                \"required\": [\"data\"]\n            }\n        }\n    ]\n}\n\n# Create Gateway with semantic search enabled\ncognito = client.create_oauth_authorizer_with_cognito(\"data-processor\")\ngateway = client.setup_gateway(\n    gateway_name=\"data-processor\",\n    target_source=json.dumps(lambda_config),\n    execution_role_arn=\"arn:aws:iam::123:role/ExecutionRole\",\n    authorizer_config=cognito['authorizer_config'],\n    target_type='lambda',\n    enable_semantic_search=True,\n    description=\"Data processing gateway with validation tools\"\n)\n\nprint(f\"Gateway created: {gateway.get_mcp_url()}\")\n</code></pre>"},{"location":"examples/gateway-integration.html#openapi-integration","title":"OpenAPI Integration","text":""},{"location":"examples/gateway-integration.html#from-s3","title":"From S3","text":"<pre><code>gateway = client.setup_gateway(\n    gateway_name=\"my-api\",\n    target_source=\"s3://my-bucket/api-spec.json\",\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#inline-openapi-specification","title":"Inline OpenAPI Specification","text":"<pre><code>openapi_spec = {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\"title\": \"User API\", \"version\": \"1.0.0\"},\n    \"servers\": [{\"url\": \"https://api.example.com\"}],\n    \"paths\": {\n        \"/users\": {\n            \"get\": {\n                \"operationId\": \"listUsers\",\n                \"summary\": \"List all users\",\n                \"responses\": {\"200\": {\"description\": \"User list\"}}\n            }\n        },\n        \"/users/{id}\": {\n            \"get\": {\n                \"operationId\": \"getUser\",\n                \"summary\": \"Get user by ID\",\n                \"parameters\": [{\n                    \"name\": \"id\",\n                    \"in\": \"path\",\n                    \"required\": True,\n                    \"schema\": {\"type\": \"string\"}\n                }],\n                \"responses\": {\"200\": {\"description\": \"User found\"}}\n            }\n        }\n    }\n}\n\ngateway = client.setup_gateway(\n    gateway_name=\"user-api\",\n    target_source=json.dumps(openapi_spec),\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#yaml-openapi-from-file","title":"YAML OpenAPI (from file)","text":"<pre><code>import yaml\n\n# Load YAML OpenAPI spec\nwith open('openapi.yaml', 'r') as f:\n    yaml_content = f.read()\n    openapi_spec = yaml.safe_load(yaml_content)\n\n# Convert to JSON string for inline use\ngateway = client.setup_gateway(\n    gateway_name=\"yaml-api\",\n    target_source=json.dumps(openapi_spec),\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n\n# Or use S3 (YAML files work directly)\ngateway = client.setup_gateway(\n    gateway_name=\"yaml-api\",\n    target_source=\"s3://my-bucket/openapi.yaml\",\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#oauth-token-management","title":"OAuth Token Management","text":"<p>When integrating Gateway with any agent framework, you'll need to handle OAuth tokens properly:</p> <pre><code>import os\nfrom datetime import datetime, timedelta\nimport httpx\nimport asyncio\n\nclass GatewayTokenManager:\n    \"\"\"Manages OAuth tokens with automatic refresh\"\"\"\n\n    def __init__(self, client_id, client_secret, token_endpoint, scope):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.token_endpoint = token_endpoint\n        self.scope = scope\n        self._token = None\n        self._expires_at = None\n\n    async def get_token(self):\n        \"\"\"Get valid token, refreshing if needed\"\"\"\n        if self._token and self._expires_at &gt; datetime.now():\n            return self._token\n\n        # Fetch new token\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                self.token_endpoint,\n                data={\n                    'grant_type': 'client_credentials',\n                    'client_id': self.client_id,\n                    'client_secret': self.client_secret,\n                    'scope': self.scope\n                },\n                headers={'Content-Type': 'application/x-www-form-urlencoded'}\n            )\n            data = response.json()\n            self._token = data['access_token']\n            # Buffer expiry by 5 minutes\n            expires_in = data.get('expires_in', 3600) - 300\n            self._expires_at = datetime.now() + timedelta(seconds=expires_in)\n            return self._token\n</code></pre>"},{"location":"examples/gateway-integration.html#generic-agent-integration","title":"Generic Agent Integration","text":"<p>Here's how to integrate Gateway with any agent framework:</p> <pre><code>import os\nimport asyncio\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\n# Initialize token manager with Gateway credentials\ntoken_manager = GatewayTokenManager(\n    client_id=os.environ['GATEWAY_CLIENT_ID'],\n    client_secret=os.environ['GATEWAY_CLIENT_SECRET'],\n    token_endpoint=os.environ['GATEWAY_TOKEN_ENDPOINT'],\n    scope=os.environ['GATEWAY_SCOPE']\n)\n\n# Gateway MCP endpoint\nGATEWAY_URL = os.environ['GATEWAY_MCP_URL']\n\n# Generic function to call Gateway tools\nasync def call_gateway_tool(tool_name: str, arguments: dict):\n    \"\"\"Call any tool exposed through Gateway\"\"\"\n    token = await token_manager.get_token()\n\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            GATEWAY_URL,\n            headers={\n                \"Authorization\": f\"Bearer {token}\",\n                \"Content-Type\": \"application/json\"\n            },\n            json={\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"method\": \"tools/call\",\n                \"params\": {\n                    \"name\": tool_name,\n                    \"arguments\": arguments\n                }\n            }\n        )\n\n        result = response.json()\n        if 'error' in result:\n            raise Exception(f\"Tool error: {result['error']}\")\n\n        return result.get('result')\n\n# Example: Using in your agent logic\nasync def process_user_request(user_message: str):\n    # Parse intent from user message\n    if \"weather\" in user_message.lower():\n        # Extract location (this would be done by your agent's NLU)\n        location = extract_location(user_message)\n        weather_data = await call_gateway_tool(\"get_weather\", {\"location\": location})\n        return f\"The weather in {location} is: {weather_data}\"\n\n    elif \"user\" in user_message.lower():\n        # Get user information\n        user_id = extract_user_id(user_message)\n        user_data = await call_gateway_tool(\"getUser\", {\"id\": user_id})\n        return f\"User information: {user_data}\"\n\n    return \"I couldn't understand your request.\"\n</code></pre>"},{"location":"examples/gateway-integration.html#complete-example-weather-agent","title":"Complete Example: Weather Agent","text":"<pre><code>from bedrock_agentcore.gateway import GatewayClient\nimport json\nimport asyncio\nimport httpx\n\n# Step 1: Create Gateway\nasync def setup_weather_gateway():\n    client = GatewayClient(region_name='us-west-2')\n\n    # Configure Lambda with weather tools\n    lambda_config = {\n        \"arn\": \"arn:aws:lambda:us-west-2:123:function:WeatherService\",\n        \"tools\": [\n            {\n                \"name\": \"get_current_weather\",\n                \"description\": \"Get current weather for a city\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"city\": {\"type\": \"string\"},\n                        \"country\": {\"type\": \"string\"}\n                    },\n                    \"required\": [\"city\"]\n                }\n            },\n            {\n                \"name\": \"get_forecast\",\n                \"description\": \"Get 5-day weather forecast\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"city\": {\"type\": \"string\"},\n                        \"days\": {\"type\": \"number\"}\n                    },\n                    \"required\": [\"city\"]\n                }\n            }\n        ]\n    }\n\n    # Create Gateway with EZ Auth\n    cognito = client.create_oauth_authorizer_with_cognito(\"weather-service\")\n    gateway = client.setup_gateway(\n        gateway_name=\"weather-service\",\n        target_source=json.dumps(lambda_config),\n        execution_role_arn=\"arn:aws:iam::123:role/WeatherExecutionRole\",\n        authorizer_config=cognito['authorizer_config'],\n        target_type='lambda',\n        enable_semantic_search=True\n    )\n\n    return gateway, cognito['client_info']\n\n# Step 2: Use the Gateway\nasync def weather_agent():\n    gateway, client_info = await setup_weather_gateway()\n\n    # Initialize token manager\n    token_manager = GatewayTokenManager(\n        client_id=client_info['client_id'],\n        client_secret=client_info['client_secret'],\n        token_endpoint=client_info['token_endpoint'],\n        scope=client_info['scope']\n    )\n\n    # Get weather for multiple cities\n    cities = [\"Seattle\", \"New York\", \"London\"]\n\n    for city in cities:\n        token = await token_manager.get_token()\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                gateway.get_mcp_url(),\n                headers={\"Authorization\": f\"Bearer {token}\"},\n                json={\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": 1,\n                    \"method\": \"tools/call\",\n                    \"params\": {\n                        \"name\": \"get_current_weather\",\n                        \"arguments\": {\"city\": city}\n                    }\n                }\n            )\n\n            result = response.json()\n            print(f\"Weather in {city}: {result.get('result')}\")\n\n# Run the agent\nif __name__ == \"__main__\":\n    asyncio.run(weather_agent())\n</code></pre>"},{"location":"examples/session-management.html","title":"Session Management","text":"<p>Agent that maintains conversation state using session IDs.</p>"},{"location":"examples/session-management.html#handler-code","title":"Handler Code","text":"<pre><code># handler.py\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom bedrock_agentcore.context import RequestContext\n\napp = BedrockAgentCoreApp()\n\n# Simple in-memory session storage (use database in production)\nsessions = {}\n\n@app.entrypoint\ndef chat_handler(payload, context: RequestContext):\n    \"\"\"Handle chat with session management\"\"\"\n    session_id = context.session_id or \"default\"\n    message = payload.get(\"message\", \"\")\n\n    # Initialize session if new\n    if session_id not in sessions:\n        sessions[session_id] = {\n            \"messages\": [],\n            \"count\": 0\n        }\n\n    # Add message to session\n    sessions[session_id][\"messages\"].append(message)\n    sessions[session_id][\"count\"] += 1\n\n    # Generate response\n    count = sessions[session_id][\"count\"]\n    return {\n        \"response\": f\"Message {count}: You said '{message}'\",\n        \"session_id\": session_id,\n        \"message_count\": count\n    }\n\napp.run()\n</code></pre>"},{"location":"examples/session-management.html#usage","title":"Usage","text":""},{"location":"examples/session-management.html#cli","title":"CLI","text":"<pre><code>agentcore configure --entrypoint handler.py\nagentcore launch\n\n# Start conversation\nagentcore invoke '{\"message\": \"Hello\"}' --session-id conv1\n\n# Continue conversation\nagentcore invoke '{\"message\": \"How are you?\"}' --session-id conv1\n\n# Session id is automatically persisted and reused in .bedrock_agentcore.yaml\nagentcore invoke '{\"message\": \"Goodbye\"}'\n\n# Start a new conversation\nagentcore invoke '{\"message\": \"Hello\"}' --session-id conv2\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html","title":"Getting Started with Browser","text":"<p>The Amazon Bedrock AgentCore Browser provides a secure, managed environment for web browsing and automation. This guide will help you implement powerful browser capabilities in your agent applications.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#prerequisites","title":"Prerequisites","text":"<p>Before using the browser tool, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>Python 3.10+ installed</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#install-the-sdk","title":"Install the SDK","text":"<pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#create-a-browser-session","title":"Create a Browser Session","text":"<p>The bedrock-agentcore SDK provides a convenient way to create browser sessions:</p> <pre><code>from bedrock_agentcore.tools.browser_client import browser_session\n\n# Create a browser session using the context manager\nwith browser_session(\"us-west-2\") as client:\n    # The session_id is automatically generated\n    print(f\"Session ID: {client.session_id}\")\n\n    # Generate WebSocket URL and headers for connecting automation frameworks\n    websocket_url, headers = client.generate_ws_headers()\n\n    # Use these to connect your preferred browser automation tool\n    # (See examples below)\n\n# The session is automatically closed when exiting the context manager\n</code></pre> <p>For more control over the session lifecycle:</p> <pre><code>from bedrock_agentcore.tools.browser_client import BrowserClient\n\n# Create a browser client\nclient = BrowserClient(region=\"us-west-2\")\n\n# Start a browser session\nclient.start()\nprint(f\"Session ID: {client.session_id}\")\n\ntry:\n    # Generate WebSocket URL and headers\n    url, headers = client.generate_ws_headers()\n\n    # Perform browser operations with your preferred automation tool\n\nfinally:\n    # Always close the session when done\n    client.stop()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#integration-examples","title":"Integration Examples","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#example-1-browser-automation-with-nova-act","title":"Example 1: Browser Automation with Nova Act","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#install-dependencies","title":"Install dependencies","text":"<p><pre><code>pip install nova-act\n</code></pre> You can build a browser agent using Nova Act to automate web interactions:</p> <pre><code>import time\nfrom bedrock_agentcore.tools.browser_client import browser_session\nfrom nova_act import NovaAct\nfrom rich.console import Console\n\nNOVA_ACT_API_KEY = \"YOUR_NOVA_ACT_API_KEY\"\n\nconsole = Console()\n\ndef main():\n    try:\n        # Step 1: Create browser session\n        with browser_session(\"us-west-2\") as client:\n            print(\"\\r   \u2705 Browser ready!                    \")\n            ws_url, headers = client.generate_ws_headers()\n\n            # Step 2: Use Nova Act to interact with the browser\n            with NovaAct(\n                    cdp_endpoint_url=ws_url,\n                    cdp_headers=headers,\n                    preview={\"playwright_actuation\": True},\n                    nova_act_api_key=NOVA_ACT_API_KEY,\n                    starting_page=\"https://www.amazon.com\",\n                ) as nova_act:\n                    result = nova_act.act(\"Search for coffee maker and get the details of the lowest priced one on the first page\")\n                    console.print(f\"\\n[bold green]Nova Act Result:[/bold green] {result}\")\n\n    except KeyboardInterrupt:\n        console.print(\"\\n\\n[yellow]Shutting down...[/yellow]\")\n        if 'client' in locals():\n            client.stop()\n            print(\"\u2705 Browser session terminated\")\n    except Exception as e:\n        print(f\"\\n[red]Error: {e}[/red]\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#example-2-using-playwright-for-browser-control","title":"Example 2: Using Playwright for Browser Control","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#install-dependencies_1","title":"Install dependencies","text":"<pre><code>pip install playwright\n</code></pre> <p>You can use the Playwright automation framework with the Browser Tool:</p> <pre><code>import time\nimport base64\nfrom datetime import datetime\nfrom playwright.sync_api import sync_playwright, Playwright, BrowserType\nfrom bedrock_agentcore.tools.browser_client import browser_session\n\ndef capture_cdp_screenshot(context, page, filename_prefix=\"screenshot\", image_format=\"jpeg\"):\n    \"\"\"Capture a screenshot using the CDP API and save to file.\"\"\"\n    cdp_client = context.new_cdp_session(page)\n    screenshot_data = cdp_client.send(\"Page.captureScreenshot\", {\n        \"format\": image_format,\n        \"quality\": 80,\n        \"captureBeyondViewport\": True\n    })\n\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    filename = f\"{filename_prefix}_{timestamp}.{image_format}\"\n    image_bytes = base64.b64decode(screenshot_data['data'])\n\n    with open(filename, \"wb\") as f:\n        f.write(image_bytes)\n\n    print(f\"\u2705 Screenshot saved: {filename}\")\n    return filename\n\n\ndef main(playwright: Playwright):\n    with browser_session(\"us-west-2\") as client:\n        print(\"\ud83d\udce1 Browser session started... waiting for readiness\")\n\n        ws_url, headers = client.generate_ws_headers()\n        chromium: BrowserType = playwright.chromium\n        browser = chromium.connect_over_cdp(ws_url, headers=headers)\n\n        try:\n            context = browser.contexts[0] if browser.contexts else browser.new_context()\n            page = context.pages[0] if context.pages else context.new_page()\n\n            # Step 1: Navigate to Amazon\n            print(\"\ud83c\udf10 Navigating to Amazon...\")\n            page.goto(\"https://www.amazon.com\", wait_until=\"domcontentloaded\")\n            time.sleep(2)\n            capture_cdp_screenshot(context, page, \"amazon_home\")\n\n            # Step 2: Search for \"coffee maker\"\n            print(\"\ud83d\udd0e Searching for 'coffee maker'...\")\n            page.fill(\"input#twotabsearchtextbox\", \"coffee maker\")\n            page.keyboard.press(\"Enter\")\n            page.wait_for_selector(\".s-result-item\", timeout=10000)\n            time.sleep(2)\n            capture_cdp_screenshot(context, page, \"coffee_maker_results\")\n\n        finally:\n            print(\"\ud83d\udd12 Closing browser session...\")\n            if not page.is_closed():\n                page.close()\n            browser.close()\n\n\nif __name__ == \"__main__\":\n    with sync_playwright() as p:\n        main(p)\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#browser-tool-architecture","title":"Browser Tool Architecture","text":"<p>The AWS Browser Tool provides:</p> <ul> <li>Fully managed browser environment running in the AWS cloud</li> <li>WebSocket-based CDP interface for browser control</li> <li>Integration with popular automation frameworks like Playwright, Puppeteer, and NovaAct</li> <li>Security and isolation between browser sessions</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#best-practices","title":"Best Practices","text":"<p>To get the most out of the browser tool:</p> <ol> <li>Use context managers for proper resource cleanup</li> <li>Handle exceptions properly to ensure browser sessions are closed</li> <li>Consider performance when making multiple browser requests</li> <li>Secure sensitive data - never hardcode credentials in browser automation code</li> <li>Use appropriate timeouts for network and page load operations</li> <li>Add error recovery for common browser automation challenges</li> </ol>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html","title":"Getting Started with Code Interpreter","text":"<p>The Amazon Bedrock AgentCore Code Interpreter provides a secure environment for executing code snippets directly within your agent applications. This guide will help you get started with implementing code execution capabilities in your agents.</p>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#prerequisites","title":"Prerequisites","text":"<p>Before using the Code Interpreter, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>Python 3.10+ installed</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#install-the-sdk","title":"Install the SDK","text":"<pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#create-a-code-interpreter-session","title":"Create a Code Interpreter Session","text":"<p>The bedrock-agentcore SDK provides a convenient way to create code interpreter sessions using the managed code interpreter <code>aws.codeinterpreter.v1</code>:</p> <pre><code>from bedrock_agentcore.tools.code_interpreter_client import code_session\n\n# Create a code interpreter session using the context manager\nwith code_session(\"us-west-2\") as client:\n    # The session is automatically created and managed\n    print(f\"Code interpreter session created\")\n\n    # List files in the session\n    result = client.invoke(\"listFiles\")\n    for event in result[\"stream\"]:\n        print(event[\"result\"][\"content\"])\n\n# The session is automatically closed when exiting the context manager\n</code></pre> <p>If you need more control over the session lifecycle, you can also use the client without a context manager:</p> <pre><code>from bedrock_agentcore.tools.code_interpreter_client import CodeInterpreter\n\n# Create a code interpreter client\nclient = CodeInterpreter(region=\"us-west-2\")\n\n# Start a code interpreter session\nclient.start()\nprint(f\"Code interpreter session started\")\n\ntry:\n    # Use the code interpreter\n    result = client.invoke(\"listFiles\")\n    for event in result[\"stream\"]:\n        print(event[\"result\"][\"content\"])\n\nfinally:\n    # Always close the session when done\n    client.stop()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#execute-code","title":"Execute Code","text":"<p>Use the <code>invoke</code> method to execute code in your session:</p> <pre><code>from bedrock_agentcore.tools.code_interpreter_client import code_session\n\nwith code_session(\"us-west-2\") as client:\n    # Execute Python code\n    code_to_execute = \"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\n# Create plot\nplt.figure(figsize=(10, 6))\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title('Sine Wave')\nplt.xlabel('x')\nplt.ylabel('sin(x)')\nplt.grid(True)\nplt.show()\n\nprint(\"Code execution completed successfully!\")\n\"\"\"\n\n    # Execute the code\n    result = client.invoke(\"executeCode\", {\"language\": \"python\", \"code\": code_to_execute})\n\n    # Process the streaming results\n    for event in result[\"stream\"]:\n        print(event[\"result\"][\"content\"])\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#integrating-with-agents","title":"Integrating with Agents","text":"<p>You can integrate the Code Interpreter with your agents to enable code execution capabilities:</p> <pre><code>import json\nfrom strands import Agent, tool\nfrom bedrock_agentcore.tools.code_interpreter_client import CodeInterpreter\n\n# Global code interpreter client\ncode_client = CodeInterpreter(\"us-west-2\")\n\n# Validation-focused system prompt\nSYSTEM_PROMPT = \"\"\"You are an AI assistant that validates answers through code execution.\nWhen asked about code, algorithms, or calculations, write Python code to verify your answers.\"\"\"\n\n\n@tool\ndef execute_python(code: str) -&gt; str:\n    \"\"\"Execute Python code in the code interpreter.\"\"\"\n\n    # Show the code being executed\n    print(\"\\nExecuting Python code:\")\n    print(code)\n\n    # Execute the code\n    response = code_client.invoke(\"executeCode\", {\"language\": \"python\", \"code\": code})\n\n    # Process the streaming results\n    output = []\n\n    for event in response[\"stream\"]:\n        if \"result\" in event and \"content\" in event[\"result\"]:\n            content = event[\"result\"][\"content\"]\n            output.append(content)\n            print(content)\n\n    return json.dumps(output[-1])\n\n\ndef demo():\n    \"\"\"Main function demonstrating the code interpreter agent\"\"\"\n    try:\n        code_client.start()\n\n        # Create the agent with the execute_python tool\n        agent = Agent(\n            tools=[execute_python],\n            system_prompt=SYSTEM_PROMPT,\n        )\n\n        prompt = \"Calculate the first 10 Fibonacci numbers.\"\n        print(f\"\\nPrompt: {prompt}\\n\")\n\n        response = agent(prompt)\n        # Print the response\n        print(\"\\nAgent Response:\")\n        print(response.message)\n    finally:\n        code_client.stop()\n\n\nif __name__ == \"__main__\":\n    demo()\n</code></pre>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#best-practices","title":"Best Practices","text":"<p>To get the most out of the Code Interpreter:</p> <ol> <li>Use context managers: The <code>code_session</code> context manager ensures proper cleanup</li> <li>Handle errors gracefully: Always include try/except blocks</li> <li>Process streaming results: Code execution results are returned as streams</li> <li>Manage files properly: Clean up temporary files when no longer needed</li> <li>Close sessions: Always close sessions when done to release resources</li> </ol>"},{"location":"user-guide/gateway/quickstart.html","title":"QuickStart: A Fully Managed MCP Server in 5 Minutes! \ud83d\ude80","text":"<p>Amazon Bedrock AgentCore Gateway provides an easy and secure way for developers to build, deploy, discover, and connect to tools at scale. AI agents need tools to perform real-world tasks\u2014from querying databases to sending messages to analyzing documents. With Gateway, developers can convert APIs, Lambda functions, and existing services into Model Context Protocol (MCP)-compatible tools and make them available to agents through Gateway endpoints with just a few lines of code. Gateway supports OpenAPI, Smithy, and Lambda as input types, and is the only solution that provides both comprehensive ingress authentication and egress authentication in a fully-managed service. Gateway eliminates weeks of custom code development, infrastructure provisioning, and security implementation so developers can focus on building innovative agent applications.</p> <p>In the quick start guide you will learn how to set up a Gateway and integrate it into your agents using the AgentCore Starter Toolkit. You can find more comprehensive guides and examples here.</p> <p>Note: The AgentCore Starter Toolkit is intended to help developers get started quickly. The Boto3 Python library provides the most comprehensive set of operations for Gateways and Targets. You can find the Boto3 documentation here. For complete documentation see the developer guide</p>"},{"location":"user-guide/gateway/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>\u26a0\ufe0f Before starting, make sure you have:</p> <ul> <li>AWS Account with credentials configured (<code>aws configure</code>). </li> <li>Python 3.10+ installed.</li> <li>Access to Anthropic's Sonnet 3.7 (or another model) for running the demo agent below.</li> </ul>"},{"location":"user-guide/gateway/quickstart.html#step-1-install-and-create-your-agent","title":"Step 1: Install and Create Your Agent","text":"<pre><code>pip install boto3\npip install bedrock-agentcore-starter-toolkit\npip install strands-agents\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#python-quick-start","title":"Python Quick Start","text":"<p>Let's walk through how you can get started quickly using the Bedrock AgentCore Starter Toolkit.</p>"},{"location":"user-guide/gateway/quickstart.html#setup","title":"Setup","text":"<p>Start by importing the client needed to create Gateways: <pre><code>from bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\nimport json\nimport logging\n\nregion = \"us-east-1\"\nclient = GatewayClient(region_name=region)\nclient.logger.setLevel(logging.DEBUG)\n</code></pre></p>"},{"location":"user-guide/gateway/quickstart.html#creating-an-oauth-authorization-server","title":"Creating an OAuth Authorization Server","text":"<p>\ud83d\udd12 Gateways are secured by OAuth authorization servers which ensure that only allowed users can access your Gateway. Let's create an OAuth authorization server to use with this Gateway. If you already have an OAuth authorization server, you can skip this step.  <pre><code># create cognito authorizer\ncognito_response = client.create_oauth_authorizer_with_cognito(\"TestGateway\")\n</code></pre></p>"},{"location":"user-guide/gateway/quickstart.html#creating-a-gateway","title":"Creating a Gateway","text":"<p>\ud83c\udf09 Now, let's create a Gateway. <pre><code># create the gateway.\ngateway = client.create_mcp_gateway(\n    # the name of the Gateway - if you don't set one, one will be generated.\n    name=None,\n    # the role arn that the Gateway will use - if you don't set one, one will be created. \n    # NOTE: if you are using your own role make sure it has a trust policy that trusts bedrock-agentcore.amazonaws.com\n    role_arn=None,\n    # the OAuth authorization server details. If you are providing your own authorization server, then pass an input of the following form: {\"customJWTAuthorizer\": {\"allowedClients\": [\"&lt;INSERT CLIENT ID&gt;\"], \"discoveryUrl\": \"&lt;INSERT DISCOVERY URL\"&gt;}}\n    authorizer_config=cognito_response[\"authorizer_config\"],\n    # enable semantic search\n    enable_semantic_search=True,\n)\n</code></pre></p> <p>Now that we have a Gateway set up let's add a target. Targets can be Lambda functions, Open API schemas, or Smithy schemas (another type of API schema). Each Gateway can have multiple targets and each target can have many APIs. </p>"},{"location":"user-guide/gateway/quickstart.html#adding-lambda-targets","title":"Adding Lambda Targets","text":"<p>\ud83d\udee0\ufe0f Let's add a Lambda function target. This code will automatically create a Lambda function for you and will add the appropriate target configuration. If you want to add your own Lambda ARN / customize the schema, skip this step.</p> <pre><code># create a lambda target.\nlambda_target = client.create_mcp_gateway_target(\n    # the gateway created in the previous step\n    gateway=gateway,\n    # the name of the Target - if you don't set one, one will be generated.\n    name=None,\n    # the type of the Target\n    target_type=\"lambda\",\n    # the target details - set this to define your own lambda if you pre-created one. Otherwise leave this None and one will be created for you.\n    target_payload=None,\n     # you will see later in the tutorial how to use this to connect to APIs using API keys and OAuth credentials.\n    credentials=None,\n)\n</code></pre>  \u27a1\ufe0f Adding a custom Lambda  Each Lambda target needs a schema defining the tools that the Lambda function implements. Your agent will see this schema and will send requests to your Lambda function in this format. You can decide how to implement the code for these tools in your Lambda.   The schema has the following structure. **\u26a0\ufe0f Note don't forget to fill in the lambdaArn with your function ARN**  <pre><code>lambda_target_payload = {\n    \"lambdaArn\": \"&lt;INSERT YOUR LAMBDA FUNCTION ARN&gt;\",\n    \"toolSchema\": {\n        \"inlinePayload\": [\n            # first tool\n            {\n                # name of the tool\n                \"name\": \"get_weather\",\n                # description of the tool\n                \"description\": \"Get weather for a location\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    # parameters of the tool\n                    \"properties\": {\n                        # first parameter, named \"location\"\n                        \"location\": {\n                            # type of the parameter, must be one of string | number | object | array | boolean | integer\n                            \"type\": \"string\",\n                            # description of the parameter\n                            \"description\": \"the location e.g. seattle, wa\"\n                        }\n                    },\n                    # which parameters are required to invoke this tool\n                    \"required\": [\n                        \"location\"\n                    ]\n                }\n            },\n            # second tool\n            {\n                \"name\": \"get_time\",\n                \"description\": \"Get time for a timezone\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"timezone\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"required\": [\n                        \"timezone\"\n                    ]\n                }\n            }\n        ]\n    }\n}\n</code></pre> You can create a target with this schema with the following: <pre><code>lambda_target = client.create_mcp_gateway_target(\n    # the gateway created in the previous step\n    gateway=gateway,\n    # the name of the Target - if you don't set one, one will be generated.\n    name=None,\n    # the type of the Target\n    target_type=\"lambda\",\n    # the target details - set this to define your own lambda if you pre-created one. Otherwise leave this None and one will be created for you.\n    target_payload=lambda_target_payload\n     # you will see later in the tutorial how to use this to connect to APIs using API keys and OAuth credentials.\n    credentials=None,\n)\n</code></pre>  Here is an example of a simple Lambda function that implements these tools. <pre><code>import json\n\ndef lambda_handler(event, context):\n    # Extract tool name from context\n    tool_name = context.client_context.custom.get('bedrockAgentCoreToolName', 'unknown')\n\n    if 'get_weather' in tool_name:\n        return {\n            'statusCode': 200,\n            'body': json.dumps({\n                'location': event.get('location', 'Unknown'),\n                'temperature': '72\u00b0F',\n                'conditions': 'Sunny'\n            })\n        }\n    elif 'get_time' in tool_name:\n        return {\n            'statusCode': 200,\n            'body': json.dumps({\n                'timezone': event.get('timezone', 'UTC'),\n                'time': '2:30 PM'\n            })\n        }\n    else:\n        return {\n            'statusCode': 200,\n            'body': json.dumps({'message': 'Unknown tool'})\n        }\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#using-the-gateway","title":"Using the Gateway","text":"<p>\ud83d\udd10 To use this Gateway, we first need to obtain an OAuth access token. If you followed the steps to create a Cognito authorization server then you can obtain an access token with the following code: <pre><code># get access token\naccess_token = client.get_access_token_for_cognito(cognito_response[\"client_info\"])\n</code></pre></p> <p>\ud83d\uddd2\ufe0f Copy and paste the below code to set up a simple agent that we can use to test out the Gateway. Note AgentCore Gateway can integrate with any Agent that uses MCP including agents / code not running on AWS. </p> <pre><code>from strands import Agent\nimport logging\nfrom strands.models import BedrockModel\nfrom strands.tools.mcp.mcp_client import MCPClient\nfrom mcp.client.streamable_http import streamablehttp_client \nimport os\n\ndef create_streamable_http_transport(mcp_url: str, access_token: str):\n       return streamablehttp_client(mcp_url, headers={\"Authorization\": f\"Bearer {access_token}\"})\n\ndef get_full_tools_list(client):\n    more_tools = True\n    tools = []\n    pagination_token = None\n    while more_tools:\n        tmp_tools = client.list_tools_sync(pagination_token=pagination_token)\n        tools.extend(tmp_tools)\n        if tmp_tools.pagination_token is None:\n            more_tools = False\n        else:\n            more_tools = True \n            pagination_token = tmp_tools.pagination_token\n    return tools\n\ndef run_agent(mcp_url: str, access_token: str, bedrock_model_id: str):\n    bedrockmodel = BedrockModel(\n        inference_profile_id=bedrock_model_id,\n        streaming=True,\n    )\n\n    mcp_client = MCPClient(lambda: create_streamable_http_transport(mcp_url, access_token))\n\n    with mcp_client:\n        tools = get_full_tools_list(mcp_client)\n        print(f\"Found the following tools: {[tool.tool_name for tool in tools]}\")\n        agent = Agent(model=bedrockmodel,tools=tools)\n        print(\"\\nThis is an interactive Strands Agent. Ask me something. When you're finished, say exit or quit: \")\n        while True:\n            user_input = input()\n            if user_input.lower() in [\"exit\", \"quit\", \"bye\"]:\n                print(\"Goodbye!\")\n                break\n            print(\"\\nThinking...\\n\")\n            agent(user_input)\n</code></pre> <p>\u2705 Now, let's run the agent: <pre><code># Run your agent!\nrun_agent(gateway[\"gatewayUrl\"], access_token, \"anthropic.claude-3-7-sonnet-20250219-v1:0\")\n</code></pre></p>"},{"location":"user-guide/gateway/quickstart.html#congratulations-you-successfully-built-an-agent-with-mcp-tools-powered-by-agentcore-gateway","title":"\ud83e\udd73\ud83e\udd73\ud83e\udd73 Congratulations - you successfully built an agent with MCP tools powered by AgentCore Gateway!","text":"<p>If you're excited and want to learn more about Gateways and the other Target types. Continue through this guide.</p>"},{"location":"user-guide/gateway/quickstart.html#adding-openapi-targets","title":"Adding OpenAPI Targets","text":"<p>Let's add an OpenAPI target. This code uses the OpenAPI schema for a NASA API that provides Mars weather information. You can get an API key sent to your email in a minute by filling out the form here: https://api.nasa.gov/. </p> <p>Open API Spec for NASA Mars weather API</p> <pre><code>nasa_open_api_payload = {\n  \"openapi\": \"3.0.3\",\n  \"info\": {\n    \"title\": \"NASA InSight Mars Weather API\",\n    \"description\": \"Returns per\u2011Sol weather summaries from the InSight lander for the seven most recent Martian sols.\",\n    \"version\": \"1.0.0\"\n  },\n  \"servers\": [\n    {\n      \"url\": \"https://api.nasa.gov\"\n    }\n  ],\n  \"paths\": {\n    \"/insight_weather/\": {\n      \"get\": {\n        \"summary\": \"Retrieve latest InSight Mars weather data\",\n        \"operationId\": \"getInsightWeather\",\n        \"parameters\": [\n          {\n            \"name\": \"feedtype\",\n            \"in\": \"query\",\n            \"required\": true,\n            \"description\": \"Response format (only \\\"json\\\" is supported).\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"json\"\n              ]\n            }\n          },\n          {\n            \"name\": \"ver\",\n            \"in\": \"query\",\n            \"required\": true,\n            \"description\": \"API version string. (only \\\"1.0\\\" supported)\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"1.0\"\n              ]\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Successful response \u2013 weather data per Martian sol.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/InsightWeatherResponse\"\n                }\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"Bad request \u2013 missing or invalid parameters.\"\n          },\n          \"429\": {\n            \"description\": \"Too many requests \u2013 hourly rate limit exceeded (2\u202f000 hits/IP).\"\n          },\n          \"500\": {\n            \"description\": \"Internal server error.\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"InsightWeatherResponse\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"sol_keys\"\n        ],\n        \"description\": \"Top\u2011level object keyed by sol numbers plus metadata.\",\n        \"properties\": {\n          \"sol_keys\": {\n            \"type\": \"array\",\n            \"description\": \"List of sols (as strings) included in this payload.\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          },\n          \"validity_checks\": {\n            \"type\": \"object\",\n            \"additionalProperties\": {\n              \"$ref\": \"#/components/schemas/ValidityCheckPerSol\"\n            },\n            \"description\": \"Data\u2011quality provenance per sol and sensor.\"\n          }\n        },\n        \"additionalProperties\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/components/schemas/SolWeather\"\n            }\n          ]\n        }\n      },\n      \"SolWeather\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"AT\": {\n            \"$ref\": \"#/components/schemas/SensorData\"\n          },\n          \"HWS\": {\n            \"$ref\": \"#/components/schemas/SensorData\"\n          },\n          \"PRE\": {\n            \"$ref\": \"#/components/schemas/SensorData\"\n          },\n          \"WD\": {\n            \"$ref\": \"#/components/schemas/WindDirection\"\n          },\n          \"Season\": {\n            \"type\": \"string\",\n            \"enum\": [\n              \"winter\",\n              \"spring\",\n              \"summer\",\n              \"fall\"\n            ]\n          },\n          \"First_UTC\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"Last_UTC\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          }\n        }\n      },\n      \"SensorData\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"av\": {\n            \"type\": \"number\"\n          },\n          \"ct\": {\n            \"type\": \"number\"\n          },\n          \"mn\": {\n            \"type\": \"number\"\n          },\n          \"mx\": {\n            \"type\": \"number\"\n          }\n        }\n      },\n      \"WindDirection\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"most_common\": {\n            \"$ref\": \"#/components/schemas/WindCompassPoint\"\n          }\n        },\n        \"additionalProperties\": {\n          \"$ref\": \"#/components/schemas/WindCompassPoint\"\n        }\n      },\n      \"WindCompassPoint\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"compass_degrees\": {\n            \"type\": \"number\"\n          },\n          \"compass_point\": {\n            \"type\": \"string\"\n          },\n          \"compass_right\": {\n            \"type\": \"number\"\n          },\n          \"compass_up\": {\n            \"type\": \"number\"\n          },\n          \"ct\": {\n            \"type\": \"number\"\n          }\n        }\n      },\n      \"ValidityCheckPerSol\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"AT\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          },\n          \"HWS\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          },\n          \"PRE\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          },\n          \"WD\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          }\n        }\n      },\n      \"SensorValidity\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sol_hours_with_data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"integer\",\n              \"minimum\": 0,\n              \"maximum\": 23\n            }\n          },\n          \"valid\": {\n            \"type\": \"boolean\"\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p></p> <p>Use the following code to add an Open API target. \u26a0\ufe0f Note: don't forget to add your api_key below. <pre><code>open_api_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=None,\n    target_type=\"openApiSchema\",\n    # the API spec to use (note don't forget to )\n    target_payload={\n        \"inlinePayload\": json.dumps(nasa_open_api_payload)\n    },\n    # the credentials to use when interacting with this API\n    credentials={\n        \"api_key\": \"&lt;INSERT KEY&gt;\",\n        \"credential_location\": \"QUERY_PARAMETER\",\n        \"credential_parameter_name\": \"api_key\"\n    }\n)\n</code></pre></p>  \u27a1\ufe0f Advanced OpenAPI Configurations (Import API specs from S3 + set up APIs with OAuth)   You can also use an OpenAPI specification stored in S3 buckets by passing the following `target_payload` field. **\u26a0\ufe0f Note don't forget to fill in the S3 URI below.** <pre><code>{\n    \"s3\": {\n        \"uri\": \"&lt;INSERT S3 URI&gt;\"\n    }\n}\n</code></pre>  If you have an API that uses a key stored in a header value you can set the `credentials` field to the following. **\u26a0\ufe0f Note don't forget to fill in the api key and parameter name below.** <pre><code>{\n    \"api_key\": \"&lt;INSERT KEY&gt;\",\n    \"credential_location\": \"HEADER\",\n    \"credential_parameter_name\": \"&lt;INSERT HEADER VALUE&gt;\"\n}\n</code></pre>  Alternatively if you have an API that uses OAuth, set the `credentials` field to the following. **\u26a0\ufe0f Note don't forget to fill in all of the information below.** <pre><code>{\n  \"oauth2_provider_config\": {\n    \"customOauth2ProviderConfig\": {\n      \"oauthDiscovery\": {\n        \"authorizationServerMetadata\": {\n          \"issuer\": \"&lt;INSERT ISSUER URL&gt;\",\n          \"authorizationEndpoint\": \"&lt;INSERT AUTHORIZATION ENDPOINT&gt;\",\n          \"tokenEndpoint\": \"&lt;INSERT TOKEN ENDPOINT&gt;\"\n        }\n      },\n      \"clientId\": \"&lt;INSERT CLIENT ID&gt;\",\n      \"clientSecret\": \"&lt;INSERT CLIENT SECRET&gt;\"\n    }\n  }\n}\n</code></pre> There are other supported `oauth_2_provider` types including Microsoft, GitHub, Google, Salesforce, and Slack. For information on the structure of those provider configs see the [identity documentation](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/identity-idps.html)."},{"location":"user-guide/gateway/quickstart.html#adding-smithy-api-model-targets","title":"Adding Smithy API Model Targets","text":"<p>Let's add a Smithy API model target. Many AWS services use Smithy API models to describe their APIs. This AWS-maintained GitHub repository has over the models of 350+ AWS services for download. For quick testing, we've made it possible to use a few of these models in the AgentCore Gateway without downloading them or storing them in S3. To create a Smithy API model target for DynamoDB simply run:</p> <pre><code># create a Smithy API model target for DynamoDB\nsmithy_target = client.create_mcp_gateway_target(gateway=gateway, name=None, target_type=\"smithyModel\")\n</code></pre>  \u27a1\ufe0f Add more Smithy API model targets   Create a Smithy API model target from a Smithy API model stored in S3. **\u26a0\ufe0f Note don't forget to fill in the S3 URI below.** <pre><code># create a Smithy API model target from a Smithy API model stored in S3\nopen_api_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=None,\n    target_type=\"smithyModel\",\n    target_payload={\n        \"s3\": {\n            \"uri\": \"&lt;INSERT S3 URI&gt;\"\n        }\n    },\n)\n</code></pre>  Create a Smithy API model target from a Smithy API model inline. **\u26a0\ufe0f Note don't forget to load the Smithy model JSON into the smithy_model_json variable.** <pre><code># create a Smithy API model target from a Smithy API model stored in S3\nopen_api_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=None,\n    target_type=\"smithyModel\",\n    target_payload={\n        \"inlinePayload\": json.dumps(smithy_model_json)\n    },\n)\n</code></pre> <p></p> \u27a1\ufe0f More Operations on Gateways and Targets (Create, Read, Update, Delete, List)   While the Starter Toolkit makes it easy to get started, the Boto3 Python client has a more complete set of operations including those for creating, reading, updating, deleting, and listing Gateways and Targets. Let's see how to use Boto3 to carry out these operations on Gateways and Targets.  ### Setup  Instantiate the client <pre><code>import boto3\n\nboto_client = boto3.client(\"bedrock-agentcore-control\", \n                           region_name=\"us-east-1\")\n</code></pre>  ### Listing Gateways/Targets Run the below code to list all of the Gateways in your account. <pre><code># list gateawys\ngateways = boto_client.list_gateways()\n</code></pre> Run the below code to list all of the Gateway Targets for a specific Gateway. <pre><code># list targets\ngateway_targets = boto_client.list_gateway_targets(gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\")\n</code></pre>  ### Getting Gateways/Targets Run the below code to get the details of a Gateway <pre><code># get a gateway\ngateway_details = boto_client.get_gateway(gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\")\n</code></pre> Run the below code to get the details of a Gateway Target. <pre><code># get a target\ntarget_details = boto_client.get_gateway_target(gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\", targetId=\"INSERT TARGET ID\")\n</code></pre>  ### Creating / Updating Gateways  Let's see how to create a Gateway. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of a create request for a Gateway: <pre><code># the schema of a create request for a Gateway\ncreate_gw_request = {\n    \"name\": \"string\", # required - name of your gateway\n    \"description\": \"string\", # optional - description of your gateway\n    \"clientToken\": \"string\", # optional - used for idempotency\n    \"roleArn\": \"string\", # required - execution role arn that Gateway will use when interacting with AWS resources\n    \"protocolType\": \"string\", # required - must be MCP\n    \"protocolConfiguration\": { # optional \n        \"mcp\": {\n            \"supportedVersions\": [\"enum_string\"], # optional - e.g. 2025-06-18\n            \"instructions\": \"string\", # optional - instructions for agents using this MCP server\n            \"searchType\": \"enum_string\" # optional - must be SEMANTIC if specified. This enables the tool search tool\n        }\n    },\n    \"authorizerType\": \"string\", # required - must be CUSTOM_JWT  \n    \"authorizerConfiguration\": { # required - the configuration for your authorizer\n        \"customJWTAuthorizer\": { # required the custom JWT authorizer setup\n            \"allowedAudience\": [], # optional \n            \"allowedClients\": [], # optional\n            \"discoveryUrl\": \"string\" # required - the URL of the authorization server\n        },\n    },\n    \"kmsKeyArn\": \"string\", # optional - an encryption key to use for encrypting your tool metadata stored on Gateway\n    \"exceptionLevel\": \"string\", # optional - must be DEBUG if specified. Gateway will return verbose error messages when DEBUG is specified.\n}\n</code></pre>  Let's take a look at a simpler example: <pre><code># an example of a create request\nexample_create_gw_request = {\n    \"name\": \"TestGateway\",\n    \"roleArn\": \"&lt;INSERT ROLE ARN e.g. arn:aws:iam::123456789012:role/Admin&gt;\",\n    \"protocolType\": \"MCP\",\n    \"authorizerType\": \"CUSTOM_JWT\",\n    \"authorizerConfiguration\":  {\n        \"customJWTAuthorizer\": {  \n            \"discoveryUrl\": \"&lt;INSERT DISCOVERY URL e.g. https://cognito-idp.{region}.amazonaws.com/{user_pool_id}/.well-known/openid-configuration&gt;\",\n            \"allowedClients\": [\"&lt;INSERT CLIENT ID&gt;\"]\n        }\n    }\n}\n</code></pre> Once you have filled in your request details, you can create a Gateway from that request with the following command: <pre><code># create the gateway\ngateway = boto_client.create_gateway(**example_create_gw_request)\n</code></pre>  Now let's see how to update a Gateway that we've already created. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of an update request for a Gateway: <pre><code># the schema of an update request for a Gateway\nupdate_gw_request = {\n    \"gatewayIdentifier\": \"string\", # required - the ID of the existing gateway\n    \"name\": \"string\", # required - name of your gateway\n    \"description\": \"string\", # optional - description of your gateway\n    \"roleArn\": \"string\", # required - execution role arn that Gateway will use when interacting with AWS resources\n    \"protocolType\": \"string\", # required - must be MCP\n    \"protocolConfiguration\": { # optional \n        \"mcp\": {\n            \"supportedVersions\": [\"enum_string\"], # optional - e.g. 2025-06-18\n            \"instructions\": \"string\", # optional - instructions for agents using this MCP server\n            \"searchType\": \"enum_string\" # optional - must be SEMANTIC if specified. This enables the tool search tool\n        }\n    },\n    \"authorizerType\": \"string\", # required - must be CUSTOM_JWT  \n    \"authorizerConfiguration\": { # required - the configuration for your authorizer\n        \"customJWTAuthorizer\": { # required the custom JWT authorizer setup\n            \"allowedAudience\": [], # optional \n            \"allowedClients\": [], # optional\n            \"discoveryUrl\": \"string\" # required - the URL of the authorization server\n        },\n    },\n    \"kmsKeyArn\": \"string\", # optional - an encryption key to use for encrypting your tool metadata stored on Gateway\n}\n</code></pre>  Let's take a look at a simpler example: <pre><code># an example of an update request\nexample_update_gw_request = {\n    \"gatewayIdentifier\": \"&lt;INSERT ID OF CREATED GATEWAY&gt;\",\n    \"name\": \"TestGateway\",\n    \"roleArn\": \"&lt;INSERT ROLE ARN e.g. arn:aws:iam::123456789012:role/Admin&gt;\",\n    \"protocolType\": \"MCP\",\n    \"authorizerType\": \"CUSTOM_JWT\",\n    \"authorizerConfiguration\":  {\n        \"customJWTAuthorizer\": {  \n            \"discoveryUrl\": \"&lt;INSERT DISCOVERY URL e.g. https://cognito-idp.{region}.amazonaws.com/{user_pool_id}/.well-known/openid-configuration&gt;\",\n            \"allowedClients\": [\"&lt;INSERT CLIENT ID&gt;\"]\n        }\n    }\n}\n</code></pre>  Once you've filled in you request details you can update a Gateway using that request with the following command: <pre><code># update the gateway\ngateway = boto_client.update_gateway(**example_update_gw_request)\n</code></pre>  ### Creating / Updating Targets  Let's see how to create a Gateway Target. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of a create request for a Gateway Target: <pre><code># the schema of a create request for a Gateway Target\ncreate_target_request = {\n    \"gatewayIdentifier\": \"string\", # required - the ID of the Gateway to create this target on\n    \"name\": \"string\", # required\n    \"description\": \"string\", # optional - description of your target\n    \"clientToken\": \"string\", # optional - used for idempotency\n    \"targetConfiguration\": { # required\n        \"mcp\": { # required - union - choose one of openApiSchema | smithyModel | lambda\n            \"openApiSchema\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"smithyModel\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"lambda\": {\n                \"lambdaArn\": \"string\",\n                \"toolSchema\": { # union - choose one of either s3 or inlinePayload \n                    \"s3\": {\n                        \"uri\": \"string\",\n                        \"bucketOwnerAccountId\": \"string\"\n                     },\n                    \"inlinePayload\": [\n                        # &lt;inline tool here&gt;\n                    ]\n                }\n            }\n        }\n    },\n    \"credentialProviderConfigurations\": [\n        {\n            \"credentialProviderType\": \"enum_string\", # required - choose one of OAUTH | API_KEY | GATEWAY_IAM_ROLE\n            \"credentialProvider\": { # optional (required if you choose OAUTH or API_KEY) - union - choose either apiKeyCredentialProvider | oauthCredentialProvider\n                \"oauthCredentialProvider\": {\n                    \"providerArn\": \"string\", # required - the ARN of the credential provider\n                    \"scopes\": [\"string\"], # required - can be empty list in some cases\n                },\n                \"apiKeyCredentialProvider\": {\n                    \"providerArn\": \"string\", # required - the ARN of the credential provider\n                    \"credentialLocation\": \"enum_string\", # required - the location where the credential goes - choose HEADER | QUERY_PARAMETER\n                    \"credentialParameterName\": \"string\", # required - the header key or parameter name e.g., \u201cAuthorization\u201d, \u201cX-API-KEY\u201d\n                    \"credentialPrefix\": \"string\"  # optional - the prefix the auth token needs e.g. \u201cBearer\u201d\n                }\n            }\n        }\n    ]\n}\n</code></pre>  Let's take a look at a simpler example: <pre><code># example of a target creation request\nexample_create_target_request = {\n    \"gatewayIdentifier\": \"&lt;INSERT GATEWAY ID\",\n    \"name\": \"TestLambdaTarget\",\n    \"targetConfiguration\": {\n        \"mcp\": {\n            \"lambda\": {\n                \"lambdaArn\": \"&lt;INSERT LAMBDA ARN e.g. arn:aws:lambda:us-west-2:123456789012:function:TestLambda&gt;\",\n                \"toolSchema\": {\n                    \"s3\": {\n                        \"uri\": \"&lt;INSERT S3 URI&gt;\"\n                    }\n                }\n            }\n        }\n    },\n    \"credentialProvider\": [\n        {\n            \"credentialProviderType\": \"GATEWAY_IAM_ROLE\"\n        }\n    ]\n}\n</code></pre> Once you've filled in you request details you can create a Gateway Target using that request with the following command: <pre><code># create the target\ntarget = boto_client.create_gateway_target(**example_create_target_request)\n</code></pre>  Now let's see how to update a Gateway Target. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of an update request for a Target: <pre><code># create a target\nupdate_target_request = {\n    \"gatewayIdentifier\": \"string\", # required - the ID of the Gateway to update this target on\n    \"targetId\": \"string\", # required - the ID of the target to update\n    \"name\": \"string\", # required\n    \"description\": \"string\", # optional - description of your target\n    \"targetConfiguration\": { # required\n        \"mcp\": { # required - union - choose one of openApiSchema | smithyModel | lambda\n            \"openApiSchema\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"smithyModel\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"lambda\": {\n                \"lambdaArn\": \"string\",\n                \"toolSchema\": { # union - choose one of either s3 or inlinePayload \n                    \"s3\": {\n                        \"uri\": \"string\",\n                        \"bucketOwnerAccountId\": \"string\"\n                     },\n                    \"inlinePayload\": [\n                        # &lt;inline tool here&gt;\n                    ]\n                }\n            }\n        }\n    },\n    \"credentialProviderConfigurations\": [\n        {\n            \"credentialProviderType\": \"enum_string\", # required - choose one of OAUTH | API_KEY | GATEWAY_IAM_ROLE\n            \"credentialProvider\": { # optional (required if you choose OAUTH or API_KEY) - union - choose either apiKeyCredentialProvider | oauthCredentialProvider\n                \"oauthCredentialProvider\": {\n                    \"providerArn\": \"string\", # required\n                    \"scopes\": [\"string\"], # required - can be empty list in some cases\n                },\n                \"apiKeyCredentialProvider\": {\n                    \"providerArn\": \"string\", # required\n                    \"credentialLocation\": \"enum_string\", # required - the location where the credential goes - choose HEADER | QUERY_PARAMETER\n                    \"credentialParameterName\": \"string\", # required - the header key or parameter name e.g., \u201cAuthorization\u201d, \u201cX-API-KEY\u201d\n                    \"credentialPrefix\": \"string\"  # optional - the prefix the auth token needs e.g. \u201cBearer\u201d\n                }\n            }\n        }\n    ]\n}\n</code></pre> Let's take a look at a simpler example: <pre><code>example_update_target_request = {\n    \"gatewayIdentifier\": \"&lt;INSERT GATEWAY ID\",\n    \"targetId\": \"&lt;INSERT TARGET ID&gt;\",\n    \"name\": \"TestLambdaTarget\",\n    \"targetConfiguration\": {\n        \"mcp\": {\n            \"lambda\": {\n                \"lambdaArn\": \"&lt;INSERT LAMBDA ARN e.g. arn:aws:lambda:us-west-2:123456789012:function:TestLambda&gt;\",\n                \"toolSchema\": {\n                    \"s3\": {\n                        \"uri\": \"&lt;INSERT S3 URI&gt;\"\n                    }\n                }\n            }\n        }\n    },\n    \"credentialProvider\": [\n        {\n            \"credentialProviderType\": \"GATEWAY_IAM_ROLE\"\n        }\n    ]\n}\n</code></pre> Once you've filled in you request details you can create a Target using that request with the following command: <pre><code># update a target\ntarget = boto_client.update_gateway_target(**example_update_target_request)\n</code></pre>   ### Deleting Gateways / Targets Run the below code to delete a Gateway. <pre><code># delete a gateway\ndelete_gateway_response = boto_client.delete_gateway(\n    gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\"\n)\n</code></pre>  Run the below code to delete a Gateway Target. <pre><code># delete a target\ndelete_target_response = boto_client.delete_gateway_target(\n    gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\",\n    targetId=\"&lt;INSERT TARGET ID&gt;\"\n)\n</code></pre>"},{"location":"user-guide/identity/quickstart.html","title":"Getting Started with AgentCore Identity","text":"<p>Amazon Bedrock AgentCore Identity provides a secure way to manage identities for your AI agents and enable authenticated access to external services. This guide will help you get started with implementing identity features in your agent applications.</p>"},{"location":"user-guide/identity/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>Python 3.10+ installed</li> <li>AWS CLI configured with your credentials</li> <li>(Optional) External service accounts for OAuth2 or API key integration</li> </ul>"},{"location":"user-guide/identity/quickstart.html#install-the-sdk","title":"Install the SDK","text":"<pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#create-a-workload-identity","title":"Create a Workload Identity","text":"<p>A workload identity is a unique identifier that represents your agent within the AgentCore Identity system:</p> <pre><code>from bedrock_agentcore.services.identity import IdentityClient\n\n# Create identity client\nidentity_client = IdentityClient(\"us-east-1\")\n\n# Create workload identity\nworkload_identity = identity_client.create_workload_identity(\n    name=\"my-research-agent\",\n)\n\nprint(f\"Workload Identity ARN: {workload_identity['workloadIdentityArn']}\")\nprint(f\"Agent Name: {workload_identity['name']}\")\n</code></pre> <p>You can also use the AWS CLI:</p> <pre><code>aws bedrock-agentcore create-workload-identity \\\n    --name \"my-research-agent\"\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#configure-credential-providers","title":"Configure Credential Providers","text":"<p>Credential providers define how your agent accesses external services:</p>"},{"location":"user-guide/identity/quickstart.html#oauth2-provider-example-google","title":"OAuth2 Provider Example (Google)","text":"<pre><code># Configure Google OAuth2 provider\ngoogle_provider = identity_client.create_oauth2_credential_provider(req={\n    \"name\": \"myGoogleCredentialProvider\",\n    \"credentialProviderVendor\": \"GoogleOauth2\",\n    \"oauth2ProviderConfigInput\": {\n        \"googleOauth2ProviderConfig\": {\n            \"clientId\": \"your-google-client-id\",\n            \"clientSecret\": \"your-google-client-secret\"\n        }\n    }\n})\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#api-key-provider-example-perplexity-ai","title":"API Key Provider Example (Perplexity AI)","text":"<pre><code># Configure API key provider\nperplexity_provider = identity_client.create_api_key_credential_provider(req={\n    \"name\": \"myPerplexityAPIKeyCredentialProvider\",\n    \"apiKey\": \"myApiKey\"\n})\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#configure-environment-variables","title":"Configure Environment Variables","text":"<p>Set up environment variables for your development environment:</p> <pre><code># AWS Configuration\nexport AWS_REGION=us-west-2\nexport AWS_ACCESS_KEY_ID=your-access-key-id\nexport AWS_SECRET_ACCESS_KEY=your-secret-access-key\n\n# Agent Configuration\nexport AGENT_IDENTITY_ID=your-agent-identity-id\nexport AGENT_IDENTITY_ARN=your-agent-identity-arn\nexport WORKLOAD_ACCESS_TOKEN=your-workload-access-token\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#building-a-simple-research-agent","title":"Building a Simple Research Agent","text":"<p>Let's create a simple research agent that demonstrates AgentCore Identity capabilities:</p>"},{"location":"user-guide/identity/quickstart.html#agent-implementation","title":"Agent Implementation","text":"<p>Create a file named <code>research_agent.py</code>:</p> <pre><code># research_agent.py\nimport os\nimport asyncio\nfrom typing import Optional\nfrom datetime import datetime\nfrom bedrock_agentcore.services.identity import IdentityClient\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\nimport requests\n\nclass ResearchAgent:\n    def __init__(self):\n        self.identity_client = IdentityClient(\"us-east-1\")\n        self.workload_token = os.getenv('WORKLOAD_ACCESS_TOKEN')\n\n    async def search_web(self, query: str) -&gt; str:\n        \"\"\"Search the web using Perplexity AI\"\"\"\n        # Get API key from identity service\n        api_key = await self.identity_client.get_api_key(\n            provider_name=\"myPerplexityAPIKeyCredentialProvider\",\n            agent_identity_token=self.workload_token\n        )\n\n        url = \"https://api.perplexity.ai/chat/completions\"\n        headers = {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        body = {\n            \"model\": \"sonar\",\n            \"messages\": [\n                {\"role\": \"user\", \"content\": query}\n            ]\n        }\n\n        try:\n            response = requests.post(url, headers=headers, json=body)\n            response.raise_for_status()\n            result = response.json()\n            return result[\"choices\"][0][\"message\"][\"content\"]\n        except Exception as e:\n            return f\"Search error: {str(e)}\"\n\n    async def save_to_drive(self, content: str, filename: str) -&gt; str:\n        \"\"\"Save content to Google Drive\"\"\"\n        try:\n            # Get OAuth2 access token from identity service\n            access_token = await self.identity_client.get_token(\n                provider_name=\"myGoogleCredentialProvider\",\n                scopes=[\"https://www.googleapis.com/auth/drive.file\"],\n                agent_identity_token=self.workload_token,\n                auth_flow=\"USER_FEDERATION\",\n                callback_url=\"https://myapp.com/callback\"\n            )\n\n            # Create Google Drive service\n            creds = Credentials(token=access_token)\n            service = build(\"drive\", \"v3\", credentials=creds)\n\n            # Create file metadata\n            file_metadata = {\n                'name': filename,\n                'mimeType': 'text/plain'\n            }\n\n            # Upload file\n            from googleapiclient.http import MediaIoBaseUpload\n            import io\n\n            media = MediaIoBaseUpload(\n                io.BytesIO(content.encode('utf-8')),\n                mimetype='text/plain'\n            )\n\n            file = service.files().create(\n                body=file_metadata,\n                media_body=media,\n                fields='id,name,webViewLink'\n            ).execute()\n\n            return f\"File saved to Google Drive: {file.get('webViewLink')}\"\n\n        except Exception as e:\n            return f\"Drive save error: {str(e)}\"\n\n    async def research_and_save(self, topic: str, user_id: str = None) -&gt; str:\n        \"\"\"Main agent function: research a topic and save to Drive\"\"\"\n        try:\n            # Search for information\n            search_query = f\"Research comprehensive information about: {topic}\"\n            search_results = await self.search_web(search_query)\n\n            # Format the research report\n            report = f\"\"\"\nResearch Report: {topic}\nGenerated by Research Agent\n{'=' * 50}\n\n{search_results}\n\n{'=' * 50}\nReport generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n            \"\"\"\n\n            # Save to Google Drive\n            filename = f\"research_report_{topic.replace(' ', '_')}.txt\"\n\n            save_result = await self.save_to_drive(\n                content=report,\n                filename=filename\n            )\n\n            return f\"Research completed! {save_result}\"\n\n        except Exception as e:\n            return f\"Research failed: {str(e)}\"\n\n# Create agent instance\nagent = ResearchAgent()\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#create-http-server","title":"Create HTTP Server","text":"<p>Create a file named <code>server.py</code> to host your agent:</p> <pre><code># server.py\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import Optional\nimport uvicorn\nfrom research_agent import agent\n\napp = FastAPI(title=\"Research Agent API\")\n\nclass ResearchRequest(BaseModel):\n    topic: str\n    user_id: Optional[str] = None\n\n@app.post(\"/research\")\nasync def research_endpoint(request: ResearchRequest):\n    \"\"\"Research a topic and save results to Google Drive\"\"\"\n    try:\n        result = await agent.research_and_save(\n            topic=request.topic,\n            user_id=request.user_id\n        )\n        return {\"status\": \"success\", \"message\": result}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return {\"status\": \"healthy\"}\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8080)\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#test-your-agent","title":"Test Your Agent","text":"<p>Start your agent server:</p> <pre><code>python server.py\n</code></pre> <p>Test the agent using curl:</p> <pre><code># Test health endpoint\ncurl http://localhost:8080/health\n\n# Test research functionality\ncurl -X POST http://localhost:8080/research \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n        \"topic\": \"artificial intelligence trends 2024\",\n        \"user_id\": \"user123\"\n    }'\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#understanding-the-oauth2-authorization-flow","title":"Understanding the OAuth2 Authorization Flow","text":"<p>When your agent first attempts to access Google Drive, it will trigger a 3-legged OAuth (3LO) flow:</p> <ol> <li>The AgentCore SDK will display a URL for authentication</li> <li>The user visits the URL and grants permissions</li> <li>The token is securely stored in the token vault</li> <li>Subsequent requests use the cached token</li> </ol> <p>Example output during the OAuth2 flow:</p> <pre><code>Waiting for authentication...\nVisit the following URL to login:\nhttps://bedrock-agentcore.us-west-2.amazonaws.com/identities/oauth2/authorize?request_uri=123456789\n\nPolling for token... (press Ctrl+C to cancel)\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#using-declarative-annotations","title":"Using Declarative Annotations","text":"<p>For a cleaner implementation, you can use AgentCore Identity's declarative annotations:</p> <pre><code>from bedrock_agentcore.identity import requires_access_token, requires_api_key\n\n@requires_api_key(provider=\"Perplexity AI\")\ndef search_perplexity(query, api_key=None):\n    \"\"\"\n    Search Perplexity AI with the query.\n    The api_key is automatically injected by the @requires_api_key decorator.\n    \"\"\"\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    # Make API call to Perplexity AI with the headers\n    # ...\n    return results\n\n@requires_access_token(provider=\"Google Workspace\", scopes=[\"https://www.googleapis.com/auth/drive.file\"])\ndef save_to_google_drive(content, filename, access_token=None):\n    \"\"\"\n    Save content to Google Drive.\n    The access_token is automatically injected by the @requires_access_token decorator.\n    \"\"\"\n    headers = {\"Authorization\": f\"Bearer {access_token}\"}\n    # Make API call to Google Drive with the headers\n    # ...\n    return results\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#security-best-practices","title":"Security Best Practices","text":"<p>When working with identity information:</p> <ol> <li>Never hardcode credentials in your agent code</li> <li>Use environment variables or AWS Secrets Manager for sensitive information</li> <li>Apply least privilege principle when configuring IAM permissions</li> <li>Regularly rotate credentials for external services</li> <li>Audit access logs to monitor agent activity</li> <li>Implement proper error handling for authentication failures</li> </ol>"},{"location":"user-guide/import-agent/configuration.html","title":"Import Agent Configuration Reference","text":"<p>This document provides detailed information about all configuration options available for the <code>import-agent</code> utility.</p>"},{"location":"user-guide/import-agent/configuration.html#command-syntax","title":"Command Syntax","text":"<pre><code>agentcore import-agent [OPTIONS]\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#configuration-options","title":"Configuration Options","text":""},{"location":"user-guide/import-agent/configuration.html#required-parameters","title":"Required Parameters","text":"<p>These parameters are required for the import process. If not provided via command line flags, the utility will prompt you interactively.</p>"},{"location":"user-guide/import-agent/configuration.html#-agent-id","title":"<code>--agent-id</code>","text":"<ul> <li>Type: String</li> <li>Description: ID of the Bedrock Agent to import</li> <li>Example: <code>--agent-id ABCD1234EFGH</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-agent-alias-id","title":"<code>--agent-alias-id</code>","text":"<ul> <li>Type: String</li> <li>Description: ID of the Agent Alias to use</li> <li>Example: <code>--agent-alias-id TSTALIASID</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-target-platform","title":"<code>--target-platform</code>","text":"<ul> <li>Type: String</li> <li>Options: <code>langchain</code>, <code>strands</code></li> <li>Description: Target platform for code generation</li> <li>Example: <code>--target-platform strands</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/import-agent/configuration.html#aws-configuration","title":"AWS Configuration","text":""},{"location":"user-guide/import-agent/configuration.html#-region","title":"<code>--region</code>","text":"<ul> <li>Type: String</li> <li>Description: AWS Region to use when fetching Bedrock Agents</li> <li>Default: Uses your default AWS configuration</li> <li>Example: <code>--region us-east-1</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#output-configuration","title":"Output Configuration","text":""},{"location":"user-guide/import-agent/configuration.html#-output-dir","title":"<code>--output-dir</code>","text":"<ul> <li>Type: String</li> <li>Description: Output directory for generated code</li> <li>Default: <code>./output/</code></li> <li>Example: <code>--output-dir ./my-agent</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#agentcore-primitives","title":"AgentCore Primitives","text":""},{"location":"user-guide/import-agent/configuration.html#-disable-memory","title":"<code>--disable-memory</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Memory primitive integration</li> <li>Default: <code>false</code> (Memory is enabled by default)</li> <li>Usage: <code>--disable-memory</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-disable-code-interpreter","title":"<code>--disable-code-interpreter</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Code Interpreter primitive integration</li> <li>Default: <code>false</code> (Code Interpreter is enabled by default)</li> <li>Usage: <code>--disable-code-interpreter</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-disable-observability","title":"<code>--disable-observability</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Observability primitive integration</li> <li>Default: <code>false</code> (Observability is enabled by default)</li> <li>Usage: <code>--disable-observability</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-disable-gateway","title":"<code>--disable-gateway</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Gateway primitive integration</li> <li>Default: <code>false</code> (Gateway is enabled by default)</li> <li>Usage: <code>--disable-gateway</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#deployment-options","title":"Deployment Options","text":""},{"location":"user-guide/import-agent/configuration.html#-deploy-runtime","title":"<code>--deploy-runtime</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Deploy the generated agent to AgentCore Runtime</li> <li>Default: <code>false</code></li> <li>Usage: <code>--deploy-runtime</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-run-option","title":"<code>--run-option</code>","text":"<ul> <li>Type: String</li> <li>Options: <code>locally</code>, <code>runtime</code>, <code>none</code></li> <li>Description: How to run the agent after generation</li> <li>Default: Interactive prompt if not specified</li> <li>Examples:</li> <li><code>--run-option locally</code> - Run the agent on your local machine</li> <li><code>--run-option runtime</code> - Run on AgentCore Runtime (requires <code>--deploy-runtime</code>)</li> <li><code>--run-option none</code> - Generate code only, don't run</li> </ul>"},{"location":"user-guide/import-agent/configuration.html#debugging-options","title":"Debugging Options","text":""},{"location":"user-guide/import-agent/configuration.html#-verbose","title":"<code>--verbose</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Enable verbose output mode</li> <li>Default: <code>false</code></li> <li>Usage: <code>--verbose</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#configuration-examples","title":"Configuration Examples","text":""},{"location":"user-guide/import-agent/configuration.html#basic-import","title":"Basic Import","text":"<pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#full-configuration-with-deployment","title":"Full Configuration with Deployment","text":"<pre><code>agentcore import-agent \\\n  --region us-west-2 \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id PRODALIASID \\\n  --target-platform langchain \\\n  --output-dir ./production-agent \\\n  --deploy-runtime \\\n  --run-option runtime \\\n  --verbose\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#minimal-setup-without-primitives","title":"Minimal Setup without Primitives","text":"<pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --disable-memory \\\n  --disable-code-interpreter \\\n  --disable-observability \\\n  --run-option none\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#debug-mode-for-troubleshooting","title":"Debug Mode for Troubleshooting","text":"<pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --output-dir ./debug-output\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#interactive-vs-non-interactive-mode","title":"Interactive vs Non-Interactive Mode","text":""},{"location":"user-guide/import-agent/configuration.html#interactive-mode","title":"Interactive Mode","text":"<p>When required parameters are missing, the utility enters interactive mode:</p> <pre><code>agentcore import-agent\n</code></pre> <p>This will prompt you for: - AWS Region selection - Agent selection from your available Bedrock Agents - Agent alias selection - Target platform choice - AgentCore primitives configuration - Deployment and run options</p>"},{"location":"user-guide/import-agent/configuration.html#non-interactive-mode","title":"Non-Interactive Mode","text":"<p>Provide all required parameters to run without prompts:</p> <pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --deploy-runtime \\\n  --run-option runtime\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#default-behavior","title":"Default Behavior","text":"Option Default Value Behavior Memory Enabled AgentCore Memory primitive is integrated Code Interpreter Enabled AgentCore Code Interpreter primitive is integrated Observability Enabled AgentCore Observability primitive is integrated Gateway Enabled AgentCore Gateway is not used as a proxy to AG Lambdas Deployment Disabled Generated code is not deployed to runtime Output Directory <code>./output/</code> Code is generated in this directory Verbose Mode Disabled Standard output level"},{"location":"user-guide/import-agent/configuration.html#environment-variables","title":"Environment Variables","text":"<p>The utility respects standard AWS environment variables:</p> <ul> <li><code>AWS_REGION</code> - Default region for AWS operations</li> <li><code>AWS_PROFILE</code> - AWS profile to use</li> <li><code>AWS_ACCESS_KEY_ID</code> / <code>AWS_SECRET_ACCESS_KEY</code> - AWS credentials</li> </ul>"},{"location":"user-guide/import-agent/configuration.html#configuration-file-support","title":"Configuration File Support","text":"<p>Currently, the import-agent utility does not support configuration files. All options must be provided via command line flags or interactive prompts.</p>"},{"location":"user-guide/import-agent/configuration.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/import-agent/configuration.html#common-issues","title":"Common Issues","text":"<p>Missing AWS Permissions Use ADA or the AWS CLI to authenticate. Ensure that you have environment variables for your AWS credentials and these can be used by Boto3 appropriately.</p> <p>Agent Not Found <pre><code># Verify your agent ID and region\nagentcore import-agent --region us-east-1 --agent-id YOUR_AGENT_ID\n</code></pre></p> <p>Output Directory Issues <pre><code># Specify a custom output directory\nagentcore import-agent --output-dir ./custom-path\n</code></pre></p>"},{"location":"user-guide/import-agent/design.html","title":"Import Agent Design","text":"<p>Design overview for the import-agent utility, explaining the choices behind the generated agent.</p>"},{"location":"user-guide/import-agent/design.html#utility-feature-support","title":"Utility Feature Support","text":"<p>Below is each feature of Bedrock Agents and which of the features this utility successfully maps to each target framework. We also describe which AgentCore Primitive is used to enhance each feature mapping.</p> Bedrock Agent Feature AgentCore + Langchain AgentCore + Strands Notes Action Groups SUPPORTED SUPPORTED Uses AgentCore Gateway Orchestration SUPPORTED SUPPORTED Guardrails SUPPORTED SUPPORTED Knowledge Bases SUPPORTED SUPPORTED Code Interpreter SUPPORTED SUPPORTED Uses AgentCore Code Interpreter Short Term Memory SUPPORTED SUPPORTED Long Term Memory SUPPORTED SUPPORTED Uses AgentCore Memory Pre/Post Processing Step SUPPORTED SUPPORTED User Input SUPPORTED SUPPORTED Traces SUPPORTED SUPPORTED Uses AgentCore Observability Multi-Agent Collaboration SUPPORTED SUPPORTED"},{"location":"user-guide/import-agent/design.html#action-groups-agentcore-gateway-target","title":"Action Groups \u2192 AgentCore Gateway Target","text":"<p>In Bedrock Agents, users can define Action Groups for their agents. An Action Group is a collection of tools that are either executed via AWS Lambda or through a local callback (Return of Control). These tools are defined using either an OpenAPI specification or a structured function schema. At runtime, Bedrock Agents call your Lambda function with an event formatted according to the schema you selected. The structure of this event is documented here: AWS Bedrock Lambda integration.</p> <p>In AgentCore Gateway, we create one gateway per generated agent. Each Action Group in Bedrock Agents maps to a target in the gateway. Within each target, every function or path/method becomes a tool. To ensure compatibility with existing Action Group Lambda functions, we use a proxy Lambda function as the executor for all tools in the gateway. This proxy:</p> <ol> <li>Receives tool calls in the Gateway's format.</li> <li>Identifies the correct Action Group Lambda to invoke.</li> <li>Reformats the request object to match the expected format.</li> <li>Calls the appropriate Lambda and returns the result in a Gateway-compatible format.</li> </ol> <p>If AgentCore Gateway is disabled, the system generates local tools instead:</p> <ul> <li>Each function or path/method becomes a separate tool.</li> <li>The tool\u2019s argument schema is exposed to the agent via Pydantic model generation.</li> <li>Each tool formats its request correctly and calls the corresponding Action Group Lambda directly.</li> </ul> <p>This approach also applies to Return of Control (ROC) action groups, where the tool prompts the user for input locally before proceeding with execution.</p>"},{"location":"user-guide/import-agent/design.html#orchestration","title":"Orchestration","text":"<p>For orchestration, the Bedrock Agents prompt are constructed at runtime, by substituting in template fixtures (ie. variables in the prompt). For example, the orchestration prompt may have the fixture called knowledge_base_guidelines. This variable is filled in depending on the model provider and model version in use.</p> <p>To approximate the same behavior and deliver translated agents that are functionally equivalent, the utility uses ONE collection of template fixtures (<code>template_fixtures_merged.json</code>) and substitutes them in to build the correct prompts. As for orchestration strategy, for both Langchain and Strands, the utility uses the standard ReAcT orchestration pattern.</p>"},{"location":"user-guide/import-agent/design.html#guardrails","title":"Guardrails","text":"<p>In Bedrock Agents, users can add Bedrock Guardrails to their agent. This applies the guardrail on the model level and Bedrock Agents will have defined behavior for when a guardrail is invoked to redact or block an input. Equivalently, the utility applies the same guardrail on Bedrock models, as there is support for this in both Langchain and Strands.</p>"},{"location":"user-guide/import-agent/design.html#knowledge-bases","title":"Knowledge Bases","text":"<p>In Bedrock Agents, users can add existing Knowledge Bases (defined via Bedrock Knowledge Bases) to their agent via the Console or SDK. The AgentCore + Langchain/Strands equivalent of this feature is to use each of those KBs to define a KB retrieval tool for an agent to use. This tool uses the AWS SDK to retrieve from connected knowledge bases using a query decided by the agent and then returns the document results for the agent to use.</p>"},{"location":"user-guide/import-agent/design.html#code-interpreter-agentcore-code-interpreter","title":"Code Interpreter \u2192 AgentCore Code Interpreter","text":"<p>In Bedrock Agents, users can enable Code Interpreter. This gives a Bedrock Agent access to a sandbox for it to write, troubleshoot, and return the output of code.</p> <p>We use AgentCore Code Interpreter for an equivalent experience. The utility defines a <code>code_tool</code> which creates a code sandbox session and defines a sub-agent with access to code interpreter operations (as tools). These operations include executing code, writing/removing files, and more. This sub-agent is fed the code tool's input query and runs in a loop using the sandbox operations to accomplish the coding task and return the output.</p> <p>When AgentCore Code Interpreter is opted-out, we use open-interpreter, an open source and local code interpreter that can write, execute, and troubleshoot code.</p>"},{"location":"user-guide/import-agent/design.html#short-term-memory","title":"Short Term Memory","text":"<p>In Bedrock Agents, by default, agents have short term memory of an entire session\u2019s messages. This means that the user can ask any number of questions within a session, with the agent keeping earlier messages from that session in its context.</p> <p>The utility will use an in-memory saver as a solution for this. In Langchain, we use an in-memory store to save the session\u2019s messages in a thread for that session. In Strands, we use a Sliding Conversation Manager, which can maintain in-memory context of any number of earlier messages in a session.</p>"},{"location":"user-guide/import-agent/design.html#long-term-memory-agentcore-memory","title":"Long Term Memory \u2192 AgentCore Memory","text":"<p>In Bedrock Agents, users can enable Long Term Memory for their agent. This is based on session summarization, where BR Agents uses an LLM to summarize the conversation\u2019s discussion topics based on a session\u2019s messages. This occurs on the end of each session, and customers can configure a max number of sessions and max days threshold to keep the summaries. In the orchestration prompt in BR agents, a synopsis of the long-term memory, consisting of multiple of these session summaries, is injected.</p> <p>In Bedrock Agents, users can enable Long-Term Memory for their agents. This system is based on session summarization, where Bedrock Agents use an LLM to summarize discussion topics from each session\u2019s messages.</p> <ul> <li>Summarization happens at the end of each session.</li> <li>Customers can configure:<ul> <li>The maximum number of sessions to retain.</li> <li>A maximum age (in days) for how long to keep the summaries.</li> </ul> </li> <li>During orchestration, Bedrock Agents inject a synopsis of long-term memory\u2014which consists of multiple session summaries\u2014into the system prompt.</li> </ul> <p>In AgentCore Memory, the utility implements a similar memory model using a summarization strategy with a dedicated memory store:</p> <pre><code>{\n    \"summaryMemoryStrategy\": {\n        \"name\": \"SessionSummarizer\",\n        \"namespaces\": [\"/summaries/{actorId}/{sessionId}\"],\n    }\n}\n</code></pre> <p>On each entrypoint invocation, formatted messages are saved to this memory store by generating an event that includes the correct <code>userId</code> and <code>sessionId</code> (both provided to the entrypoint). During agent initialization (inside the <code>get_agent</code> loop in the output code), the top session summaries are retrieved from the memory store and formatted to match the Bedrock Agents' memory style. These formatted summaries are then injected into the agent's system prompt as a memory synopsis.</p> <p>If AgentCore Memory is opted out, then we replicate the behavior with a local long term memory manager, which uses a memory summarization LLM and the memory summarization BR agents prompt to create and manage session summaries. The generated summaries are saved and maintained in a local session summaries JSON file.</p>"},{"location":"user-guide/import-agent/design.html#prepost-processing-step","title":"Pre/Post-Processing Step","text":"<p>In Bedrock Agents, customers can enable and override pre-processing and post-processing steps in their agents. These steps are meant to be taken at the start and end, respectively, of agent invocation.</p> <p>If the pre-processing step is enabled, then within the <code>invoke_agent</code> function, the utility will use the pre-processing prompt on the user query and append the output to the query before passing this on to the orchestration loop. If the post-processing step is enabled, then the post-processing prompt is used on the orchestration loop output, and this result is returned as the output of <code>invoke_agent</code>.</p>"},{"location":"user-guide/import-agent/design.html#user-input","title":"User Input","text":"<p>In Bedrock Agents, an agent can ask for human input. This may be for clarification or to ask for missing parameters for a tool call. If enabled, the utility will create a human input tool, which can be invoked with a question by the agent and asks the user for CLI input on that question. This answer is then returned to the agent as the tool\u2019s output.</p>"},{"location":"user-guide/import-agent/design.html#traces-agentcore-observability","title":"Traces \u2192 AgentCore Observability","text":"<p>In Bedrock Agents, users can view traces that describe pre/post processing steps, routing classifier steps, guardrail invocation, agent orchestration, and other information. These traces are in a format specific to Bedrock Agents, and can be viewed either in the console or as output of an invoke_agent call to a BR agent.</p> <p>The equivalent for this with AgentCore is to use AgentCore Observability (if not opted-out). For both Langchain and Strands, the agent will output OTEL logs on a session, trace, and span level. These logs are captured by AgentCore Observability when the agent is deployed to AgentCore Runtime, and the logs will be visible in CloudWatch under the GenAI Observability section.</p>"},{"location":"user-guide/import-agent/design.html#multi-agent-collaboration","title":"Multi-Agent Collaboration","text":"<p>In Bedrock Agents, users can promote an agent and add collaborators to it. This hierarchy can be up to 5 levels deep. A collaborator can receive shared conversation history from the parent, and can be invoked with routing mode (parent uses a routing classifier prompt to find a relevant collaborator for a user query) or supervisor mode (an agents-as-tools approach).</p> <p>The utility's approach to this is to recursively translate a parent agent and its children, and then orchestrate them together via an Agents-as-Tools approach by default. If conversation sharing is enabled, then the parent will inject its state into the child's via these collaboration tools. If routing mode is enabled for the parent, then the parent agent uses a routing classifier prompt, before orchestration, to invoke a relevant child agent. In AgentCore Runtime, the code for a parent agent and its children are packaged together, in the same container image, to enable this setup.</p>"},{"location":"user-guide/import-agent/overview.html","title":"Import Agent Overview","text":"<p>The <code>import-agent</code> utility enables you to migrate existing Amazon Bedrock Agents to Bedrock AgentCore, converting them into framework-specific implementations while leveraging AgentCore's enterprise-grade primitives.</p> <p>Note Use the output agent definition as a starting point for your custom agent implementation. Review the generated code, evaluate agent behavior, and make necessary changes before deploying. Extend the agent with additional tools, memory, and other features as required.</p> <p>Note Use the output agent definition as a starting point for your custom agent implementation. Review the generated code, evaluate agent behavior, and make necessary changes before deploying. Extend the agent with additional tools, memory, and other features as required.</p>"},{"location":"user-guide/import-agent/overview.html#what-is-import-agent","title":"What is Import Agent?","text":"<p>The import-agent utility automates the process of:</p> <ol> <li>Fetching your existing Bedrock Agent configuration</li> <li>Converting it to LangChain/LangGraph or Strands framework code</li> <li>Integrating AgentCore primitives (Memory, Code Interpreter, Observability, Gateway)</li> <li>Integrating AgentCore primitives (Memory, Code Interpreter, Observability, Gateway)</li> <li>Deploying to AgentCore Runtime (optional)</li> </ol>"},{"location":"user-guide/import-agent/overview.html#key-benefits","title":"Key Benefits","text":"<ul> <li>Framework Flexibility: Convert to LangChain/LangGraph or Strands</li> <li>Zero Infrastructure: Leverage AgentCore's serverless platform</li> <li>Enhanced Capabilities: Add Memory, Code Interpreter, and Observability</li> <li>Production Ready: Deploy directly to AgentCore Runtime</li> <li>Preserved Logic: Maintains your agent's core functionality</li> </ul>"},{"location":"user-guide/import-agent/overview.html#supported-target-platforms","title":"Supported Target Platforms","text":""},{"location":"user-guide/import-agent/overview.html#langchain-langgraph","title":"LangChain + LangGraph","text":"<p>Perfect for teams already using the LangChain ecosystem or those looking for extensive third-party integrations.</p>"},{"location":"user-guide/import-agent/overview.html#strands","title":"Strands","text":"<p>Ideal for teams wanting AWS-native agent development with streamlined patterns.</p>"},{"location":"user-guide/import-agent/overview.html#generated-output","title":"Generated Output","text":"<p>The utility generates an agent implementation including:</p> <ul> <li>Agent Code: Framework-specific implementation of your Bedrock Agent</li> <li>Dependencies: All required packages and versions</li> <li>Configuration: Environment setup and deployment configuration</li> <li>AgentCore Integration: Memory, Code Interpreter, and Observability primitives</li> </ul>"},{"location":"user-guide/import-agent/overview.html#migration-workflow","title":"Migration Workflow","text":"<pre><code>flowchart TD\n    A[Existing Bedrock Agent] --&gt; B[Import Agent Utility]\n    B --&gt; C{Select Target Platform}\n    C --&gt; D[LangChain/LangGraph]\n    C --&gt; E[Strands]\n    D --&gt; F[Generate Agent Code]\n    E --&gt; F\n    F --&gt; G{Deploy to Runtime?}\n    G --&gt;|Yes| H[AgentCore Runtime]\n    G --&gt;|No| I[Local Development]</code></pre>"},{"location":"user-guide/import-agent/overview.html#feature-support","title":"Feature Support","text":"Bedrock Agent Feature Langchain Strands AgentCore Guardrails SUPPORTED SUPPORTED Orchestration (via reAct) SUPPORTED SUPPORTED Knowledge Bases SUPPORTED SUPPORTED Code Interpreter SUPPORTED SUPPORTED SUPPORTED: 1P Code Interpreter Lambda Function Definitions SUPPORTED SUPPORTED SUPPORTED: AgentCore Gateway Lambda OpenAPI Definitions SUPPORTED SUPPORTED SUPPORTED: AgentCore Gateway Return of Control SUPPORTED SUPPORTED Short Term (Conversational) Memory SUPPORTED SUPPORTED Long Term (Cross-Session) Memory SUPPORTED SUPPORTED SUPPORTED: AgentCore Memory Session Summarization SUPPORTED SUPPORTED SUPPORTED: AgentCore Memory Pre Processing Step SUPPORTED SUPPORTED Post Processing Step SUPPORTED SUPPORTED KB Generation Routing/Optimizations SUPPORTED SUPPORTED Idle Timeouts SUPPORTED SUPPORTED User Input (as a tool) SUPPORTED SUPPORTED Traces SUPPORTED SUPPORTED SUPPORTED: AgentCore Observability Multi-Agent Collaboration - Supervisor Mode SUPPORTED SUPPORTED Multi-Agent Collaboration - Routing Mode SUPPORTED SUPPORTED Multi-Agent Collaboration - Conversation Relay SUPPORTED SUPPORTED Custom Bedrock Model Usage SUPPORTED SUPPORTED Chat Interface (via CLI) SUPPORTED SUPPORTED Custom Inference Configurations SUPPORTED SUPPORTED Agent Deployment N/A N/A SUPPORTED: AgentCore Runtime Lambda Parsing and Orchestration N/A N/A"},{"location":"user-guide/import-agent/overview.html#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started in 5 minutes</li> <li>Configuration Reference - Detailed parameter guide</li> <li>Design Choices - Details on the design of the generated agent</li> <li>Design Choices - Details on the design of the generated agent</li> </ul>"},{"location":"user-guide/import-agent/quickstart.html","title":"Import Agent Quick Start","text":"<p>Get started with importing your Bedrock Agent to AgentCore in just a few minutes.</p>"},{"location":"user-guide/import-agent/quickstart.html#prerequisites","title":"Prerequisites","text":"<ul> <li>AWS credentials configured with access to Bedrock Agents</li> <li>Use <code>ada</code> or <code>aws configure</code> to ensure that your credentials are available for the utility to assume.</li> <li>Bedrock AgentCore Starter Toolkit installed</li> <li>An existing Amazon Bedrock Agent</li> </ul>"},{"location":"user-guide/import-agent/quickstart.html#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/import-agent/quickstart.html#interactive-mode-recommended","title":"Interactive Mode (Recommended)","text":"<p>The simplest way to get started is with interactive mode:</p> <pre><code>agentcore import-agent\n</code></pre> <p>The utility will guide you through:</p> <ol> <li>Agent Selection: Choose your Bedrock Agent and alias</li> <li>Target Platform: Select LangChain/LangGraph or Strands</li> <li>AgentCore Primitives: Configure Memory, Code Interpreter, Observability</li> <li>Deployment Options: Deploy to AgentCore Runtime or run locally</li> </ol>"},{"location":"user-guide/import-agent/quickstart.html#command-line-mode","title":"Command Line Mode","text":"<p>For automation or when you know your parameters:</p> <pre><code>agentcore import-agent \\\n  --region us-east-1 \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --output-dir ./my-agent \\\n  --deploy-runtime \\\n  --run-option runtime\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"user-guide/import-agent/quickstart.html#1-launch-the-import-utility","title":"1. Launch the Import Utility","text":"<pre><code>agentcore import-agent\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#2-configure-aws-region","title":"2. Configure AWS Region","text":"<pre><code>? Select AWS Region: us-east-1\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#3-select-your-agent","title":"3. Select Your Agent","text":"<p>The utility will list your available Bedrock Agents in the selected region:</p> <pre><code>? Select Bedrock Agent:\n  &gt; my-customer-service-agent (ID: ABCD1234)\n    my-research-agent (ID: EFGH5678)\n    my-code-assistant (ID: IJKL9012)\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#4-choose-agent-alias","title":"4. Choose Agent Alias","text":"<pre><code>? Select Agent Alias:\n  &gt; TSTALIASID (Test)\n    PRODALIASID (Production)\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#5-select-target-platform","title":"5. Select Target Platform","text":"<pre><code>? Choose target platform:\n  &gt; strands (1.0.x)\n    langchain (0.3.x) + langgraph (0.5.x)\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#7-deployment-options","title":"7. Deployment Options","text":"<pre><code>? Deploy to AgentCore Runtime? [y/N]: Y\n? How would you like to run the agent?\n  &gt; Run on AgentCore Runtime\n    Install dependencies and run locally\n    Don't run now\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#generated-output","title":"Generated Output","text":"<p>After completion, you'll find:</p> <pre><code>./output/\n\u251c\u2500\u2500 strands_agent.py          # Your converted agent\n\u251c\u2500\u2500 requirements.txt          # Dependencies\n\u251c\u2500\u2500 .agentcore-config.yaml   # Deployment configuration\n\u2514\u2500\u2500 README.md                # Generated documentation\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#testing-your-agent","title":"Testing Your Agent","text":""},{"location":"user-guide/import-agent/quickstart.html#local-testing","title":"Local Testing","text":"<pre><code>cd ./output\npython -m pip install -r requirements.txt\npython strands_agent.py\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#agentcore-runtime-testing","title":"AgentCore Runtime Testing","text":"<p>If deployed to runtime:</p> <pre><code>cd ./output\nagentcore invoke \"Hello, test message\"\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#common-options","title":"Common Options","text":""},{"location":"user-guide/import-agent/quickstart.html#enable-debug-mode","title":"Enable Debug Mode","text":"<p>Get detailed logging in the output agent:</p> <pre><code>agentcore import-agent --debug\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#disable-specific-primitives","title":"Disable Specific Primitives","text":"<p>Skip certain AgentCore features:</p> <pre><code>agentcore import-agent \\\n  --disable-memory \\\n  --disable-code-interpreter\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#custom-output-directory","title":"Custom Output Directory","text":"<p>Specify where to generate files:</p> <pre><code>agentcore import-agent --output-dir ./my-custom-agent\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#next-steps","title":"Next Steps","text":"<ul> <li>Review Generated Code: Examine the converted agent implementation</li> <li>Test Functionality: Verify your agent works as expected</li> <li>Customize Integration: Add custom AgentCore primitive configurations</li> <li>Production Deployment: Deploy to AgentCore Runtime for production usage</li> </ul> <p>For detailed configuration options, see the Configuration Reference.</p>"},{"location":"user-guide/memory/quickstart.html","title":"Getting Started with AgentCore Memory","text":"<p>Amazon Bedrock AgentCore Memory lets you create and manage memory resources that store conversation context for your AI agents. This section guides you through installing dependencies and implementing both short-term and long-term memory features.</p>"},{"location":"user-guide/memory/quickstart.html#install-dependencies","title":"Install Dependencies","text":"<p>To get started with Amazon Bedrock AgentCore Memory, install the required Python package:</p> <pre><code>pip install bedrock-agentcore\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#create-memory","title":"Create Memory","text":""},{"location":"user-guide/memory/quickstart.html#create-memory-for-short-term-memory","title":"Create Memory for Short-term Memory","text":"<p>Adding short-term memory is a quick, one-time setup process. Short-term memory maintains context without persisting historical data. This is useful for tracking current conversation flow, such as customer support interactions. Note that for short-term memory, you don't need to add a memory strategy which is used to extract memories for long-term storage.</p> <pre><code>from bedrock_agentcore.memory import MemoryClient\n\nclient = MemoryClient(region_name=\"us-west-2\")\n\nmemory = client.create_memory(\n    name=\"CustomerSupportAgentMemory\",\n    description=\"Memory for customer support conversations\",\n)\n\n# The memory_id will be used in following operations\nprint(f\"Memory ID: {memory.get('id')}\")\nprint(f\"Memory: {memory}\")\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#list-existing-memory-resources","title":"List Existing Memory Resources","text":"<p>If you already have existing memory resources created in Amazon Bedrock AgentCore Memory, you can list them to find their identifiers:</p> <pre><code>for memory in client.list_memories():\n    print(f\"Memory Arn: {memory.get('arn')}\")\n    print(f\"Memory ID: {memory.get('id')}\")\n    print(\"--------------------------------------------------------------------\")\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#maintain-user-context-using-short-term-memory","title":"Maintain User Context Using Short-term Memory","text":""},{"location":"user-guide/memory/quickstart.html#create-events-in-short-term-memory","title":"Create Events in Short-term Memory","text":"<p>The create_event action stores agent interactions into short-term memory instantly. You can save conversations either one turn at a time or in batches, depending on your application needs. Each saved interaction can include user messages, assistant responses, and tool actions. The process is synchronous, ensuring no conversation data is lost.</p> <pre><code>client.create_event(\n    memory_id=memory.get(\"id\"), # This is the id from create_memory or list_memories\n    actor_id=\"User84\",  # This is the identifier of the actor, could be an agent or end-user.\n    session_id=\"OrderSupportSession1\", #Unique id for a particular request/conversation.\n    messages=[\n        (\"Hi, I'm having trouble with my order #12345\", \"USER\"),\n        (\"I'm sorry to hear that. Let me look up your order.\", \"ASSISTANT\"),\n        (\"lookup_order(order_id='12345')\", \"TOOL\"),\n        (\"I see your order was shipped 3 days ago. What specific issue are you experiencing?\", \"ASSISTANT\"),\n        (\"Actually, before that - I also want to change my email address\", \"USER\"),\n        (\n            \"Of course! I can help with both. Let's start with updating your email. What's your new email?\",\n            \"ASSISTANT\",\n        ),\n        (\"newemail@example.com\", \"USER\"),\n        (\"update_customer_email(old='old@example.com', new='newemail@example.com')\", \"TOOL\"),\n        (\"Email updated successfully! Now, about your order issue?\", \"ASSISTANT\"),\n        (\"The package arrived damaged\", \"USER\"),\n    ],\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#load-conversations-from-short-term-memory","title":"Load Conversations from Short-term Memory","text":"<p>The list_events method loads conversations from short-term memory using the memory_id, actor_id and session_id. The process is synchronous and returns the conversation data:</p> <pre><code>conversations = client.list_events(\n    memory_id=memory.get(\"id\"),\n    actor_id=\"User84\",\n    session_id=\"OrderSupportSession1\",\n    max_results=5,\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#long-term-memory","title":"Long-term Memory","text":""},{"location":"user-guide/memory/quickstart.html#create-memory-with-long-term-memory","title":"Create Memory with Long-term Memory","text":"<p>With long-term memory, you can extract and store information from conversations for future use. When you add long-term memory, you can use one of the following strategies:</p> <ul> <li> <p>User Preferences (UserPreferenceMemoryStrategy): Stores and learns recurring patterns in user behavior, interaction styles, and choices. This enables the agent to automatically adapt its responses to match user preferences across multiple sessions.</p> </li> <li> <p>Semantic Facts (SemanticMemoryStrategy): Maintains knowledge of facts and domain-specific information, technical concepts, and their relationships. This allows the agent to provide informed responses based on previously established context and understanding.</p> </li> <li> <p>Session Summaries (SummaryMemoryStrategy): Creates condensed representations of interaction content and outcomes. These summaries provide quick reference points for past activities and help optimize context window usage for future interactions.</p> </li> </ul> <p>To create a memory resource with long-term memory, use the create_memory_and_wait method with a strategy. When you add a memory strategy for the first time to a memory resource (either on create or update), it may take 2-3 minutes for it to become ACTIVE:</p> <pre><code>memory = client.create_memory_and_wait(\n    name=\"MyAgentMemory\",\n    strategies=[{\n        \"summaryMemoryStrategy\": {\n            # Name of the extraction model/strategy\n            \"name\": \"SessionSummarizer\",\n            # Organize facts by session ID for easy retrieval\n            # Example: \"summaries/User84/session123\" contains summary of session123\n            \"namespaces\": [\"/summaries/{actorId}/{sessionId}\"]\n        }\n    }]\n)\n</code></pre> <p>If you are already using short-term memory, you can upgrade to use long-term memory by adding a strategy to the existing memory resource:</p> <pre><code>summary_strategy = client.add_summary_strategy(\n    memory_id = memory.get(\"id\"),\n    name=\"SessionSummarizer\",\n    description=\"Summarizes conversation sessions\",\n    namespaces=[\"/summaries/{actorId}/{sessionId}\"] #Namespace allow you to organize all extracted information. This template will extract information for each sessionId belonging to an actor in separate namespace\n)\n</code></pre> <p>Note</p> <p>Long-term memory records will only be extracted from events that are stored after the newly added strategies become ACTIVE. Conversations stored before a strategy is added will not appear in long-term memory.</p>"},{"location":"user-guide/memory/quickstart.html#save-conversations-and-view-extracted-memories","title":"Save Conversations and View Extracted Memories","text":"<p>The following example demonstrates how to save a conversation and retrieve its automatically extracted memories. After saving the conversation, we wait for 1 minute to allow the long-term memory strategies to process and extract meaningful information before retrieving it.</p> <pre><code>import time\n\nevent = client.create_event(\n    memory_id=memory.get(\"id\"), # This is the id from create_memory or list_memories\n    actor_id=\"User84\",  # This is the identifier of the actor, could be an agent or end-user.\n    session_id=\"OrderSupportSession1\",\n    messages=[\n        (\"Hi, I'm having trouble with my order #12345\", \"USER\"),\n        (\"I'm sorry to hear that. Let me look up your order.\", \"ASSISTANT\"),\n        (\"lookup_order(order_id='12345')\", \"TOOL\"),\n        (\"I see your order was shipped 3 days ago. What specific issue are you experiencing?\", \"ASSISTANT\"),\n        (\"Actually, before that - I also want to change my email address\", \"USER\"),\n        (\n            \"Of course! I can help with both. Let's start with updating your email. What's your new email?\",\n            \"ASSISTANT\",\n        ),\n        (\"newemail@example.com\", \"USER\"),\n        (\"update_customer_email(old='old@example.com', new='newemail@example.com')\", \"TOOL\"),\n        (\"Email updated successfully! Now, about your order issue?\", \"ASSISTANT\"),\n        (\"The package arrived damaged\", \"USER\"),\n    ],\n)\n\n# Wait for meaningful memories to be extracted from the conversation.\ntime.sleep(60)\n\n# We will query for the summary of the issue using the namespace set in summary strategy above\nmemories = client.retrieve_memories(\n    memory_id=memory.get(\"id\"),\n    namespace=f\"/summaries/User84/OrderSupportSession1\",\n    query=\"can you summarize the support issue\"\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#use-long-term-memory-in-an-agent","title":"Use Long-term Memory in an Agent","text":""},{"location":"user-guide/memory/quickstart.html#install-dependencies_1","title":"Install Dependencies","text":"<pre><code>pip install strands\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#add-memory-to-an-agent","title":"Add Memory to an Agent","text":"<pre><code>from strands import tool, Agent\nfrom strands_tools.agent_core_memory import AgentCoreMemoryToolProvider\nimport time\nfrom bedrock_agentcore.memory import MemoryClient\n\nclient = MemoryClient(region_name=\"us-west-2\")\nmemory = client.create_memory_and_wait(\n    name=\"MyAgentMemory\",\n    strategies=[{\n        \"userPreferenceMemoryStrategy\": {\n            \"name\": \"UserPreference\",\n            \"namespaces\": [\"/users/{actorId}\"]\n        }\n    }]\n)\n\nstrands_provider = AgentCoreMemoryToolProvider(\n    memory_id=memory.get(\"id\"),\n    actor_id=\"CaliforniaPerson\",\n    session_id=\"TalkingAboutFood\",\n    namespace=\"/users/CaliforniaPerson\",\n    region=\"us-west-2\"\n)\nagent = Agent(tools=strands_provider.tools)\n\nagent(\"Im vegetarian and I prefer restaurants with a quiet atmosphere.\")\nagent(\"Im in the mood for Italian cuisine.\")\nagent(\"Id prefer something mid-range and located downtown.\")\nagent(\"I live in Irvine.\")\n\ntime.sleep(60)\n\n# This will use the long-term memory tool\nagent(\"I dont remember what I was in a mood for, do you remember?\")\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#custom-strategies","title":"Custom Strategies","text":"<p>You can customize existing strategies by specifying your own prompt. This allows you to specify the exact information you want to extract. In the example below, we will create a custom prompt to extract a user's preference about their airline needs.</p>"},{"location":"user-guide/memory/quickstart.html#create-an-iam-role-for-the-service","title":"Create an IAM Role for the Service","text":"<p>Start by ensuring you have an IAM role with the managed policy <code>AmazonBedrockAgentCoreMemoryBedrockModelInferenceExecutionRolePolicy</code>, or create a policy with the following permissions:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:InvokeModelWithResponseStream\"\n            ],\n            \"Resource\": [\n                \"arn:aws:bedrock:*::foundation-model/*\",\n                \"arn:aws:bedrock:*:*:inference-profile/*\"\n            ],\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"aws:ResourceAccount\": \"${aws:PrincipalAccount}\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>This role is assumed by the Service to call the model in your AWS account. Use the trust policy below when creating the role or when using the managed policy:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": [\n                    \"bedrock-agentcore.amazonaws.com\"\n                ]\n            },\n            \"Action\": \"sts:AssumeRole\"\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#create-a-long-term-memory-with-a-custom-strategy","title":"Create a Long-term Memory with a Custom Strategy","text":"<pre><code>from bedrock_agentcore.memory import MemoryClient\n\nclient = MemoryClient(region_name=\"us-west-2\")\n\n# Our custom prompt ensures that we're able to extract a customer's travel preferences.\nCUSTOM_PROMPT = \"\"\"\\\nYou are tasked with analyzing conversations to extract the user's preferences. You'll be analyzing two sets of data:\n\n&lt;past_conversation&gt;\n[Past conversations between the user and system will be placed here for context]\n&lt;/past_conversation&gt;\n\n&lt;current_conversation&gt;\n[The current conversation between the user and system will be placed here]\n&lt;/current_conversation&gt;\n\nYour job is to identify and categorize the user's preferences about their travel habits.\n- Extract a user's preference for the airline carrier from the choice they make.\n- Extract a user's preference for the seat type on the airline from the choice they make. It can aisle, middle or window\n\"\"\"\n\n# Replace the value with the role arn created above.\nMEMORY_EXECUTION_ROLE_ARN = \"arn:aws:iam::123456789012:role/MyRole\"\n\nmemory = client.create_memory_and_wait(\n    name=\"AirlineMemoryAgent\",\n    strategies=[{\n        \"customMemoryStrategy\": {\n            \"name\": \"UserPreference\",\n            \"namespaces\": [\"/users/{actorId}\"],\n            \"configuration\" : {\n                \"userPreferenceOverride\" : {\n                    \"extraction\" : {\n                        \"modelId\" : \"anthropic.claude-3-5-sonnet-20241022-v2:0\",\n                        \"appendToPrompt\": CUSTOM_PROMPT\n                    }\n                }\n            }\n        }\n    }],\n    memory_execution_role_arn=MEMORY_EXECUTION_ROLE_ARN\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#create-events-to-upload-user-conversations","title":"Create Events to Upload User Conversations","text":"<pre><code>event = client.create_event(\n    memory_id=memory.get(\"id\"), # This is the id from create_memory or list_memories\n    actor_id=\"User84\",  # This is the identifier of the actor, could be an agent or end-user.\n    session_id=\"AirlineBookingSession1\",\n    messages=[\n        (\"Hi, I would like to book a flight from Seattle to New York for this Sunday\", \"USER\"),\n        (\"Certainly, let me try to find the best flights for you\", \"ASSISTANT\"),\n        (\"flight_search(start='Seattle', end='New York', date='2025-07-30')\", \"TOOL\"),\n        (\"I have a two options available. 1/ Delta Airlines DL456 at 10:30 AM 2/ American Airline AA345 at 4PM. \", \"ASSISTANT\"),\n        (\"Delta airline\", \"USER\"),\n        (\"Sure. I will get you a seat on Delta flight DL456. Do you have a preference for a seat type\",\"ASSISTANT\",),\n        (\"Yes. Window please\", \"USER\"),\n        (\"I have booked you on flight DL456 at 10:30 AM on 07/30/2025. Your seat number is 26A. You will more details in your email\", \"ASSISTANT\"),\n    ],\n)\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#search-for-users-preferences","title":"Search for User's Preferences","text":"<pre><code>memories = client.retrieve_memories(\n    memory_id=memory.get(\"id\"),\n    namespace=f\"/users/User84\",\n    query=\"What are the user's preferences for airline type ?\"\n)\n\nmemories = client.retrieve_memories(\n    memory_id=memory.get(\"id\"),\n    namespace=f\"/users/User84\",\n    query=\"What are the user's preferences for seat type ?\"\n)\n</code></pre>"},{"location":"user-guide/observability/quickstart.html","title":"Getting Started with AgentCore Observability","text":"<p>Amazon Bedrock AgentCore Observability helps you trace, debug, and monitor agent performance in production environments. This guide will help you get started with implementing observability features in your agent applications.</p>"},{"location":"user-guide/observability/quickstart.html#what-is-agentcore-observability","title":"What is AgentCore Observability?","text":"<p>AgentCore Observability provides:</p> <ul> <li>Detailed visualizations of each step in the agent workflow</li> <li>Real-time visibility into operational performance through CloudWatch dashboards</li> <li>Telemetry for key metrics such as session count, latency, duration, token usage, and error rates</li> <li>Rich metadata tagging and filtering for issue investigation</li> <li>Standardized OpenTelemetry (OTEL)-compatible format for easy integration with existing monitoring stacks</li> <li>Flexibility to be used with all AI agent frameworks and any large language model</li> </ul>"},{"location":"user-guide/observability/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>AWS Account with credentials configured (<code>aws configure</code>) with model access enabled to the Foundation Model you would like to use.</li> <li>Python 3.10+ installed</li> <li>Enable transaction search on Amazon CloudWatch. First-time users must enable CloudWatch Transaction Search to view Bedrock AgentCore spans and traces.</li> <li>Add the OpenTelemetry library Include <code>aws-opentelemetry-distro</code> (ADOT) in your requirements.txt file.</li> <li>Ensure that your framework is configured to emit traces (eg. <code>strands-agents[otel]</code> package), you may sometimes need to include <code>&lt;your-agent-framework-auto-instrumentor&gt;</code> # e.g., <code>opentelemetry-instrumentation-langchain</code></li> </ul> <p>AgentCore Observability offers two ways to configure monitoring to match different infrastructure needs: 1. AgentCore Runtime-hosted agents 2. Non-runtime hosted agents</p>"},{"location":"user-guide/observability/quickstart.html#enabling-observability-for-agentcore-hosted-agents","title":"Enabling Observability for AgentCore-Hosted Agents","text":"<p>AgentCore Runtime-hosted agents are deployed and executed directly within the AgentCore environment, providing automatic instrumentation with minimal configuration. This approach offers the fastest path to deployment and is ideal for rapid development and testing. </p> <p>For a complete example please refer to this notebook</p>"},{"location":"user-guide/observability/quickstart.html#step-1-create-your-agent-shown-below-is-an-example-with-strands-agents-sdk","title":"Step 1 : Create your Agent, shown below is an example with Strands Agents SDK:","text":"<p>To enable OTEL exporting, please note to install Strands Agents with otel extra dependencies: </p> <pre><code>pip install 'strands-agents[otel]'\n</code></pre> <p>Highlighted below are the steps to host a strands agent on AgentCore Runtime to get started: </p> <pre><code>##  Save this as strands_claude.py\nfrom strands import Agent, tool\nfrom strands_tools import calculator # Import the calculator tool\nimport argparse\nimport json\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom strands.models import BedrockModel\n\napp = BedrockAgentCoreApp()\n\n# Create a custom tool \n@tool\ndef weather():\n    \"\"\" Get weather \"\"\" # Dummy implementation\n    return \"sunny\"\n\n\nmodel_id = \"us.anthropic.claude-3-7-sonnet-20250219-v1:0\"\nmodel = BedrockModel(\n    model_id=model_id,\n)\nagent = Agent(\n    model=model,\n    tools=[calculator, weather],\n    system_prompt=\"You're a helpful assistant. You can do simple math calculation, and tell the weather.\"\n)\n\n@app.entrypoint\ndef strands_agent_bedrock(payload):\n    \"\"\"\n    Invoke the agent with a payload\n    \"\"\"\n    user_input = payload.get(\"prompt\")\n    print(\"User input:\", user_input)\n    response = agent(user_input)\n    return response.message['content'][0]['text']\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-2-deploy-and-invoke-your-agent-on-agentcore-runtime","title":"Step 2 : Deploy and invoke your Agent on AgentCore Runtime","text":"<p>Now that you created an agent ready to be hosted on AgentCore runtime, you can easily deploy it using the <code>bedrock_agentcore_starter_toolkit</code> package as shown below : </p> <pre><code>from bedrock_agentcore_starter_toolkit import Runtime\nfrom boto3.session import Session\nboto_session = Session()\nregion = boto_session.region_name\n\nagentcore_runtime = Runtime()\nagent_name = \"strands_claude_getting_started\"\nresponse = agentcore_runtime.configure(\n    entrypoint=\"strands_claude.py\", # file created in Step 1  \n    auto_create_execution_role=True,\n    auto_create_ecr=True,\n    requirements_file=\"requirements.txt\", # ensure aws-opentelemetry-distro exists along with your libraries required to run your agent\n    region=region,\n    agent_name=agent_name\n)\n\nlaunch_result = agentcore_runtime.launch()\nlaunch_result\n</code></pre> <p>In these simple steps you deployed your strands agent on runtime with the Bedrock agentcore starter toolkit that automaticcally instruments your agent invocation using Open Telemetry. Now, you can invoke your agent using the command shown below and see the Traces, sessions and metrics on GenAI Obsrvability dashboard on Amazon Cloudwatch. </p> <pre><code>invoke_response = agentcore_runtime.invoke({\"prompt\": \"How is the weather now?\"})\ninvoke_response\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#enabling-observability-for-non-agentcore-hosted-agents","title":"Enabling Observability for Non-AgentCore-Hosted Agents","text":"<p>For agents running outside of the AgentCore runtime, deliver the same monitoring capabilities for agents deployed on your own infrastructure, allowing consistent observability regardless of where your agents run. Additionally, you would need to  follow the steps below to configure the environment variables needed to observe your agents. </p> <p>For a complete example please refer to this notebook</p>"},{"location":"user-guide/observability/quickstart.html#step-1-configure-aws-environment-variables","title":"Step 1: Configure AWS Environment Variables","text":"<pre><code>export AWS_ACCOUNT_ID=&lt;account id&gt;\nexport AWS_DEFAULT_REGION=&lt;default region&gt;\nexport AWS_REGION=&lt;region&gt;\nexport AWS_ACCESS_KEY_ID=&lt;access key id&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;secret key&gt;\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-2-configure-cloudwatch-logging","title":"Step 2: Configure CloudWatch logging:","text":"<p>Create a log group and log stream for your agent in Amazon CloudWatch which you can use to configure below environment variables.</p>"},{"location":"user-guide/observability/quickstart.html#step-3-configure-opentelemetry-environment-variables","title":"Step 3: Configure OpenTelemetry Environment Variables","text":"<pre><code>export AGENT_OBSERVABILITY_ENABLED=true # Activates the ADOT pipeline\nexport OTEL_PYTHON_DISTRO=aws_distro # Uses AWS Distro for OpenTelemetry \nexport OTEL_PYTHON_CONFIGURATOR=aws_configurator # Sets AWS configurator for ADOT SDK\nexport OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf # Configures export protocol\nexport  OTEL_EXPORTER_OTLP_LOGS_HEADERS=x-aws-log-group=&lt;YOUR-LOG-GROUP&gt;,x-aws-log-stream=&lt;YOUR-LOG-STREAM&gt;,x-aws- metric-namespace=&lt;YOUR-NAMESPACE&gt;\n# Directs logs to CloudWatch groups \nexport OTEL_RESOURCE_ATTRIBUTES=service.name=&lt;YOUR-AGENT-NAME&gt; # Identifies your agent in observability data\n</code></pre> <p>Replace <code>&lt;YOUR-AGENT-NAME&gt;</code> with a unique name to identify this agent in the GenAI Observability dashboard and logs.</p>"},{"location":"user-guide/observability/quickstart.html#step-4-create-an-agent-locally","title":"Step 4: Create an agent locally","text":"<pre><code># Create agent.py -  Strands agent that is a weather assistant\nfrom strands import Agent\nfrom strands_tools import http_request\n\n# Define a weather-focused system prompt\nWEATHER_SYSTEM_PROMPT = \"\"\"You are a weather assistant with HTTP capabilities. You can:\n\n1. Make HTTP requests to the National Weather Service API\n2. Process and display weather forecast data\n3. Provide weather information for locations in the United States\n\nWhen retrieving weather information:\n1. First get the coordinates or grid information using https://api.weather.gov/points/{latitude},{longitude} or https://api.weather.gov/points/{zipcode}\n2. Then use the returned forecast URL to get the actual forecast\n\nWhen displaying responses:\n- Format weather data in a human-readable way\n- Highlight important information like temperature, precipitation, and alerts\n- Handle errors appropriately\n- Convert technical terms to user-friendly language\n\nAlways explain the weather conditions clearly and provide context for the forecast.\n\"\"\"\n\n# Create an agent with HTTP capabilities\nweather_agent = Agent(\n    system_prompt=WEATHER_SYSTEM_PROMPT,\n    tools=[http_request],  # Explicitly enable http_request tool\n)\n\nresponse = weather_agent(\"What's the weather like in Seattle?\")\nprint(response)\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-5-run-your-agent-with-automatic-instrumentation-command","title":"Step 5: Run your agent with automatic instrumentation command","text":"<p>With aws-opetelemetry-distro in your requirements.txt, <code>opentelemetry-instrument</code> command will:</p> <ul> <li>Load your OTEL configuration from your environment variables</li> <li>Automatically instrument Strands, Amazon Bedrock calls, agent tool and databases, and other requests made by agent</li> <li>Send traces to CloudWatch</li> <li>Enable you to visualize the agent's decision-making process in the GenAI Observability dashboard</li> </ul> <pre><code>opentelemetry-instrument python agent.py\n</code></pre> <p>You can now view your traces, sessions and metrics on GenAI Observability Dashboard on Amazon CloudWatch with the help of YOUR-AGENT-NAME that you configured in your environment variable.</p> <p>To correlate traces across multiple agent runs, you can associate a session ID with your telemetry data using OpenTelemetry baggage:</p> <pre><code>from opentelemetry import baggage, context\nctx = baggage.set_baggage(\"session.id\", session_id)\n</code></pre> <p>Run the session-enabled version following command, complete implementation provided in the notebook:</p> <pre><code>opentelemetry-instrument python strands_travel_agent_with_session.py --session-id \"user-session-123\"\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#agentcore-observability-on-genai-observability-on-amazon-cloudwatch","title":"AgentCore Observability on GenAI Observability on Amazon CloudWatch","text":"<p>After implementing observability, you can view the collected data in CloudWatch:</p>"},{"location":"user-guide/observability/quickstart.html#bedrock-agentcore-overview-on-genai-observability-dashboard","title":"Bedrock AgentCore Overview on GenAI Observability dashboard","text":"<ol> <li>Open the GenAI Observability on CloudWatch console</li> <li>You are able to view the data related to model invocations and agents on Bedrock AgentCore on the dashboard.</li> <li>In the Bedrock Agentcore tab you are able to see Agents View, Sessions View and Traces View. </li> <li>Agents View lists all your Agents that are on and not on runtime, you can also click on the agent and view further details like runtime metrics, sessions and traces specific to an agent.</li> <li>In the Sessions View tab, you can navigate across all the sessions associated with agents.</li> <li>In the Trace View tab, you can look into the traces and span information for agents. Also explore the trace trajectory and timeline by clicking on a trace. </li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-logs-in-cloudwatch","title":"View Logs in CloudWatch","text":"<ol> <li>Open the CloudWatch console</li> <li>In the left navigation pane, expand Logs and select Log groups</li> <li> <p>Search for your agent's log group:</p> </li> <li> <p>Standard logs (stdout/stderr) Location: <code>/aws/bedrock-agentcore/runtimes/&lt;agent_id&gt;-&lt;endpoint_name&gt;/[runtime-logs] &lt;UUID&gt;</code></p> </li> <li>OTEL structured logs: <code>/aws/bedrock-agentcore/runtimes/&lt;agent_id&gt;-&lt;endpoint_name&gt;/runtime-logs</code></li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-traces-and-spans","title":"View Traces and Spans","text":"<ol> <li>Open the CloudWatch console</li> <li>Select Transaction Search from the left navigation</li> <li>Location: <code>/aws/spans/default</code></li> <li>Filter by service name or other criteria</li> <li>Select a trace to view the detailed execution graph</li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-metrics","title":"View Metrics","text":"<ol> <li>Open the CloudWatch console</li> <li>Select Metrics from the left navigation</li> <li>Browse to the <code>bedrock-agentcore</code> namespace</li> <li>Explore the available metrics</li> </ol>"},{"location":"user-guide/observability/quickstart.html#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple, Then Expand - The default observability provided by AgentCore captures most critical metrics automatically, including model calls, token usage, and tool execution.</li> <li>Configure for Development Stage - Tailor your observability configuration to match your current development phase and progressively adjust.</li> <li>Use Consistent Naming - Establish naming conventions for services, spans, and attributes from the start</li> <li>Filter Sensitive Data - Prevent exposure of confidential information by filtering sensitive data from observability attributes and payloads.</li> <li>Set up alerts - Configure CloudWatch alarms to notify you of potential issues before they impact users</li> </ol>"},{"location":"user-guide/runtime/async.html","title":"Handle Asynchronous and Long Running Agents","text":"<p>AgentCore Runtime can handle asynchronous processing and long running agents. Asynchronous tasks allow your agent to continue processing after responding to the client and handle long-running operations without blocking responses.</p> <p>With async processing, your agent can:</p> <ul> <li>Start a task that might take minutes or hours</li> <li>Immediately respond to the user saying \"I've started working on this\"</li> <li>Continue processing in the background</li> <li>Allow the user to check back later for results</li> </ul>"},{"location":"user-guide/runtime/async.html#key-concepts","title":"Key Concepts","text":""},{"location":"user-guide/runtime/async.html#asynchronous-processing-model","title":"Asynchronous Processing Model","text":"<p>The Amazon Bedrock AgentCore SDK supports both synchronous and asynchronous processing through a unified API. This creates a flexible implementation pattern for both clients and agent developers. Agent clients can work with the same API without differentiating between synchronous and asynchronous on the client side. With the ability to invoke the same session across invocations, agent developers can reuse context and build upon this context incrementally without implementing complex task management logic.</p>"},{"location":"user-guide/runtime/async.html#runtime-session-lifecycle-management","title":"Runtime Session Lifecycle Management","text":"<p>Agent code communicates its processing status using the \"/ping\" health status:</p> <ul> <li>\"Healthy\": Ready for new work, no background tasks running</li> <li>\"HealthyBusy\": Currently processing background tasks</li> </ul> <p>A session in idle state for 15 minutes gets automatically terminated.</p>"},{"location":"user-guide/runtime/async.html#three-ways-to-manage-async-tasks","title":"Three Ways to Manage Async Tasks","text":""},{"location":"user-guide/runtime/async.html#1-async-task-decorator-recommended","title":"1. Async Task Decorator (Recommended)","text":"<p>The simplest way to track asynchronous functions. The SDK automatically manages the ping status:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.async_task\nasync def background_work():\n    await asyncio.sleep(10)  # Status becomes \"HealthyBusy\"\n    return \"done\"\n\n@app.entrypoint\nasync def handler(event):\n    asyncio.create_task(background_work())\n    return {\"status\": \"started\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>How it works: - The <code>@app.async_task</code> decorator tracks function execution - When the function runs, ping status changes to \"HealthyBusy\" - When the function completes, status returns to \"Healthy\"</p>"},{"location":"user-guide/runtime/async.html#2-manual-task-management","title":"2. Manual Task Management","text":"<p>For more control over task tracking, use the API methods directly:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nimport threading\nimport time\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef handler(event):\n    \"\"\"Start tracking a task manually\"\"\"\n    # Start tracking the task\n    task_id = app.add_async_task(\"data_processing\", {\"batch\": 100})\n\n    # Start background work\n    def background_work():\n        time.sleep(30)  # Simulate work\n        app.complete_async_task(task_id)  # Mark as complete\n\n    threading.Thread(target=background_work, daemon=True).start()\n\n    return {\"status\": \"Task started\", \"task_id\": task_id}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>API Methods: - <code>app.add_async_task(name, metadata)</code> - Start tracking a task - <code>app.complete_async_task(task_id)</code> - Mark task as complete - <code>app.get_async_task_info()</code> - Get information about running tasks</p>"},{"location":"user-guide/runtime/async.html#3-custom-ping-handler","title":"3. Custom Ping Handler","text":"<p>Override automatic status with custom logic:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom bedrock_agentcore.runtime.models import PingStatus\n\napp = BedrockAgentCoreApp()\n\n# Global state to track custom conditions\nprocessing_data = False\n\n@app.ping\ndef custom_status():\n    \"\"\"Custom ping handler with your own logic\"\"\"\n    if processing_data or system_busy():\n        return PingStatus.HEALTHY_BUSY\n    return PingStatus.HEALTHY\n\n@app.entrypoint\ndef handler(event):\n    global processing_data\n\n    if event.get(\"action\") == \"start_processing\":\n        processing_data = True\n        # Start your processing...\n        return {\"status\": \"Processing started\"}\n\n    return {\"status\": \"Ready\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/runtime/async.html#complete-example-with-strands","title":"Complete Example with Strands","text":"<p>Here's a practical example combining async tasks with the Strands AI framework:</p> <pre><code>import threading\nimport time\nfrom strands import Agent, tool\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\n# Initialize app with debug mode for task management\napp = BedrockAgentCoreApp(debug=True)\n\n@tool\ndef start_background_task(duration: int = 5) -&gt; str:\n    \"\"\"Start a simple background task that runs for specified duration.\"\"\"\n    # Start tracking the async task\n    task_id = app.add_async_task(\"background_processing\", {\"duration\": duration})\n\n    # Run task in background thread\n    def background_work():\n        time.sleep(duration)  # Simulate work\n        app.complete_async_task(task_id)  # Mark as complete\n\n    threading.Thread(target=background_work, daemon=True).start()\n    return f\"Started background task (ID: {task_id}) for {duration} seconds. Agent status is now BUSY.\"\n\n# Create agent with the tool\nagent = Agent(tools=[start_background_task])\n\n@app.entrypoint\ndef main(payload):\n    \"\"\"Main entrypoint - handles user messages.\"\"\"\n    user_message = payload.get(\"prompt\", \"Try: start_background_task(3)\")\n    return {\"message\": agent(user_message).message}\n\nif __name__ == \"__main__\":\n    print(\"\ud83d\ude80 Simple Async Strands Example\")\n    print(\"Test: curl -X POST http://localhost:8080/invocations -H 'Content-Type: application/json' -d '{\\\"prompt\\\": \\\"start a 3 second task\\\"}'\")\n    app.run()\n</code></pre> <p>This example demonstrates: - Creating a background task that runs asynchronously - Tracking the task's status with <code>add_async_task</code> and <code>complete_async_task</code> - Responding immediately to the user while processing continues - Managing the agent's health status automatically</p>"},{"location":"user-guide/runtime/async.html#ping-status-priority","title":"Ping Status Priority","text":"<p>The ping status is determined in this priority order:</p> <ol> <li>Forced Status (debug actions like <code>force_busy</code>)</li> <li>Custom Handler (<code>@app.ping</code> decorator)</li> <li>Automatic (based on active <code>@app.async_task</code> functions)</li> </ol>"},{"location":"user-guide/runtime/async.html#debug-and-testing-features","title":"Debug and Testing Features","text":"<p>Enable debug mode for additional testing capabilities:</p> <pre><code>app = BedrockAgentCoreApp(debug=True)\n</code></pre> <p>Debug Actions (via POST with <code>\"_agent_core_app_action\"</code>): - <code>\"ping_status\"</code> - Check current status - <code>\"job_status\"</code> - List running tasks - <code>\"force_busy\"</code> / <code>\"force_healthy\"</code> - Force status - <code>\"clear_forced_status\"</code> - Clear forced status</p> <p>API Methods: <pre><code>task_id = app.add_async_task(\"task_name\", metadata={})\nsuccess = app.complete_async_task(task_id)\nstatus = app.get_current_ping_status()\ninfo = app.get_async_task_info()\n</code></pre></p>"},{"location":"user-guide/runtime/async.html#testing-your-async-agent","title":"Testing Your Async Agent","text":""},{"location":"user-guide/runtime/async.html#local-testing-with-curl","title":"Local Testing with curl","text":"<pre><code># Start your agent\npython my_async_agent.py\n\n# Test ping endpoint\ncurl http://localhost:8080/ping\n\n# Start a background task\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"start a background task\"}'\n\n# Check if status changed to HealthyBusy\ncurl http://localhost:8080/ping\n</code></pre>"},{"location":"user-guide/runtime/async.html#local-testing-with-agentcore-cli","title":"Local Testing with AgentCore CLI","text":"<pre><code># Configure and test locally\nagentcore configure -e my_async_agent.py\nagentcore launch -l\n\n# Test in another terminal\nagentcore invoke '{\"prompt\": \"start processing\"}' -l\n\n# Check status via ping\ncurl http://localhost:8080/ping\n</code></pre>"},{"location":"user-guide/runtime/async.html#common-patterns","title":"Common Patterns","text":"<p>Long-Running Processing: <pre><code>@tool\ndef start_data_processing(dataset_size: str = \"medium\") -&gt; str:\n    task_id = app.add_async_task(\"data_processing\", {\"size\": dataset_size})\n\n    def process_data():\n        time.sleep(1800)  # Simulate processing\n        app.complete_async_task(task_id)\n\n    threading.Thread(target=process_data, daemon=True).start()\n    return f\"\ud83d\ude80 Processing started (Task {task_id}). I'll continue in the background!\"\n</code></pre></p> <p>Progress Monitoring: <pre><code>def save_progress(task_id: int, progress: dict):\n    with open(f\"task_progress_{task_id}.json\", 'w') as f:\n        json.dump(progress, f)\n\n@tool\ndef get_progress(task_id: int = None) -&gt; str:\n    # Find and read progress file\n    # Return formatted status\n    pass\n</code></pre></p>"},{"location":"user-guide/runtime/notebook.html","title":"Jupyter Notebook Support","text":"<p>Local Testing Only</p> <p>The notebook interface is intended for local development and testing only. It has rough edges and is not recommended for production use. For production deployment, use the Boto3 SDK instead.</p> <p>The AgentCore Runtime provides basic Jupyter notebook support for quick experimentation and testing.</p>"},{"location":"user-guide/runtime/notebook.html#basic-example","title":"Basic Example","text":"<pre><code># Import the notebook Runtime class\nfrom bedrock_agentcore_starter_toolkit.notebook import Runtime\n\n# Initialize\nruntime = Runtime()\n\n# Configure your agent\nconfig = runtime.configure(\n    entrypoint=\"my_agent.py\",\n    execution_role=\"arn:aws:iam::123456789012:role/MyExecutionRole\"\n)\n\n# Test locally\nlocal_result = runtime.launch(local=True)\nprint(f\"Local container: {local_result.tag}\")\n\n# Test your agent\nresponse = runtime.invoke({\"prompt\": \"Hello from notebook!\"})\nprint(response)\n</code></pre>"},{"location":"user-guide/runtime/notebook.html#simple-agent-example","title":"Simple Agent Example","text":"<p>Create a simple agent file first:</p> <pre><code># my_agent.py\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef handler(payload):\n    prompt = payload.get(\"prompt\", \"Hello\")\n    return {\"result\": f\"You said: {prompt}\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Then use it in your notebook:</p> <pre><code>from bedrock_agentcore_starter_toolkit.notebook import Runtime\n\nruntime = Runtime()\n\n# Configure\nruntime.configure(\n    entrypoint=\"my_agent.py\",\n    execution_role=\"arn:aws:iam::123456789012:role/MyRole\"\n)\n\n# Launch locally for testing\nruntime.launch(local=True)\n\n# Test the agent\nresponse = runtime.invoke({\"prompt\": \"Test from notebook\"})\nprint(response)  # {\"result\": \"You said: Test from notebook\"}\n</code></pre>"},{"location":"user-guide/runtime/notebook.html#available-methods","title":"Available Methods","text":"<ul> <li><code>configure()</code> - Set up agent configuration</li> <li><code>launch(local=True)</code> - Build and run locally</li> <li><code>invoke(payload)</code> - Test your agent</li> <li><code>status()</code> - Check agent status</li> </ul>"},{"location":"user-guide/runtime/notebook.html#limitations","title":"Limitations","text":"<ul> <li>Local testing focus - Not optimized for production workflows</li> <li>Basic error handling - Limited error reporting compared to CLI</li> <li>Configuration limitations - Fewer options than full CLI interface</li> <li>No interactive prompts - All configuration must be provided programmatically</li> </ul> <p>For full-featured development and production deployment, use the AgentCore CLI instead.</p>"},{"location":"user-guide/runtime/overview.html","title":"AgentCore Runtime SDK Overview","text":"<p>The Amazon Bedrock AgentCore Runtime SDK transforms your Python functions into production-ready AI agents with built-in HTTP service wrapper, session management, and complete deployment workflows.</p>"},{"location":"user-guide/runtime/overview.html#quick-start","title":"Quick Start","text":"<pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef my_agent(payload):\n    return {\"result\": f\"Hello {payload.get('name', 'World')}!\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <pre><code># Configure and deploy your agent\nagentcore configure --entrypoint my_agent.py\nagentcore launch\nagentcore invoke '{\"name\": \"Alice\"}'\n</code></pre>"},{"location":"user-guide/runtime/overview.html#what-is-the-agentcore-runtime-sdk","title":"What is the AgentCore Runtime SDK?","text":"<p>The Runtime SDK is a comprehensive Python framework that bridges the gap between your AI agent code and Amazon Bedrock AgentCore's managed infrastructure. It provides HTTP service wrapper, decorator-based programming, session management, authentication integration, streaming support, async task management, and complete local development tools.</p>"},{"location":"user-guide/runtime/overview.html#core-components","title":"Core Components","text":"<p>BedrockAgentCoreApp - HTTP service wrapper with: - <code>/invocations</code> endpoint for agent logic - <code>/ping</code> endpoint for health checks - Built-in logging, error handling, and session management</p> <p>Key Decorators: - <code>@app.entrypoint</code> - Define your agent's main logic - <code>@app.ping</code> - Custom health checks - <code>@app.async_task</code> - Background processing</p>"},{"location":"user-guide/runtime/overview.html#deployment-modes","title":"Deployment Modes","text":""},{"location":"user-guide/runtime/overview.html#cloud-build-recommended","title":"\ud83d\ude80 Cloud Build (RECOMMENDED)","text":"<p><pre><code>agentcore configure --entrypoint my_agent.py\nagentcore launch                    # Uses CodeBuild - no Docker needed\n</code></pre> - No Docker required - builds in the cloud - Production-ready - standardized ARM64 containers - Works everywhere - SageMaker Notebooks, Cloud9, laptops</p>"},{"location":"user-guide/runtime/overview.html#local-development","title":"\ud83d\udcbb Local Development","text":"<p><pre><code>agentcore launch --local           # Build and run locally\n</code></pre> - Fast iteration - immediate feedback and debugging - Requires: Docker, Finch, or Podman</p>"},{"location":"user-guide/runtime/overview.html#hybrid-build","title":"\ud83d\udd27 Hybrid Build","text":"<p><pre><code>agentcore launch --local-build     # Build locally, deploy to cloud\n</code></pre> - Custom builds with cloud deployment - Requires: Docker, Finch, or Podman</p>"},{"location":"user-guide/runtime/overview.html#agent-development-patterns","title":"Agent Development Patterns","text":""},{"location":"user-guide/runtime/overview.html#synchronous-agents","title":"Synchronous Agents","text":"<pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef simple_agent(payload):\n    prompt = payload.get(\"prompt\", \"\")\n    if \"weather\" in prompt.lower():\n        return {\"result\": \"It's sunny today!\"}\n    return {\"result\": f\"You said: {prompt}\"}\n</code></pre>"},{"location":"user-guide/runtime/overview.html#streaming-agents","title":"Streaming Agents","text":"<pre><code>from strands import Agent\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\nagent = Agent()\n\n@app.entrypoint\nasync def streaming_agent(payload):\n    \"\"\"Streaming agent with real-time responses\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello\")\n\n    # Stream responses as they're generated\n    stream = agent.stream_async(user_message)\n    async for event in stream:\n        if \"data\" in event:\n            yield event[\"data\"]          # Stream data chunks\n        elif \"message\" in event:\n            yield event[\"message\"]       # Stream message parts\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Key Streaming Features: - Server-Sent Events (SSE): Automatic SSE formatting for web clients - Error Handling: Graceful error streaming with error events - Generator Support: Both sync and async generators supported - Real-time Processing: Immediate response chunks as they're available</p>"},{"location":"user-guide/runtime/overview.html#framework-integration","title":"Framework Integration","text":"<p>The SDK works seamlessly with popular AI frameworks:</p> <p>Strands Integration: <pre><code>from strands import Agent\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\nagent = Agent(tools=[your_tools])\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef strands_agent(payload):\n    result = agent(payload.get(\"prompt\"))\n    return {\"result\": result.message}\n</code></pre> Custom Framework Integration: <pre><code>@app.entrypoint\nasync def custom_framework_agent(payload):\n    \"\"\"Works with any async framework\"\"\"\n    response = await your_framework.process(payload)\n\n    # Can yield for streaming\n    for chunk in response.stream():\n        yield {\"chunk\": chunk}\n</code></pre></p>"},{"location":"user-guide/runtime/overview.html#session-management","title":"Session Management","text":"<p>Built-in session handling with automatic creation, 15-minute timeout, and cross-invocation persistence:</p> <pre><code>from bedrock_agentcore.runtime.context import RequestContext\n\n@app.entrypoint\ndef session_aware_agent(payload, context: RequestContext):\n    \"\"\"Agent with session awareness\"\"\"\n    session_id = context.session_id\n    user_message = payload.get(\"prompt\")\n\n    # Your session-aware logic here\n    return {\n        \"result\": f\"Session {session_id}: {user_message}\",\n        \"session_id\": session_id\n    }\n</code></pre> <pre><code># CLI session management\n# Using AgentCore CLI with session management\nagentcore invoke '{\"prompt\": \"Hello, remember this conversation\"}' --session-id \"conversation-123\"\n\nagentcore invoke '{\"prompt\": \"What did I say earlier?\"}' --session-id \"conversation-123\"\n</code></pre>"},{"location":"user-guide/runtime/overview.html#authentication-authorization","title":"Authentication &amp; Authorization","text":"<p>The SDK integrates with AgentCore's identity services providing automatic AWS credential validation (IAM SigV4) by default or JWT Bearer tokens for OAuth-compatible authentication:</p> <pre><code># Configure JWT authorization using AgentCore CLI\nagentcore configure --entrypoint my_agent.py \\\n  --authorizer-config '{\"customJWTAuthorizer\": {\"discoveryUrl\": \"https://cognito-idp.region.amazonaws.com/pool/.well-known/openid-configuration\", \"allowedClients\": [\"your-client-id\"]}}'\n</code></pre>"},{"location":"user-guide/runtime/overview.html#asynchronous-processing","title":"Asynchronous Processing","text":"<p>AgentCore Runtime supports asynchronous processing for long-running tasks. Your agent can start background work and immediately respond to users, with automatic health status management.</p>"},{"location":"user-guide/runtime/overview.html#key-features","title":"Key Features","text":"<p>Automatic Status Management: - Agent status changes to \"HealthyBusy\" during background processing - Returns to \"Healthy\" when tasks complete - Sessions automatically terminate after 15 minutes of inactivity</p> <p>Three Processing Approaches:</p> <ol> <li> <p>Async Task Decorator (Recommended) <pre><code>@app.async_task\nasync def background_work():\n    await process_data()  # Status becomes \"HealthyBusy\"\n    return \"done\"\n\n@app.entrypoint\nasync def handler(event):\n    asyncio.create_task(background_work())\n    return {\"status\": \"started\"}\n</code></pre></p> </li> <li> <p>Manual Task Management <pre><code>@app.entrypoint\ndef handler(event):\n    task_id = app.add_async_task(\"data_processing\", {\"batch\": 100})\n\n    def background_work():\n        time.sleep(30)\n        app.complete_async_task(task_id)\n\n    threading.Thread(target=background_work, daemon=True).start()\n    return {\"task_id\": task_id}\n</code></pre></p> </li> <li> <p>Custom Ping Handler <pre><code>@app.ping\ndef custom_status():\n    if processing_data or system_busy():\n        return PingStatus.HEALTHY_BUSY\n    return PingStatus.HEALTHY\n</code></pre></p> </li> </ol> <p>Common Use Cases: - Data processing that takes minutes or hours - File uploads and conversions - External API calls with retries - Batch operations and reports</p> <p>See the Async Processing Guide for detailed examples and testing strategies.</p>"},{"location":"user-guide/runtime/overview.html#local-development_1","title":"Local Development","text":""},{"location":"user-guide/runtime/overview.html#debug-mode","title":"Debug Mode","text":"<pre><code>app = BedrockAgentCoreApp(debug=True)  # Enhanced logging\n\nif __name__ == \"__main__\":\n    app.run()  # Auto-detects Docker vs local\n</code></pre>"},{"location":"user-guide/runtime/overview.html#complete-development-workflow","title":"Complete Development Workflow","text":"<pre><code># 1. Configure\nagentcore configure --entrypoint my_agent.py\n\n# 2. Develop locally\nagentcore launch --local\n\n# 3. Test\nagentcore invoke '{\"prompt\": \"Hello\"}'\nagentcore invoke '{\"prompt\": \"Remember this\"}' --session-id \"test\"\n\n# 4. Deploy to cloud\nagentcore launch\n\n# 5. Monitor\nagentcore status\n</code></pre> <p>The AgentCore Runtime SDK provides everything needed to build, test, and deploy production-ready AI agents with minimal setup and maximum flexibility.</p>"},{"location":"user-guide/runtime/permissions.html","title":"Runtime Permissions","text":"<p>This guide covers the IAM permissions required to run agents with Amazon Bedrock AgentCore Runtime. The toolkit supports two types of execution roles with distinct permission sets.</p> <p>Refer to AWS Bedrock AgentCore Runtime Permissions documentation for more details.</p>"},{"location":"user-guide/runtime/permissions.html#overview","title":"Overview","text":"<p>The toolkit requires two types of IAM roles for different phases of agent deployment:</p> <ul> <li>Runtime Execution Role: Used by Bedrock AgentCore Runtime to execute your agent</li> <li>CodeBuild Execution Role: Used by AWS CodeBuild to build and push container images (ARM64 architecture)</li> </ul> <p>Both roles can be automatically created by the toolkit or manually specified using existing roles.</p>"},{"location":"user-guide/runtime/permissions.html#auto-role-creation-feature","title":"Auto Role Creation Feature","text":""},{"location":"user-guide/runtime/permissions.html#overview_1","title":"Overview","text":"<p>The Bedrock AgentCore Starter Toolkit includes an auto role creation feature that automatically generates the Runtime Execution Role when you don't specify an existing role.</p>"},{"location":"user-guide/runtime/permissions.html#what-gets-auto-created","title":"What Gets Auto-Created","text":"<p>When you run <code>agentcore configure</code> without specifying the <code>--execution-role</code> parameter, the toolkit automatically creates:</p>"},{"location":"user-guide/runtime/permissions.html#runtime-execution-role","title":"Runtime Execution Role","text":"<ul> <li>Name: <code>AmazonBedrockAgentCoreSDKRuntime-{region}-{hash}</code></li> <li>Purpose: Used by Bedrock AgentCore to execute your agent</li> <li>Permissions: All required runtime permissions (ECR, CloudWatch, Bedrock, etc.)</li> </ul> <p>Note: The CodeBuild Execution Role (<code>AmazonBedrockAgentCoreSDKCodeBuild-{region}-{hash}</code>) is always auto-created when using CodeBuild deployment, regardless of this setting.</p>"},{"location":"user-guide/runtime/permissions.html#benefits-of-auto-role-creation","title":"Benefits of Auto Role Creation","text":"<p>\ud83d\ude80 Instant Setup <pre><code># One command creates everything you need\nagentcore configure -e my_agent.py\n</code></pre></p>"},{"location":"user-guide/runtime/permissions.html#usage-examples","title":"Usage Examples","text":"<p>Basic Auto-Creation: <pre><code># Creates all required roles and resources\nagentcore configure -e my_agent.py\n</code></pre></p> <p>Auto-Creation with Default Deployment: <pre><code># Uses CodeBuild by default\nagentcore configure -e my_agent.py\nagentcore launch\n</code></pre></p>"},{"location":"user-guide/runtime/permissions.html#developercaller-permissions","title":"Developer/Caller Permissions","text":""},{"location":"user-guide/runtime/permissions.html#overview_2","title":"Overview","text":"<p>Developers using the Bedrock AgentCore Starter Toolkit need specific IAM permissions to create roles, manage CodeBuild projects, and deploy agents. These permissions are separate from the execution roles and are required for the toolkit's operational functionality.</p>"},{"location":"user-guide/runtime/permissions.html#required-caller-policy","title":"Required Caller Policy","text":"<p>Attach the following policy to your IAM user or role:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"IAMRoleManagement\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iam:CreateRole\",\n                \"iam:DeleteRole\",\n                \"iam:GetRole\",\n                \"iam:PutRolePolicy\",\n                \"iam:DeleteRolePolicy\",\n                \"iam:AttachRolePolicy\",\n                \"iam:DetachRolePolicy\",\n                \"iam:TagRole\",\n                \"iam:ListRolePolicies\",\n                \"iam:ListAttachedRolePolicies\"\n            ],\n            \"Resource\": [\n                \"arn:aws:iam::*:role/*BedrockAgentCore*\",\n                \"arn:aws:iam::*:role/service-role/*BedrockAgentCore*\"\n            ]\n        },\n        {\n            \"Sid\": \"CodeBuildProjectAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"codebuild:StartBuild\",\n                \"codebuild:BatchGetBuilds\",\n                \"codebuild:ListBuildsForProject\",\n                \"codebuild:CreateProject\",\n                \"codebuild:UpdateProject\",\n                \"codebuild:BatchGetProjects\"\n            ],\n            \"Resource\": [\n                \"arn:aws:codebuild:*:*:project/bedrock-agentcore-*\",\n                \"arn:aws:codebuild:*:*:build/bedrock-agentcore-*\"\n            ]\n        },\n        {\n            \"Sid\": \"CodeBuildListAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"codebuild:ListProjects\"\n            ],\n            \"Resource\": \"*\"\n        },\n        {\n            \"Sid\": \"IAMPassRoleAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iam:PassRole\"\n            ],\n            \"Resource\": [\n                \"arn:aws:iam::*:role/AmazonBedrockAgentCore*\",\n                \"arn:aws:iam::*:role/service-role/AmazonBedrockAgentCore*\"\n            ]\n        },\n        {\n            \"Sid\": \"CloudWatchLogsAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:GetLogEvents\",\n                \"logs:DescribeLogGroups\",\n                \"logs:DescribeLogStreams\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:*:*:log-group:/aws/bedrock-agentcore/*\",\n                \"arn:aws:logs:*:*:log-group:/aws/codebuild/*\"\n            ]\n        },\n        {\n            \"Sid\": \"S3Access\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:GetObject\",\n                \"s3:PutObject\",\n                \"s3:ListBucket\",\n                \"s3:CreateBucket\",\n                \"s3:PutLifecycleConfiguration\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::bedrock-agentcore-*\",\n                \"arn:aws:s3:::bedrock-agentcore-*/*\"\n            ]\n        },\n        {\n            \"Sid\": \"ECRRepositoryAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:CreateRepository\",\n                \"ecr:DescribeRepositories\",\n                \"ecr:GetRepositoryPolicy\",\n                \"ecr:InitiateLayerUpload\",\n                \"ecr:CompleteLayerUpload\",\n                \"ecr:PutImage\",\n                \"ecr:UploadLayerPart\",\n                \"ecr:BatchCheckLayerAvailability\",\n                \"ecr:GetDownloadUrlForLayer\",\n                \"ecr:BatchGetImage\",\n                \"ecr:ListImages\",\n                \"ecr:TagResource\"\n            ],\n            \"Resource\": [\n                \"arn:aws:ecr:*:*:repository/bedrock-agentcore-*\"\n            ]\n        },\n        {\n            \"Sid\": \"ECRAuthorizationAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:GetAuthorizationToken\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#additional-required-permissions","title":"Additional Required Permissions","text":"<p>You also need: - AgentCore Full Access: <code>BedrockAgentCoreFullAccess</code> managed policy - Bedrock Access (one of the following):   - Option 1 (Development): <code>AmazonBedrockFullAccess</code> managed policy   - Option 2 (Production Recommended): Custom policy with scoped permissions for specific models and actions</p>"},{"location":"user-guide/runtime/permissions.html#production-security-best-practices","title":"Production Security Best Practices","text":"<p>When moving from development to production, consider these security enhancements:</p>"},{"location":"user-guide/runtime/permissions.html#1-scope-down-resource-access","title":"1. Scope Down Resource Access","text":"<p>Instead of granting broad access to all resources, limit permissions to specific resources:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"LimitedModelAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:InvokeModelWithResponseStream\"\n            ],\n            \"Resource\": [\n                \"arn:aws:bedrock:region:accountId:foundation-model/anthropic.claude-3-sonnet-20240229-v1:0\",\n                \"arn:aws:bedrock:region:accountId:foundation-model/anthropic.claude-3-haiku-20240307-v1:0\"\n            ]\n        },\n        {\n            \"Sid\": \"LimitedECRAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:BatchGetImage\",\n                \"ecr:GetDownloadUrlForLayer\"\n            ],\n            \"Resource\": [\n                \"arn:aws:ecr:region:accountId:repository/bedrock-agentcore-your-agent-name\"\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#2-use-infrastructure-as-code","title":"2. Use Infrastructure as Code","text":"<p>Consider using AWS CDK, CloudFormation, or Terraform to define your roles with precise permissions.</p>"},{"location":"user-guide/runtime/permissions.html#codebuild-integration","title":"CodeBuild Integration","text":"<p>The toolkit uses AWS CodeBuild for ARM64 container builds, especially useful in cloud development environments where Docker is not available (such as SageMaker notebooks, Cloud9, or other managed environments).</p>"},{"location":"user-guide/runtime/permissions.html#runtime-execution-role_1","title":"Runtime Execution Role","text":"<p>The Runtime Execution Role is an IAM role that AgentCore Runtime assumes to run an agent. Replace the following:</p> <ul> <li><code>region</code> with the AWS Region that you are using</li> <li><code>accountId</code> with your AWS account ID  </li> <li><code>agentName</code> with the name of your agent. You'll need to decide the agent name before creating the role and AgentCore Runtime.</li> </ul>"},{"location":"user-guide/runtime/permissions.html#permissions-policy","title":"Permissions Policy","text":"<pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"ECRImageAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:BatchGetImage\",\n                \"ecr:GetDownloadUrlForLayer\"\n            ],\n            \"Resource\": [\n                \"arn:aws:ecr:region:accountId:repository/*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:DescribeLogStreams\",\n                \"logs:CreateLogGroup\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:region:accountId:log-group:/aws/bedrock-agentcore/runtimes/*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:DescribeLogGroups\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:region:accountId:log-group:*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:region:accountId:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*\"\n            ]\n        },\n        {\n            \"Sid\": \"ECRTokenAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:GetAuthorizationToken\"\n            ],\n            \"Resource\": \"*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"xray:PutTraceSegments\",\n                \"xray:PutTelemetryRecords\",\n                \"xray:GetSamplingRules\",\n                \"xray:GetSamplingTargets\"\n            ],\n            \"Resource\": [\"*\"]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Resource\": \"*\",\n            \"Action\": \"cloudwatch:PutMetricData\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"cloudwatch:namespace\": \"bedrock-agentcore\"\n                }\n            }\n        },\n        {\n            \"Sid\": \"GetAgentAccessToken\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock-agentcore:GetWorkloadAccessToken\",\n                \"bedrock-agentcore:GetWorkloadAccessTokenForJWT\",\n                \"bedrock-agentcore:GetWorkloadAccessTokenForUserId\"\n            ],\n            \"Resource\": [\n                \"arn:aws:bedrock-agentcore:region:accountId:workload-identity-directory/default\",\n                \"arn:aws:bedrock-agentcore:region:accountId:workload-identity-directory/default/workload-identity/agentName-*\"\n            ]\n        },\n        {\n            \"Sid\": \"BedrockModelInvocation\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:InvokeModelWithResponseStream\"\n            ],\n            \"Resource\": [\n                \"arn:aws:bedrock:*::foundation-model/*\",\n                \"arn:aws:bedrock:region:accountId:*\"\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#trust-policy","title":"Trust Policy","text":"<p>The trust relationship for the AgentCore Runtime execution role should allow AgentCore Runtime to assume the role:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"AssumeRolePolicy\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"bedrock-agentcore.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\",\n      \"Condition\": {\n            \"StringEquals\": {\n                \"aws:SourceAccount\": \"accountId\"\n            },\n            \"ArnLike\": {\n                \"aws:SourceArn\": \"arn:aws:bedrock-agentcore:region:accountId:*\"\n            }\n       }\n    }\n  ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#codebuild-execution-role","title":"CodeBuild Execution Role","text":"<p>The CodeBuild Execution Role is used by AWS CodeBuild to build your agent's Docker container for ARM64 architecture and push it to Amazon ECR.</p>"},{"location":"user-guide/runtime/permissions.html#trust-policy_1","title":"Trust Policy","text":"<p>The CodeBuild execution role must trust the <code>codebuild.amazonaws.com</code> service:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"codebuild.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"aws:SourceAccount\": \"YOUR_ACCOUNT_ID\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#permissions-policy_1","title":"Permissions Policy","text":"<p>The CodeBuild execution role requires the following permissions:</p>"},{"location":"user-guide/runtime/permissions.html#ecr-repository-access","title":"ECR Repository Access","text":"<pre><code>{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"ecr:GetAuthorizationToken\"\n  ],\n  \"Resource\": \"*\"\n},\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"ecr:BatchCheckLayerAvailability\",\n    \"ecr:BatchGetImage\",\n    \"ecr:GetDownloadUrlForLayer\",\n    \"ecr:PutImage\",\n    \"ecr:InitiateLayerUpload\",\n    \"ecr:UploadLayerPart\",\n    \"ecr:CompleteLayerUpload\"\n  ],\n  \"Resource\": \"arn:aws:ecr:YOUR_REGION:YOUR_ACCOUNT_ID:repository/YOUR_ECR_REPOSITORY\"\n}\n</code></pre> <p>Purpose: Allows CodeBuild to authenticate with ECR and push the built container image.</p>"},{"location":"user-guide/runtime/permissions.html#cloudwatch-logs-for-build-process","title":"CloudWatch Logs for Build Process","text":"<pre><code>{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"logs:CreateLogGroup\",\n    \"logs:CreateLogStream\",\n    \"logs:PutLogEvents\"\n  ],\n  \"Resource\": [\n    \"arn:aws:logs:YOUR_REGION:YOUR_ACCOUNT_ID:log-group:/aws/codebuild/bedrock-agentcore-*\"\n  ]\n}\n</code></pre> <p>Purpose: Enables CodeBuild to create and write to log groups for build monitoring.</p>"},{"location":"user-guide/runtime/permissions.html#s3-source-access","title":"S3 Source Access","text":"<pre><code>{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"s3:GetObject\"\n  ],\n  \"Resource\": [\n    \"arn:aws:s3:::bedrock-agentcore-codebuild-sources-YOUR_ACCOUNT_ID-YOUR_REGION/*\"\n  ]\n}\n</code></pre> <p>Purpose: Allows CodeBuild to access the source code uploaded to the toolkit's managed S3 bucket.</p>"},{"location":"user-guide/runtime/permissions.html#toolkit-implementation-details","title":"Toolkit Implementation Details","text":""},{"location":"user-guide/runtime/permissions.html#role-naming-convention","title":"Role Naming Convention","text":"<p>The toolkit uses deterministic naming for auto-created roles:</p> <ul> <li>Runtime Role: <code>AmazonBedrockAgentCoreSDKRuntime-{region}-{hash}</code></li> <li>CodeBuild Role: <code>AmazonBedrockAgentCoreSDKCodeBuild-{region}-{hash}</code></li> </ul> <p>Where <code>{hash}</code> is a deterministic 10-character hash based on your agent name, ensuring consistent role names across deployments.</p>"},{"location":"user-guide/runtime/quickstart.html","title":"QuickStart: Your First Agent in 5 Minutes! \ud83d\ude80","text":"<p>Get your AI agent running on Amazon Bedrock AgentCore in 3 simple steps.</p>"},{"location":"user-guide/runtime/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>AWS Account with credentials configured (<code>aws configure</code>)</li> <li>Python 3.10+ installed</li> <li>AWS Permissions:</li> <li><code>BedrockAgentCoreFullAccess</code> managed policy</li> <li><code>AmazonBedrockFullAccess</code> managed policy</li> <li>Caller permissions: See detailed policy here</li> <li>Model Access: Anthropic Claude 4.0 enabled in Amazon Bedrock console</li> </ul>"},{"location":"user-guide/runtime/quickstart.html#step-1-install-and-create-your-agent","title":"Step 1: Install and Create Your Agent","text":"<pre><code># Install both packages\npip install bedrock-agentcore strands-agents bedrock-agentcore-starter-toolkit\n</code></pre> <p>Create <code>my_agent.py</code>:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom strands import Agent\n\napp = BedrockAgentCoreApp()\nagent = Agent()\n\n@app.entrypoint\ndef invoke(payload):\n    \"\"\"Your AI agent function\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello! How can I help you today?\")\n    result = agent(user_message)\n    return {\"result\": result.message}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Create <code>requirements.txt</code>: <pre><code>bedrock-agentcore\nstrands-agents\n</code></pre></p> <p>Run <pre><code>cat &gt; requirements.txt &lt;&lt; EOF\nbedrock-agentcore\nstrands-agents\nEOF\n</code></pre></p>"},{"location":"user-guide/runtime/quickstart.html#step-2-test-locally","title":"Step 2: Test Locally","text":"<pre><code># Start your agent\npython my_agent.py\n\n# Test it (in another terminal)\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"Hello!\"}'\n</code></pre> <p>\u2705 Success: You should see a response like <code>{\"result\": \"Hello! I'm here to help...\"}</code></p>"},{"location":"user-guide/runtime/quickstart.html#step-3-deploy-to-aws","title":"Step 3: Deploy to AWS","text":"<pre><code># Configure and deploy (auto-creates all required resources)\nagentcore configure -e my_agent.py\nagentcore launch\n\n# Test your deployed agent\nagentcore invoke '{\"prompt\": \"tell me a joke\"}'\n</code></pre> <p>\ud83c\udf89 Congratulations! Your agent is now running on Amazon Bedrock AgentCore!</p> <p>\ud83d\udca1 Tip: The toolkit auto-creates IAM roles and ECR repositories - no manual setup needed!</p>"},{"location":"user-guide/runtime/quickstart.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/runtime/quickstart.html#common-issues","title":"Common Issues","text":"<p>\"Port 8080 already in use\" <pre><code># Find and stop the process using port 8080\nlsof -ti:8080 | xargs kill -9\n</code></pre></p> <p>\"Permission denied\" errors - Verify AWS credentials: <code>aws sts get-caller-identity</code> - Check you have the required managed policies attached - Review caller permissions policy for detailed requirements</p> <p>\"Docker not found\" warnings - \u2705 Ignore this! Default deployment uses CodeBuild (no Docker needed) - Only install Docker/Finch/Podman if you want to use <code>--local</code> or <code>--local-build</code> flags</p> <p>\"Model access denied\" - Enable Anthropic Claude 4.0 in the Bedrock console - Make sure you're in the correct AWS region (us-west-2 by default)</p> <p>\"CodeBuild build error\" - Check CodeBuild project logs in AWS console - Verify your caller permissions include CodeBuild access</p>"},{"location":"user-guide/runtime/quickstart.html#getting-help","title":"Getting Help","text":"<ul> <li>Detailed permissions: Runtime Permissions Guide</li> <li>Advanced deployment: Runtime Overview</li> <li>More examples: Examples Directory</li> </ul>"},{"location":"user-guide/runtime/quickstart.html#advanced-options-optional","title":"Advanced Options (Optional)","text":"\ud83d\udd27 Click to expand advanced configuration options  ### Deployment Modes  Choose the right deployment approach for your needs:  **\ud83d\ude80 Default: CodeBuild + Cloud Runtime (RECOMMENDED)** <pre><code>agentcore launch  # Uses CodeBuild (no Docker needed)\n</code></pre> Perfect for production, managed environments, teams without Docker  **\ud83d\udcbb Local Development** <pre><code>agentcore launch --local  # Build and run locally (requires Docker/Finch/Podman)\n</code></pre> Perfect for development, rapid iteration, debugging  **\ud83d\udd27 Hybrid: Local Build + Cloud Runtime** <pre><code>agentcore launch --local-build  # Build locally, deploy to cloud (requires Docker/Finch/Podman)\n</code></pre> Perfect for teams with Docker expertise needing build customization  ### Custom Roles <pre><code># Use existing IAM role\nagentcore configure -e my_agent.py --execution-role arn:aws:iam::123456789012:role/MyRole\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#next-steps","title":"Next Steps","text":"<p>Ready to build something more advanced?</p> <ul> <li>Runtime Overview - Deep dive into AgentCore features</li> <li>Memory Guide - Add persistent memory</li> <li>Gateway Tools - Connect external APIs</li> <li>Examples - More complete examples</li> </ul>"}]}